<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CWT.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace.cwt</a> &gt; <span class="el_source">CWT.java</span></div><h1>CWT.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019, RISE AB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
package se.sics.ace.cwt;

import java.security.Security;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.bouncycastle.crypto.InvalidCipherTextException;

import se.sics.ace.AccessToken;
import se.sics.ace.Constants;
import se.sics.ace.AceException;
import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.Attribute;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.EncryptMessage;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.MAC0Message;
import org.eclipse.californium.cose.MACMessage;
import org.eclipse.californium.cose.Message;
import org.eclipse.californium.cose.OneKey;
import org.eclipse.californium.cose.Recipient;
import org.eclipse.californium.cose.Sign1Message;
import org.eclipse.californium.cose.SignMessage;
import org.eclipse.californium.cose.Signer;

import com.upokecenter.cbor.CBORObject;

/**
 * Implements CWTs.
 * 
 * @author Ludwig Seitz
 *
 */
public class CWT implements AccessToken {
    
    static {
<span class="fc" id="L72">        Security.addProvider(</span>
                new org.bouncycastle.jce.provider.BouncyCastleProvider());
<span class="fc" id="L74">    }</span>

	private Map&lt;Short, CBORObject&gt; claims;	
	
	/**
	 * Creates a new CWT without a COSE wrapper.
	 * 
	 * @param claims  the map of claims.
	 */
<span class="fc" id="L83">	public CWT(Map&lt;Short, CBORObject&gt; claims) {</span>
<span class="fc" id="L84">		this.claims = new HashMap&lt;&gt; (claims);</span>
<span class="fc" id="L85">	}</span>
	
	/**
	 * Parse and validate the COSE wrapper of a CWT.
	 * 
	 * @param COSE_CWT  the raw bytes of the COSE object containing the CWT
	 * @param ctx  the crypto context
	 * @return  the CWT object wrapped by the COSE object
	 * @throws CoseException 
	 * @throws AceException 
 	 *
	 * @throws Exception 
	 */
	public static CWT processCOSE(byte[] COSE_CWT, CwtCryptoCtx ctx) 
			throws CoseException, AceException, Exception {
<span class="fc" id="L100">	    CBORObject cbor = CBORObject.DecodeFromBytes(COSE_CWT);</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">	    if (cbor.HasTag(61)) {</span>
<span class="nc" id="L102">	        cbor = cbor.UntagOne();</span>
	    }
<span class="fc" id="L104">		Message coseRaw = Message.DecodeFromBytes(cbor.EncodeToBytes());</span>
		
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (coseRaw instanceof SignMessage) {</span>
<span class="fc" id="L107">			SignMessage signed = (SignMessage)coseRaw;</span>
			//Check all signers, if kid is present compare that first
<span class="fc" id="L109">			CBORObject myKid = ctx.getPublicKey().get(</span>
<span class="fc" id="L110">					CBORObject.FromObject(HeaderKeys.KID));</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">			for (Signer s : signed.getSignerList()) {</span>
<span class="fc" id="L112">				CBORObject kid = s.findAttribute(HeaderKeys.KID);</span>
<span class="pc bpc" id="L113" title="3 of 4 branches missed.">				if (myKid == null || myKid.equals(kid)) {</span>
<span class="fc" id="L114">					s.setKey(ctx.getPublicKey());</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">					if(signed.validate(s)) {</span>
<span class="fc" id="L116">						return new CWT(Constants.getParams(</span>
<span class="fc" id="L117">								CBORObject.DecodeFromBytes(</span>
<span class="fc" id="L118">										signed.GetContent())));</span>
					}
				}
<span class="nc" id="L121">			}</span>
<span class="nc" id="L122">			throw new AceException(&quot;No valid signature found&quot;);	</span>
			
<span class="fc bfc" id="L124" title="All 2 branches covered.">		} else if (coseRaw instanceof Sign1Message) {</span>
<span class="fc" id="L125">			Sign1Message signed = (Sign1Message)coseRaw;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">			if (signed.validate(ctx.getPublicKey())) {</span>
<span class="fc" id="L127">				return new CWT(Constants.getParams(</span>
<span class="fc" id="L128">					CBORObject.DecodeFromBytes(signed.GetContent())));</span>
			}
			
<span class="pc bfc" id="L131" title="All 2 branches covered.">		} else if (coseRaw instanceof MACMessage) {</span>
<span class="fc" id="L132">			MACMessage maced = (MACMessage)coseRaw;</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">			for (Recipient me : ctx.getRecipients()) {</span>
<span class="fc" id="L134">				CBORObject myKid = me.findAttribute(HeaderKeys.KID);</span>
<span class="fc" id="L135">				CBORObject myAlg = me.findAttribute(HeaderKeys.Algorithm);</span>
<span class="fc" id="L136">				CBORObject key = CBORObject.NewMap();</span>
<span class="fc" id="L137">				key.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>
<span class="fc" id="L138">				key.Add(KeyKeys.Octet_K.AsCBOR(), CBORObject.FromObject(</span>
<span class="fc" id="L139">		        		me.getKey(AlgorithmID.FromCBOR(myAlg))));</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">				for (Recipient r : maced.getRecipientList()) {</span>
<span class="pc bpc" id="L141" title="3 of 4 branches missed.">					if (myKid == null || myKid.equals(</span>
<span class="nc" id="L142">							r.findAttribute(HeaderKeys.KID)))	{</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">						if (myAlg.equals(r.findAttribute(HeaderKeys.Algorithm))) {</span>
<span class="fc" id="L144">						    OneKey coseKey = new OneKey(key);</span>
<span class="fc" id="L145">						    r.SetKey(coseKey);			    </span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">						    if (maced.Validate(r)) {</span>
<span class="fc" id="L147">						        return new CWT(Constants.getParams(</span>
<span class="fc" id="L148">						                CBORObject.DecodeFromBytes(</span>
<span class="fc" id="L149">						                        maced.GetContent())));</span>
						    }
						}
					}
<span class="nc" id="L153">				}</span>
<span class="nc" id="L154">			}</span>
<span class="nc" id="L155">			throw new AceException(&quot;No valid MAC found&quot;);</span>
			
<span class="fc bfc" id="L157" title="All 2 branches covered.">		} else if (coseRaw instanceof MAC0Message) {</span>
<span class="fc" id="L158">			MAC0Message maced = (MAC0Message)coseRaw;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">			if (maced.Validate(ctx.getKey())) {</span>
<span class="fc" id="L160">				return new CWT(Constants.getParams(</span>
<span class="fc" id="L161">						CBORObject.DecodeFromBytes(maced.GetContent())));</span>
			}
			
<span class="pc bfc" id="L164" title="All 2 branches covered.">		} else if (coseRaw instanceof EncryptMessage) {</span>
<span class="fc" id="L165">			EncryptMessage encrypted = (EncryptMessage)coseRaw;</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">			for (Recipient me : ctx.getRecipients()) {</span>
<span class="fc" id="L167">				CBORObject myKid = me.findAttribute(HeaderKeys.KID);</span>
<span class="fc" id="L168">				CBORObject myAlg = me.findAttribute(HeaderKeys.Algorithm);</span>
<span class="fc" id="L169">				CBORObject key = CBORObject.NewMap();</span>
<span class="fc" id="L170">				key.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>
<span class="fc" id="L171">				key.Add(KeyKeys.Octet_K.AsCBOR(), CBORObject.FromObject(</span>
<span class="fc" id="L172">		        		me.getKey(AlgorithmID.FromCBOR(myAlg))));</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">				for (Recipient r : encrypted.getRecipientList()) {</span>
<span class="pc bpc" id="L174" title="3 of 4 branches missed.">					if (myKid == null || myKid.equals(</span>
<span class="nc" id="L175">							r.findAttribute(HeaderKeys.KID)))	{</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">						if (myAlg.equals(r.findAttribute(HeaderKeys.Algorithm))) {</span>
<span class="fc" id="L177">						    OneKey coseKey = new OneKey(key);</span>
<span class="fc" id="L178">							r.SetKey(coseKey);</span>
<span class="fc" id="L179">							byte[] plaintext = processDecrypt(encrypted, r);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">							if (plaintext != null) {</span>
<span class="fc" id="L181">								return new CWT(Constants.getParams(</span>
<span class="fc" id="L182">										CBORObject.DecodeFromBytes(</span>
												plaintext)));
							}
						}
					}
<span class="nc" id="L187">				}</span>
<span class="nc" id="L188">			}</span>
<span class="nc" id="L189">			throw new AceException(&quot;No valid key for ciphertext found&quot;);</span>
			
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">		} else if (coseRaw instanceof Encrypt0Message) {</span>
<span class="fc" id="L192">			Encrypt0Message encrypted = (Encrypt0Message)coseRaw;</span>
<span class="fc" id="L193">			return new CWT(Constants.getParams(</span>
<span class="fc" id="L194">					CBORObject.DecodeFromBytes(encrypted.decrypt(</span>
<span class="fc" id="L195">							ctx.getKey()))));</span>
		}
<span class="nc" id="L197">		throw new AceException(&quot;Unknown or invalid COSE crypto wrapper&quot;);</span>
	}
	
	private static byte[] processDecrypt(EncryptMessage m, Recipient r) {
		try {
<span class="fc" id="L202">			return m.decrypt(r);</span>
<span class="nc" id="L203">		} catch (CoseException e) {</span>
<span class="nc" id="L204">		    e.printStackTrace();</span>
<span class="nc" id="L205">			return null;</span>
		}
	}
	
	/**
	 * Encodes this CWT as CBOR Map without crypto wrapper.
	 * 
	 * @return  the claims as CBOR Map.
	 */
	@Override
	public CBORObject encode() {
<span class="fc" id="L216">	    return Constants.getCBOR(this.claims);</span>
	}
	
	/**
	 * Encodes this CWT with a COSE crypto wrapper.
	 *
	 * @param ctx  the crypto context.
	 * @param pHeaders  additional protected COSE header parameters
	 * @param uHeaders additional unprotected COSE header parameters
	 * @return  the claims as CBOR Map.
	 * @throws CoseException 
	 * @throws InvalidCipherTextException 
	 * @throws IllegalStateException 
	 * @throws AceException 
	 */
	public CBORObject encode(CwtCryptoCtx ctx, 
	        Map&lt;HeaderKeys, CBORObject&gt; pHeaders,
	        Map&lt;HeaderKeys, CBORObject&gt; uHeaders) 
	        throws IllegalStateException, InvalidCipherTextException, 
	               CoseException, AceException {
<span class="fc" id="L236">		CBORObject map = encode();</span>
<span class="pc bpc" id="L237" title="1 of 7 branches missed.">		switch (ctx.getMessageType()) {</span>
		
		case Encrypt0:
<span class="fc" id="L240">			Encrypt0Message coseE0 = new Encrypt0Message();</span>
<span class="fc" id="L241">			coseE0.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
					Attribute.PROTECTED);
<span class="fc" id="L243">			addHeaders(coseE0, pHeaders, true);</span>
<span class="fc" id="L244">			addHeaders(coseE0, uHeaders, false);</span>
<span class="fc" id="L245">			coseE0.SetContent(map.EncodeToBytes());</span>
<span class="fc" id="L246">			coseE0.encrypt(ctx.getKey());</span>
<span class="fc" id="L247">			return coseE0.EncodeToCBORObject();		</span>
			
		case Encrypt:
<span class="fc" id="L250">			EncryptMessage coseE = new EncryptMessage();</span>
<span class="fc" id="L251">			coseE.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
					Attribute.PROTECTED);
<span class="fc" id="L253">			addHeaders(coseE, pHeaders, true);</span>
<span class="fc" id="L254">            addHeaders(coseE, uHeaders, false);</span>
<span class="fc" id="L255">			coseE.SetContent(map.EncodeToBytes());</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">			for (Recipient r : ctx.getRecipients()) {</span>
<span class="fc" id="L257">				coseE.addRecipient(r);</span>
<span class="fc" id="L258">			}</span>
            try {
<span class="fc" id="L260">                coseE.encrypt();</span>
<span class="nc" id="L261">            } catch (Exception e) {</span>
                //Catching Jim's general &quot;not implemented&quot; exception
                //and casting it to something more useful
<span class="nc" id="L264">               throw new CoseException(e.getMessage());</span>
<span class="fc" id="L265">            }</span>
<span class="fc" id="L266">			return coseE.EncodeToCBORObject();</span>
			
		case Sign1:
<span class="fc" id="L269">			Sign1Message coseS1 = new Sign1Message();</span>
<span class="fc" id="L270">			coseS1.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
						Attribute.PROTECTED);
<span class="fc" id="L272">			addHeaders(coseS1, pHeaders, true);</span>
<span class="fc" id="L273">            addHeaders(coseS1, uHeaders, false);</span>
<span class="fc" id="L274">			coseS1.SetContent(map.EncodeToBytes());</span>
<span class="fc" id="L275">			coseS1.sign(ctx.getPrivateKey());</span>
<span class="fc" id="L276">			return coseS1.EncodeToCBORObject();	</span>
			
		case Sign:
<span class="fc" id="L279">			SignMessage coseS = new SignMessage();</span>
<span class="fc" id="L280">			coseS.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
					Attribute.PROTECTED);
<span class="fc" id="L282">			addHeaders(coseS, pHeaders, true);</span>
<span class="fc" id="L283">            addHeaders(coseS, uHeaders, false);</span>
<span class="fc" id="L284">			coseS.SetContent(map.EncodeToBytes());</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">			for (Signer s : ctx.getSigners()) {</span>
<span class="fc" id="L286">				coseS.AddSigner(s);</span>
<span class="fc" id="L287">			}</span>
<span class="fc" id="L288">			coseS.sign();</span>
<span class="fc" id="L289">			return coseS.EncodeToCBORObject();</span>
			
		case MAC:
<span class="fc" id="L292">			MACMessage coseM = new MACMessage();</span>
<span class="fc" id="L293">			coseM.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
					Attribute.PROTECTED);
<span class="fc" id="L295">			addHeaders(coseM, pHeaders, true);</span>
<span class="fc" id="L296">            addHeaders(coseM, uHeaders, false);</span>
<span class="fc" id="L297">			coseM.SetContent(map.EncodeToBytes());</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">			for (Recipient r : ctx.getRecipients()) {</span>
<span class="fc" id="L299">				coseM.addRecipient(r);</span>
<span class="fc" id="L300">			}</span>
			try {
<span class="fc" id="L302">                coseM.Create();</span>
<span class="nc" id="L303">            } catch (Exception e) {</span>
                //Catching Jim's general &quot;not implemented&quot; exception
                //and casting it to something more useful 
<span class="nc" id="L306">                throw new CoseException(e.getMessage());</span>
<span class="fc" id="L307">            }</span>
<span class="fc" id="L308">			return coseM.EncodeToCBORObject();</span>
			
		case MAC0:
<span class="fc" id="L311">			MAC0Message coseM0 = new MAC0Message();</span>
<span class="fc" id="L312">			coseM0.addAttribute(HeaderKeys.Algorithm, ctx.getAlg(), </span>
					Attribute.PROTECTED);
<span class="fc" id="L314">			addHeaders(coseM0, pHeaders, true);</span>
<span class="fc" id="L315">            addHeaders(coseM0, uHeaders, false);</span>
<span class="fc" id="L316">			coseM0.SetContent(map.EncodeToBytes());</span>
<span class="fc" id="L317">			coseM0.Create(ctx.getKey());</span>
<span class="fc" id="L318">			return coseM0.EncodeToCBORObject();</span>
			
		default:
<span class="nc" id="L321">			throw new AceException(&quot;Unknown COSE wrapper type&quot;);</span>
			
		}	
	}

	/**
	 * Add additional header parameters to a COSE message
	 * 
	 * @param m  the message
	 * @param headers  the parameters
	 * @param protect  are these protected or unprotected parameters
	 * (we don't currently support Not_Included parameters)
	 * 
	 * @throws CoseException
	 */
	private static void addHeaders(Message m, Map&lt;HeaderKeys, 
	        CBORObject&gt; headers, boolean protect) throws CoseException {
<span class="fc bfc" id="L338" title="All 2 branches covered.">	    if (headers == null) { </span>
<span class="fc" id="L339">	        return;</span>
	    }
<span class="fc bfc" id="L341" title="All 2 branches covered.">	    for (Map.Entry&lt;HeaderKeys, CBORObject&gt; h : headers.entrySet()) {</span>
<span class="fc" id="L342">            m.addAttribute(h.getKey(), h.getValue().EncodeToBytes(), </span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                    (protect ? Attribute.PROTECTED : Attribute.UNPROTECTED));</span>
<span class="fc" id="L344">        }   </span>
<span class="fc" id="L345">	}</span>
	
	/**
     * Encodes this CWT with a COSE crypto wrapper.
     *
     * @param ctx  the crypto context.
     * @return  the claims as CBOR Map.
     * @throws CoseException 
     * @throws InvalidCipherTextException 
     * @throws IllegalStateException 
     * @throws AceException 
     */
    public CBORObject encode(CwtCryptoCtx ctx) 
            throws IllegalStateException, InvalidCipherTextException, 
                   CoseException, AceException {
<span class="fc" id="L360">        return encode(ctx, null, null);</span>
    }
	
	
	/**
	 * Returns the value of a claim referenced by name or 
	 * null if this claim is not in the CWT.
	 * 
	 * @param name  the name of the claim
	 * @return  the value of the claim or null.
	 */
	public CBORObject getClaim(Short name) {
<span class="fc" id="L372">		return this.claims.get(name);</span>
	}
	
	/**
	 * @return  a list of all claims in this CWT.
	 */
	public Set&lt;Short&gt; getClaimKeys() {
<span class="fc" id="L379">		return this.claims.keySet();</span>
	}
	
	/**
	 * @return a copy of the claims in this CWT.
	 */
	public Map&lt;Short, CBORObject&gt; getClaims() {
<span class="fc" id="L386">	    return new HashMap&lt;&gt;(this.claims);</span>
	}
	
	/**
	 * Checks if the token is valid according to the nbf and exp claims
	 * (if present).  Does not check the crypto wrapper.
	 * 
	 * @param now  the current time in ms since January 1, 1970, 00:00:00 GMT
	 * @return  true if the CWT is valid, false if not
	 */
	@Override
	public boolean isValid(long now) {
		//Check nbf and exp for the found match
<span class="fc" id="L399">		CBORObject nbfO = this.claims.get(Constants.NBF);</span>
<span class="pc bpc" id="L400" title="1 of 4 branches missed.">		if (nbfO != null &amp;&amp;  nbfO.AsInt64()	&gt; now) {</span>
<span class="fc" id="L401">			return false;</span>
		}	
<span class="fc" id="L403">		CBORObject expO = this.claims.get(Constants.EXP);</span>
<span class="pc bpc" id="L404" title="1 of 4 branches missed.">		if (expO != null &amp;&amp; expO.AsInt64() &lt; now) {</span>
			//Token has expired
<span class="fc" id="L406">			return false;</span>
		}
<span class="fc" id="L408">		return true;</span>
	}
	
	/**
	 * Checks if the token is not expired according to the exp claim
	 * (if present).  Does not check anything else.
	 *  
	 * @param now  the current time in ms since January 1, 1970, 00:00:00 GMT
	 * @return  true if the CWT is expired false if it is still valid or has no expiration date
	 */
	@Override
	public boolean expired(long now) {
<span class="fc" id="L420">		CBORObject expO = this.claims.get(Constants.EXP);</span>
<span class="pc bpc" id="L421" title="1 of 4 branches missed.">		if (expO != null &amp;&amp; expO.AsInt64() &lt; now) {</span>
			//Token has expired
<span class="fc" id="L423">			return true;</span>
		}
<span class="fc" id="L425">		return false;		</span>
	}
	
	@Override
	public String toString() {
<span class="nc" id="L430">	    return this.claims.toString();</span>
	}

    @Override
    public String getCti() throws AceException {
<span class="fc" id="L435">        CBORObject cti = this.claims.get(Constants.CTI);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (cti == null) {</span>
<span class="nc" id="L437">            throw new AceException(&quot;Token has no cti&quot;);</span>
        }
<span class="fc" id="L439">        return Base64.getEncoder().encodeToString(cti.GetByteString());</span>
    }
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
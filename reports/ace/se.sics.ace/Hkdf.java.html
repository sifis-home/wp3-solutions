<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Hkdf.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace</a> &gt; <span class="el_source">Hkdf.java</span></div><h1>Hkdf.java</h1><pre class="source lang-java linenums">package se.sics.ace;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import net.i2p.crypto.eddsa.Utils;

<span class="nc" id="L12">public class Hkdf {</span>

	private static final int hashLen = 32;
	
	/**
	 * HMAC-based Extract-and-Expand Key Derivation Function.
	 * https://tools.ietf.org/html/rfc5869
	 * 
	 * @param salt optional salt value
	 * @param ikm input keying material
	 * @param info context and application specific information
	 * @param len length of output keying material in octets
	 * @return output keying material
	 * 
	 * @throws InvalidKeyException if the HMAC procedure fails
	 * @throws NoSuchAlgorithmException if an unknown HMAC is used
	 */
	public static byte[] extractExpand(byte[] salt, byte[] ikm, byte[] info, int len)
			throws InvalidKeyException, NoSuchAlgorithmException {

<span class="fc" id="L32">		final String digest = &quot;SHA256&quot;; // Hash to use</span>

<span class="fc" id="L34">		String HMAC_ALG_NAME = &quot;Hmac&quot; + digest;</span>
<span class="fc" id="L35">		Mac hmac = Mac.getInstance(HMAC_ALG_NAME);</span>
<span class="fc" id="L36">		int hashLen = hmac.getMacLength();</span>

		// Perform extract
<span class="fc" id="L39">		hmac.init(new SecretKeySpec(salt, HMAC_ALG_NAME));</span>
<span class="fc" id="L40">		byte[] rgbExtract = hmac.doFinal(ikm);</span>

		// Perform expand
<span class="fc" id="L43">		hmac.init(new SecretKeySpec(rgbExtract, HMAC_ALG_NAME));</span>
<span class="fc" id="L44">		int c = (len / hashLen) + 1;</span>
<span class="fc" id="L45">		byte[] okm = new byte[len];</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">		int maxLen = (hashLen * c &gt; len) ? hashLen * c : len;</span>
<span class="fc" id="L47">		byte[] T = new byte[maxLen];</span>
<span class="fc" id="L48">		byte[] last = new byte[0];</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">		for (int i = 0; i &lt; c; i++) {</span>
<span class="fc" id="L50">			hmac.reset();</span>
<span class="fc" id="L51">			hmac.update(last);</span>
<span class="fc" id="L52">			hmac.update(info);</span>
<span class="fc" id="L53">			hmac.update((byte) (i + 1));</span>
<span class="fc" id="L54">			last = hmac.doFinal();</span>
<span class="fc" id="L55">			System.arraycopy(last, 0, T, i * hashLen, hashLen);</span>
		}
<span class="fc" id="L57">		System.arraycopy(T, 0, okm, 0, len);</span>
<span class="fc" id="L58">		return okm;</span>
	}
	
	/**
	 * Returns the length of the hash output, in bytes
	 * @return   the length of the hash output
	 */
	public static int getHashLen() {
<span class="fc" id="L66">		return hashLen;</span>
	}
	
	// https://tools.ietf.org/html/rfc5869#appendix-A.1
	// Could be put in standalone JUnit test
	public static void main(String[] args) throws Exception {
<span class="nc" id="L72">		byte[] ikm = new byte[] { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,</span>
				0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b };
<span class="nc" id="L74">		byte[] salt = new byte[] { (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05,</span>
				(byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b, (byte) 0x0c };
<span class="nc" id="L76">		byte[] info = new byte[] { (byte) 0xf0, (byte) 0xf1, (byte) 0xf2, (byte) 0xf3, (byte) 0xf4, (byte) 0xf5,</span>
				(byte) 0xf6, (byte) 0xf7, (byte) 0xf8, (byte) 0xf9 };
<span class="nc" id="L78">		int L = 42;</span>

<span class="nc" id="L80">		byte[] correctOkm = new byte[] { (byte) 0x3c, (byte) 0xb2, (byte) 0x5f, (byte) 0x25, (byte) 0xfa, (byte) 0xac,</span>
				(byte) 0xd5, (byte) 0x7a, (byte) 0x90, (byte) 0x43, (byte) 0x4f, (byte) 0x64, (byte) 0xd0, (byte) 0x36,
				(byte) 0x2f, (byte) 0x2a, (byte) 0x2d, (byte) 0x2d, (byte) 0x0a, (byte) 0x90, (byte) 0xcf, (byte) 0x1a,
				(byte) 0x5a, (byte) 0x4c, (byte) 0x5d, (byte) 0xb0, (byte) 0x2d, (byte) 0x56, (byte) 0xec, (byte) 0xc4,
				(byte) 0xc5, (byte) 0xbf, (byte) 0x34, (byte) 0x00, (byte) 0x72, (byte) 0x08, (byte) 0xd5, (byte) 0xb8,
				(byte) 0x87, (byte) 0x18, (byte) 0x58, (byte) 0x65 };

<span class="nc" id="L87">		byte[] okm = extractExpand(salt, ikm, info, L);</span>

<span class="nc" id="L89">		System.out.println(Utils.bytesToHex(okm));</span>
<span class="nc" id="L90">		System.out.println(&quot;Matches expected: &quot; + Arrays.equals(correctOkm, okm));</span>
<span class="nc" id="L91">	}</span>
	

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
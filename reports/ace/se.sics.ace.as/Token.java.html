<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Token.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace.as</a> &gt; <span class="el_source">Token.java</span></div><h1>Token.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019, RISE AB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
package se.sics.ace.as;

import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.eclipse.californium.elements.auth.RawPublicKeyIdentity;

import com.upokecenter.cbor.CBORObject;
import com.upokecenter.cbor.CBORType;

import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;

import se.sics.ace.AccessToken;
import se.sics.ace.AceException;
import se.sics.ace.Constants;
import se.sics.ace.Endpoint;
import se.sics.ace.Message;
import se.sics.ace.TimeProvider;
import se.sics.ace.Util;
import se.sics.ace.as.logging.DhtLogger;
import se.sics.ace.cwt.CWT;
import se.sics.ace.cwt.CwtCryptoCtx;

/**
 * Implements the /token endpoint on the authorization server.
 * 
 * Note: If a client requests a scope that is not supported by (parts) of the audience this endpoint will just ignore
 * that, assuming that the client will be denied by the PDP anyway. This requires a default deny policy in the PDP.
 * 
 * Note: This endpoint assigns a cti to each issued token based on a counter. The same value is also used as kid for the
 * proof-of-possession key associated to the token by means of the 'cnf' claim.
 * 
 * Note: This endpoint assumes that the sender Id (the one you get from Message.getSenderId()) for a secure session
 * created with a raw public key is generated with org.eclipse.californium.scandium.auth.RawPublicKeyIdentity.getName()
 * 
 * @author Ludwig Seitz and Marco Tiloca
 *
 */
public class Token implements Endpoint, AutoCloseable {

    /**
     * Enums for DHT logging levels
     */
<span class="fc" id="L92">    private static String TYPE_INFO = &quot;info&quot;;</span>
<span class="fc" id="L93">    private static String TYPE_WARNING = &quot;warning&quot;;</span>
<span class="fc" id="L94">    private static String TYPE_ERROR = &quot;error&quot;;</span>
<span class="fc" id="L95">    private static String PRIO_LOW = &quot;low&quot;;</span>
<span class="fc" id="L96">    private static String PRIO_MEDIUM = &quot;medium&quot;;</span>
<span class="fc" id="L97">    private static String PRIO_HIGH = &quot;high&quot;;</span>
<span class="fc" id="L98">    private static String CAT_STATUS = &quot;status&quot;;</span>
<span class="fc" id="L99">    private static String DEVICE_NAME = &quot;ACE Authorization Server&quot;;</span>

    /**
     * The logger
     */
<span class="fc" id="L104">    private static final Logger LOGGER = Logger.getLogger(Token.class.getName());</span>

    /**
     * Boolean for not verify
     */
<span class="fc" id="L109">    private static boolean sign = false;</span>

    /**
     * The PDP this endpoint uses to make access control decisions.
     */
    private PDP pdp;

    /**
     * The database connector for storing and retrieving stuff.
     */
    private DBConnector db;

    /**
     * The identifier of this AS for the iss claim.
     */
    private String asId;

    /**
     * The time provider for this AS.
     */
    private TimeProvider time;

    /**
     * The default expiration time of an access token
     */
<span class="fc" id="L134">    private static long expiration = 1000 * 60 * 10; // 10 minutes</span>

    /**
     * The counter for generating the cti
     */
<span class="fc" id="L139">    private Long cti = 0L;</span>

    /**
     * The private key of the AS or null if there isn't any
     */
    private OneKey privateKey;

    /**
     * The client credentials grant type as CBOR-integer
     */
<span class="fc" id="L149">    public static CBORObject clientCredentials = CBORObject.FromObject(Constants.GT_CLI_CRED);</span>

    /**
     * The authorizaton_code grant type as CBOR-integer
     */
<span class="fc" id="L154">    public static CBORObject authzCode = CBORObject.FromObject(Constants.GT_AUTHZ_CODE);</span>

    /**
     * Converter to create the byte array from the cti number
     */
<span class="fc" id="L159">    private static ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>

    /**
     * The claim types included in tokens generated by this Token instance
     */
    private Set&lt;Short&gt; claims;

<span class="fc" id="L166">    private static Set&lt;Short&gt; defaultClaims = new HashSet&lt;&gt;();</span>

    static {
<span class="fc" id="L169">        defaultClaims.add(Constants.CTI);</span>
<span class="fc" id="L170">        defaultClaims.add(Constants.ISS);</span>
<span class="fc" id="L171">        defaultClaims.add(Constants.EXI);</span>
<span class="fc" id="L172">        defaultClaims.add(Constants.AUD);</span>
<span class="fc" id="L173">        defaultClaims.add(Constants.SCOPE);</span>
<span class="fc" id="L174">        defaultClaims.add(Constants.CNF);</span>
<span class="fc" id="L175">    }</span>

    /**
     * If true the AUD claim is inserted in the COSE header of a CWT generated by this AS in order to be able to
     * retrieve the right keys when the CWT is presented by the client instead of the RS for introspection
     */
<span class="fc" id="L181">    private boolean setAudHeader = false;</span>

    /**
     * Incremented after having released an Access Token including OSCORE input material The current value is used for
     * the 'id' parameter in the OSCORE Security Context object in 'cnf'
     */
<span class="fc" id="L187">    private int OSCORE_material_counter = 0;</span>

    /**
     * Store the association between the cti of an issued Access Token and the target audience intended to consume it.
     */
<span class="fc" id="L192">    private Map&lt;String, String&gt; cti2aud = new HashMap&lt;&gt;();</span>

    /**
     * Store the association between the name of the Resource Server and the next value to use as Sequence Number to
     * build the 'cti' claim when the 'exi' claim is included in the Access Token
     * 
     * The entry for a Resource Server is created when the first Access Token including 'exi' is issues, since the AS
     * process has started. The initial value of the Sequence Number is retrieved from the database.
     */
<span class="fc" id="L201">    private Map&lt;String, Integer&gt; exiSequenceNumbers = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the DTLS profile is used with symmetric PoP key
     * 
     * Store the association between the cti of an issued Acced Token and the 'kid' of the associated symmetric PoP key
     * generated by the AS
     */
<span class="fc" id="L209">    private Map&lt;String, CBORObject&gt; cti2kid = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * Store the association between the cti of an issued Acced Token and the ID identifying the OSCORE Input Material.
     * Such an ID is stored as a CBOR byte string.
     */
<span class="fc" id="L217">    private Map&lt;String, CBORObject&gt; cti2oscId = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * The size in bytes of the OSCORE Master Salt to provide to the Client and to include in the Token. It can be 0, to
     * not provide a Master Salt.
     */
    private short masterSaltSize;

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * True if the OSCORE Id Context has to be provided, false otherwise
     */
    private boolean provideIdContext;

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * It specifies information on the next Id Context to assign for each Resource Server
     */
<span class="fc" id="L239">    private Map&lt;String, IdContextInfo&gt; idContextInfoMap = new HashMap&lt;&gt;();</span>

    /**
     * Mapping between security identities of the peers and their names; it can be null
     * 
     * This is relevant especially for the OSCORE profile, since all peers are registered in the AS database by
     * nicknames. Instead, their OSCORE identities as retrieved from incoming OSCORE messages are structured base64
     * strings encoding the Context ID and Sender ID for that peer
     */
<span class="fc" id="L248">    private Map&lt;String, String&gt; peerIdentitiesToNames = null;</span>

    /**
     * Constructor using default set of claims.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey,
            Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L264">        this(asId, pdp, db, time, privateKey, defaultClaims, false, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L265">    }</span>

    /**
     * Constructor that allows configuration of the claims included in the token.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param claims the claim types to include in tokens issued by this Token instance
     * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE header of a CWT generated by this AS in
     *        order to be able to retrieve the right keys when the CWT is presented by the client instead of the RS for
     *        introspection
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
            boolean setAudInCwtHeader, Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L285">        this(asId, pdp, db, time, privateKey, claims, setAudInCwtHeader, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L286">    }</span>

    /**
     * Constructor that allows configuration of everything.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param claims the claim types to include in tokens issued by this Token instance
     * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE header of a CWT generated by this AS in
     *        order to be able to retrieve the right keys when the CWT is presented by the client instead of the RS for
     *        introspection
     * @param masterSaltSize the size in bytes of the OSCORE Master Salt
     * @param provideIdContext true if the OSCORE Id Context has to be provided, false otherwise
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
            boolean setAudInCwtHeader, short masterSaltSize, boolean provideIdContext,
<span class="fc" id="L308">            Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {</span>

<span class="fc" id="L310">        Set&lt;Short&gt; localClaims = claims;</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (localClaims == null) {</span>
<span class="fc" id="L313">            localClaims = defaultClaims;</span>
        }

        // Time for checks
<span class="pc bpc" id="L317" title="2 of 4 branches missed.">        if (asId == null || asId.isEmpty()) {</span>
<span class="nc" id="L318">            LOGGER.severe(&quot;Token endpoint's AS identifier was null or empty&quot;);</span>
<span class="nc" id="L319">            throw new AceException(&quot;AS identifier must be non-null and non-empty&quot;);</span>
        }
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (pdp == null) {</span>
<span class="nc" id="L322">            LOGGER.severe(&quot;Token endpoint's PDP was null&quot;);</span>
<span class="nc" id="L323">            throw new AceException(&quot;Token endpoint's PDP must be non-null&quot;);</span>
        }
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (db == null) {</span>
<span class="nc" id="L326">            LOGGER.severe(&quot;Token endpoint's DBConnector was null&quot;);</span>
<span class="nc" id="L327">            throw new AceException(&quot;Token endpoint's DBConnector must be non-null&quot;);</span>
        }
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (time == null) {</span>
<span class="nc" id="L330">            LOGGER.severe(&quot;Token endpoint's TimeProvider was null&quot;);</span>
<span class="nc" id="L331">            throw new AceException(&quot;Token endpoint's TimeProvider &quot; + &quot;must be non-null&quot;);</span>
        }
        // All checks passed
<span class="fc" id="L334">        this.asId = asId;</span>
<span class="fc" id="L335">        this.pdp = pdp;</span>
<span class="fc" id="L336">        this.db = db;</span>
<span class="fc" id="L337">        this.time = time;</span>
<span class="fc" id="L338">        this.privateKey = privateKey;</span>
<span class="fc" id="L339">        this.cti = db.getCtiCounter();</span>
<span class="fc" id="L340">        this.claims = new HashSet&lt;&gt;();</span>
<span class="fc" id="L341">        this.claims.addAll(localClaims);</span>
<span class="fc" id="L342">        this.setAudHeader = setAudInCwtHeader;</span>
<span class="fc" id="L343">        this.masterSaltSize = masterSaltSize;</span>
<span class="fc" id="L344">        this.provideIdContext = provideIdContext;</span>
<span class="fc" id="L345">        this.peerIdentitiesToNames = peerIdentitiesToNames;</span>

<span class="fc" id="L347">    }</span>

    @Override
    public Message processMessage(Message msg) {
        // Purge expired tokens from the database
        try {
<span class="fc" id="L353">            this.db.purgeExpiredTokens(this.time.getCurrentTime());</span>
<span class="nc" id="L354">        } catch (AceException e) {</span>
<span class="nc" id="L355">            LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L356">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Database error&quot;);</span>
<span class="nc" id="L357">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L358">        }</span>

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (msg == null) {// This should not happen</span>
<span class="nc" id="L361">            LOGGER.severe(&quot;Token.processMessage() received null message&quot;);</span>
<span class="nc" id="L362">            return null;</span>
        }
<span class="fc" id="L364">        LOGGER.log(Level.INFO, &quot;Token received message: &quot; + msg.getParameters());</span>

        // 1. Check if this client can request tokens
<span class="fc" id="L367">        String id = msg.getSenderId();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (id == null) {</span>
<span class="fc" id="L369">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L370">            map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L371">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client&quot;);</span>
<span class="fc" id="L372">			DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
					&quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="fc" id="L374">            return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
        }

<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L378">            id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (id == null) {</span>
<span class="nc" id="L380">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L381">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L382">				LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client&quot;);</span>
<span class="nc" id="L383">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="nc" id="L385">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
        }

        try {
<span class="fc bfc" id="L390" title="All 2 branches covered.">            if (!this.pdp.canAccessToken(id)) {</span>
<span class="fc" id="L391">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L392">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L393">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client&quot;);</span>
<span class="fc" id="L394">				DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
						&quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="fc" id="L396">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
<span class="nc" id="L398">        } catch (AceException e) {</span>
<span class="nc" id="L399">            LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L400">			DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Database error&quot;);</span>
<span class="nc" id="L401">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L402">        }</span>

        // 2. Check that this is a supported grant type
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (msg.getParameter(Constants.GRANT_TYPE) == null</span>
                // grant type == client credentials implied
<span class="fc bfc" id="L407" title="All 2 branches covered.">                || msg.getParameter(Constants.GRANT_TYPE).equals(clientCredentials)) {</span>
<span class="fc" id="L408">            return processCC(msg);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        } else if (msg.getParameter(Constants.GRANT_TYPE).equals(authzCode)) {</span>
<span class="fc" id="L410">            return processAC(msg);</span>
        }
<span class="fc" id="L412">        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L413">        map.Add(Constants.ERROR, Constants.UNSUPPORTED_GRANT_TYPE);</span>
<span class="fc" id="L414">        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unsupported_grant_type&quot;);</span>
<span class="fc" id="L415">		DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
				&quot;Message processing aborted: &quot; + &quot;unsupported_grant_type&quot;);
<span class="fc" id="L417">        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
    }

    /**
     * Process a Client Credentials grant.
     * 
     * @param msg the message
     * @param id the identifier of the requester
     * 
     * @return the reply
     */
    private Message processCC(Message msg) {
<span class="fc" id="L429">        String id = msg.getSenderId();</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L432">            id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if (id == null) {</span>
<span class="nc" id="L434">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L435">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L436">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="nc" id="L437">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="nc" id="L439">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
        }

        // 3. Check if the request has a scope
<span class="fc" id="L444">        CBORObject cbor = msg.getParameter(Constants.SCOPE);</span>
<span class="fc" id="L445">        Object scope = null;</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (cbor == null) {</span>
            try {
<span class="fc" id="L448">                scope = this.db.getDefaultScope(id);</span>
<span class="nc" id="L449">            } catch (AceException e) {</span>
<span class="nc" id="L450">                LOGGER.severe(&quot;Message processing aborted (checking scope): &quot; + e.getMessage());</span>
<span class="nc" id="L451">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted (checking scope)&quot;);
<span class="nc" id="L453">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L454">            }</span>
        } else {
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L457">                scope = cbor.AsString();</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">            } else if (cbor.getType().equals(CBORType.ByteString)) {</span>
<span class="fc" id="L459">                scope = cbor.GetByteString();</span>
            } else {
<span class="fc" id="L461">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L462">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L463">                map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid datatype for scope&quot;);</span>
<span class="fc" id="L464">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);</span>
<span class="fc" id="L465">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);
<span class="fc" id="L467">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
        }
<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (scope == null) {</span>
<span class="fc" id="L471">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L472">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L473">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No scope found for message&quot;);</span>
<span class="fc" id="L474">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);</span>
<span class="fc" id="L475">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);
<span class="fc" id="L477">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 4. Check if the request has an audience or if there is a default
        // audience
<span class="fc" id="L482">        cbor = msg.getParameter(Constants.AUDIENCE);</span>

        // The audience has to be a text string. A set is built for
        // compatibility with other methods
<span class="fc" id="L486">        Set&lt;String&gt; aud = new HashSet&lt;&gt;();</span>

<span class="fc" id="L488">        String audStr = &quot;&quot;; // used to save the audience for later, for possible</span>
                            // update of access rights
<span class="fc" id="L490">        String oldCti = &quot;&quot;; // used to track the cti of a Token to supersede, in</span>
                            // case of update of access rights

<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (cbor == null) {</span>
            try {
<span class="fc" id="L495">                String dAud = this.db.getDefaultAudience(id);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">                if (dAud != null) {</span>
<span class="fc" id="L497">                    aud.add(dAud);</span>
<span class="fc" id="L498">                    audStr = new String(dAud);</span>
                }
<span class="nc" id="L500">            } catch (AceException e) {</span>
<span class="nc" id="L501">                LOGGER.severe(&quot;Message processing aborted (checking aud): &quot; + e.getMessage());</span>
<span class="nc" id="L502">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted (checking aud)&quot;);
<span class="nc" id="L504">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L505">            }</span>
        } else {
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L508">                aud.add(cbor.AsString());</span>
<span class="fc" id="L509">                audStr = new String(cbor.AsString());</span>
            } else {// error
<span class="fc" id="L511">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L512">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L513">                map.Add(Constants.ERROR_DESCRIPTION, &quot;Audience malformed&quot;);</span>
<span class="fc" id="L514">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);</span>
<span class="fc" id="L515">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);
<span class="fc" id="L517">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
        }
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (aud.isEmpty()) {</span>
<span class="fc" id="L521">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L522">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L523">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No audience found for message&quot;);</span>
<span class="fc" id="L524">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);</span>
<span class="fc" id="L525">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);
<span class="fc" id="L527">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 5. Check if the scope is allowed
<span class="fc" id="L531">        Object allowedScopes = null;</span>
        try {
<span class="fc" id="L533">            allowedScopes = this.pdp.canAccess(id, aud, scope);</span>
<span class="nc" id="L534">        } catch (AceException e) {</span>
<span class="nc" id="L535">            LOGGER.severe(&quot;Message processing aborted (checking permissions): &quot; + e.getMessage());</span>
<span class="nc" id="L536">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (checking permissions)&quot;);
<span class="nc" id="L538">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L539">        }</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (allowedScopes == null) {</span>
<span class="fc" id="L541">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L542">            map.Add(Constants.ERROR, Constants.INVALID_SCOPE);</span>
<span class="fc" id="L543">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);</span>
<span class="fc" id="L544">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);
<span class="fc" id="L546">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 6. Create token
        // Find supported token type
<span class="fc" id="L551">        Short tokenType = null;</span>
        try {
<span class="fc" id="L553">            tokenType = this.db.getSupportedTokenType(aud);</span>
<span class="nc" id="L554">        } catch (AceException e) {</span>
<span class="nc" id="L555">            LOGGER.severe(&quot;Message processing aborted (creating token): &quot; + e.getMessage());</span>
<span class="nc" id="L556">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (creating token)&quot;);
<span class="nc" id="L558">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L559">        }</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (tokenType == null) {</span>
<span class="fc" id="L561">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L562">            map.Add(Constants.ERROR, &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L563">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L564">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);
<span class="fc" id="L566">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

<span class="fc" id="L569">        boolean includeExi = this.claims.contains(Constants.EXI);</span>
        // If the 'exi' claim is included, ensure that the 'cti' claim is also
        // included
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (includeExi) {</span>
<span class="fc" id="L573">            this.claims.add(Constants.CTI);</span>
        }

        // The construction of 'cti' depends on the presence/absence of the
        // 'exi' claim.
        //
        // If the 'exi' claim is not present, 'cti' is the serialization of a
        // global counter.
        //
        // If the 'exi' claim is present, 'cti' is the serialization of two
        // concatenated strings, i.e., the name of the Resource Server and the
        // current value of the Exi Sequence Number
<span class="fc" id="L585">        byte[] ctiB = null;</span>
<span class="fc" id="L586">        String ctiStr = null;</span>
<span class="fc" id="L587">        String rsName = null;</span>
<span class="fc" id="L588">        int exiSeqNum = -1;</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (!includeExi) {</span>
            // The 'exi' claim is not included in the Access Token.
            // Thus, 'cti' can be easily built by using the related single
            // counter
<span class="fc" id="L593">            ctiB = buffer.putLong(0, this.cti).array();</span>
<span class="fc" id="L594">            ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>
<span class="fc" id="L595">            this.cti++;</span>
        } else {
            // The 'exi' claim is included in the Access Token.
            //
            // Thus, 'cti' has to be built according to a particular semantics,
            // as the serialization of the text string S1 = (S2 | S3), where S2
            // is the name of the Resource Server and S3 is the text encoding of
            // the Exi Sequence Number to use for that Resource Server.

            // Determine the name of the Resource Server associated to the
            // specified Audience
<span class="fc" id="L606">            Set&lt;String&gt; rsSet = new HashSet&lt;&gt;();</span>
            try {
<span class="fc" id="L608">                rsSet = db.getRSS(audStr);</span>
<span class="nc" id="L609">            } catch (AceException e) {</span>
<span class="nc" id="L610">                LOGGER.severe(&quot;Message processing aborted: Error when retrieving the name&quot;</span>
<span class="nc" id="L611">                        + &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot; + e.getMessage());</span>
<span class="nc" id="L612">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: Error when retrieving the name&quot;
                                + &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L615">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L616">            }</span>
            // Check the the specified Audience is associated to exactly one
            // Resource Server
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (rsSet.size() != 1) {</span>
<span class="nc" id="L620">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L621">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L622">                map.Add(Constants.ERROR_DESCRIPTION, &quot;The 'exi' claim has to be included, thus Audience must contain&quot;</span>
                        + &quot; exactly one Resource Server&quot;);
<span class="nc" id="L624">                LOGGER.log(Level.INFO, &quot;Message processing aborted: The 'exi' claim has to be included,&quot;</span>
                        + &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L626">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: The 'exi' claim has to be included,&quot;
                                + &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L629">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
<span class="fc bfc" id="L631" title="All 2 branches covered.">            for (String rs : rsSet)</span>
<span class="fc" id="L632">                rsName = new String(rs);</span>

            // Retrieve the value of the Exi Sequence Number to use for this
            // Resource Server
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (exiSequenceNumbers.containsKey(rsName)) {</span>
<span class="fc" id="L637">                exiSeqNum = exiSequenceNumbers.get(rsName).intValue();</span>
            } else {
                // This is going to be the first Access Token including the
                // 'exi' claim issued to this Resource Server since the AS
                // process started. Then, retrieve the current Exi Sequence
                // Number value for this Resource Server from the database.
                try {
<span class="fc" id="L644">                    exiSeqNum = db.getExiSequenceNumber(rsName);</span>
<span class="nc" id="L645">                } catch (AceException e) {</span>
<span class="nc" id="L646">                    LOGGER.severe(&quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;</span>
                            + &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot;
<span class="nc" id="L648">                            + e.getMessage());</span>
<span class="nc" id="L649">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;
                                    + &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L652">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L653">                }</span>
            }

            // Update the local collection of Exi Sequence Numbers
<span class="fc" id="L657">            Integer newSeqNum = Integer.valueOf(exiSeqNum + 1);</span>
<span class="fc" id="L658">            exiSequenceNumbers.put(rsName, newSeqNum);</span>

<span class="fc" id="L660">            String rawCti = new String(rsName + String.valueOf(exiSeqNum));</span>
<span class="fc" id="L661">            ctiB = rawCti.getBytes(Constants.charset);</span>
<span class="fc" id="L662">            ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>

        }

        // Find supported profile

<span class="fc" id="L668">        String profileStr = null;</span>
        try {
<span class="fc" id="L670">            profileStr = this.db.getSupportedProfile(id, aud);</span>
<span class="nc" id="L671">        } catch (AceException e) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L673">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L676">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="nc" id="L678">            LOGGER.severe(&quot;Message processing aborted (finding profile): &quot; + e.getMessage());</span>
<span class="nc" id="L679">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (finding profile)&quot;);
<span class="nc" id="L681">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L682">        }</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (profileStr == null) {</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L685">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L688">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="fc" id="L690">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L691">            map.Add(Constants.ERROR, Constants.INCOMPATIBLE_PROFILES);</span>
<span class="fc" id="L692">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);</span>
<span class="fc" id="L693">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);
<span class="fc" id="L695">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L697">        short profile = Constants.getProfileAbbrev(profileStr);</span>

<span class="fc bfc" id="L699" title="All 4 branches covered.">        if (tokenType != AccessTokenFactory.CWT_TYPE &amp;&amp; tokenType != AccessTokenFactory.REF_TYPE) {</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L701">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L704">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="fc" id="L706">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L707">            map.Add(Constants.ERROR, &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L708">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L709">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);
<span class="fc" id="L711">            return msg.failReply(Message.FAIL_NOT_IMPLEMENTED, map);</span>
        }

        // This flag will be set to true if the Token is intended to update
        // access rights
<span class="fc" id="L716">        boolean updateAccessRights = false;</span>

<span class="fc" id="L718">        String keyType = null; // Save the key type for later</span>
<span class="fc" id="L719">        Map&lt;Short, CBORObject&gt; claims = new HashMap&lt;&gt;();</span>

        // ISS SUB AUD EXP NBF IAT CTI SCOPE CNF RS_CNF PROFILE EXI
<span class="fc bfc" id="L722" title="All 2 branches covered.">        for (Short c : this.claims) {</span>
<span class="pc bpc" id="L723" title="6 of 12 branches missed.">            switch (c) {</span>
            case Constants.ISS:
<span class="fc" id="L725">                claims.put(Constants.ISS, CBORObject.FromObject(this.asId));</span>
<span class="fc" id="L726">                break;</span>
            case Constants.SUB:
<span class="nc" id="L728">                claims.put(Constants.SUB, CBORObject.FromObject(id));</span>
<span class="nc" id="L729">                break;</span>
            case Constants.AUD:
                // Check if AUDIENCE is a singleton
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (aud.size() == 1) {</span>
<span class="fc" id="L733">                    claims.put(Constants.AUD, CBORObject.FromObject(aud.iterator().next()));</span>
                } else {
<span class="nc" id="L735">                    claims.put(Constants.AUD, CBORObject.FromObject(aud));</span>
                }
<span class="nc" id="L737">                break;</span>
            case Constants.EXP:
<span class="nc" id="L739">                long now = this.time.getCurrentTime();</span>
<span class="nc" id="L740">                long exp = Long.MAX_VALUE;</span>
                try {
<span class="nc" id="L742">                    exp = this.db.getExpTime(aud);</span>
<span class="nc" id="L743">                } catch (AceException e) {</span>
<span class="nc" id="L744">                    LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L745">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L747">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L748">                }</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (exp == Long.MAX_VALUE) { // == No expiration time found</span>
                    // using default
<span class="nc" id="L751">                    exp = now + expiration;</span>
                } else {
<span class="nc" id="L753">                    exp = now + exp;</span>
                }
<span class="nc" id="L755">                claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>
<span class="nc" id="L756">                break;</span>
            case Constants.EXI:
<span class="fc" id="L758">                long exi = Long.MAX_VALUE;</span>
                try {
<span class="fc" id="L760">                    exi = this.db.getExpTime(aud);</span>
<span class="nc" id="L761">                } catch (AceException e) {</span>
<span class="nc" id="L762">                    LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L763">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L765">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L766">                }</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">                if (exi == Long.MAX_VALUE) { // == No expiration time found</span>
                    // using default
<span class="nc" id="L769">                    exi = expiration;</span>
                }
<span class="fc" id="L771">                claims.put(Constants.EXI, CBORObject.FromObject(exi));</span>
<span class="fc" id="L772">                break;</span>
            case Constants.NBF:
                // XXX: NBF is not configurable in this version
<span class="nc" id="L775">                now = this.time.getCurrentTime();</span>
<span class="nc" id="L776">                claims.put(Constants.NBF, CBORObject.FromObject(now));</span>
<span class="nc" id="L777">                break;</span>
            case Constants.IAT:
<span class="nc" id="L779">                now = this.time.getCurrentTime();</span>
<span class="nc" id="L780">                claims.put(Constants.IAT, CBORObject.FromObject(now));</span>
<span class="nc" id="L781">                break;</span>
            case Constants.CTI:
<span class="fc" id="L783">                claims.put(Constants.CTI, CBORObject.FromObject(ctiB));</span>
<span class="fc" id="L784">                break;</span>
            case Constants.SCOPE:
<span class="fc" id="L786">                claims.put(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
<span class="fc" id="L787">                break;</span>
            case Constants.CNF:
<span class="fc" id="L789">                CBORObject cnf = msg.getParameter(Constants.REQ_CNF);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                if (cnf == null) { // The client wants to use PSK</span>
<span class="fc" id="L791">                    keyType = &quot;PSK&quot;; // save for later</span>

                    // check if PSK is supported for proof-of-possession
                    try {
<span class="fc bfc" id="L795" title="All 2 branches covered.">                        if (!isSupported(keyType, aud)) {</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L797">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="fc" id="L800">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="fc" id="L802">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L803">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L804">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);</span>
<span class="fc" id="L805">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);
<span class="fc" id="L807">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="nc" id="L809">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L811">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L814">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L816">                        LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding key type): &quot; + e.getMessage());</span>
<span class="nc" id="L817">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(finding key type)&quot;);
<span class="nc" id="L819">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L820">                    }</span>

                    // Audience supports PSK, make a new PSK
                    try {
<span class="fc" id="L824">                        KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;);</span>

                        // OSCORE profile
<span class="fc bfc" id="L827" title="All 2 branches covered.">                        if (profile == Constants.COAP_OSCORE) {</span>
                            // Generate OSCORE cnf
<span class="fc" id="L829">                            SecretKey key = kg.generateKey();</span>
<span class="fc" id="L830">                            byte[] masterSecret = key.getEncoded();</span>
<span class="fc" id="L831">                            CBORObject osc = makeOscoreCnf(masterSecret, audStr);</span>
<span class="fc" id="L832">                            claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L833">                        }</span>
                        // DTLS profile
                        else {
                            // Make a DTLS style psk
<span class="fc" id="L837">                            CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L838">                            CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L840">                            keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

                            // Note: kid is the same as cti
<span class="fc" id="L843">                            byte[] kid = ctiB;</span>
<span class="fc" id="L844">                            keyData.Add(KeyKeys.KeyId.AsCBOR(), kid);</span>

<span class="fc" id="L846">                            SecretKey key = kg.generateKey();</span>
<span class="fc" id="L847">                            keyData.Add(KeyKeys.Octet_K.AsCBOR(), CBORObject.FromObject(key.getEncoded()));</span>

<span class="fc" id="L849">                            OneKey psk = new OneKey(keyData);</span>
<span class="fc" id="L850">                            coseKey.Add(Constants.COSE_KEY, psk.AsCBOR());</span>
<span class="fc" id="L851">                            claims.put(Constants.CNF, coseKey);</span>
                        }
<span class="nc" id="L853">                    } catch (NoSuchAlgorithmException | CoseException e) {</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L855">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L858">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L860">                        LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(making PSK): &quot; + e.getMessage());</span>
<span class="nc" id="L861">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(making PSK)&quot;);
<span class="nc" id="L863">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L864">                    }</span>

<span class="fc bfc" id="L866" title="All 2 branches covered.">                } else if (cnf.ContainsKey(Constants.COSE_KID_CBOR)) {</span>
                    // The client requested a specific kid

                    // Check that the kid is well-formed
<span class="fc" id="L870">                    CBORObject kidC = cnf.get(Constants.COSE_KID_CBOR);</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">                    if (!kidC.getType().equals(CBORType.ByteString)) {</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L873">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L876">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L878">                        LOGGER.info(&quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);</span>
<span class="fc" id="L879">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);
<span class="fc" id="L881">                        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L882">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L883">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed kid in 'cnf' parameter&quot;);</span>
<span class="fc" id="L884">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }
<span class="fc" id="L886">                    keyType = &quot;KID&quot;;</span>

                    // Check if the new Token is intended to update the access
                    // rights for this client
<span class="fc" id="L890">                    Set&lt;String&gt; ctiSet = new HashSet&lt;&gt;();</span>
                    try {
<span class="fc" id="L892">                        ctiSet = this.db.getCtis4Client(id);</span>

<span class="nc" id="L894">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L896">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L899">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L901">                        LOGGER.severe(</span>
<span class="nc" id="L902">                                &quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens): &quot; + e.getMessage());</span>
<span class="nc" id="L903">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens)&quot;);
<span class="nc" id="L905">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L906">                    }</span>

<span class="pc bpc" id="L908" title="1 of 2 branches missed.">                    if (ctiSet.size() != 0) {</span>
                        // Some Tokens have been issued to this client.

<span class="pc bpc" id="L911" title="1 of 2 branches missed.">                        for (String myCti : ctiSet) {</span>

                            // Check that not only the Token was released at
                            // some point in time, but that it is also currently
                            // stored in the Database. If so, it is possible to
                            // retrieve a non empty set of claims through its
                            // cti.
                            try {
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                                if (this.db.getClaims(myCti).size() == 0) {</span>
                                    // A Token with this cti is not active
                                    // anymore. Continue with checking the next
                                    // Token.

                                    // But first take the opportunity to clean
                                    // up some other data structures, which
                                    // might not have happened already
<span class="nc" id="L927">                                    this.cti2aud.remove(myCti);</span>
<span class="nc" id="L928">                                    this.cti2oscId.remove(myCti);</span>
<span class="nc" id="L929">                                    this.cti2kid.remove(myCti);</span>

<span class="nc" id="L931">                                    continue;</span>
                                }
<span class="nc" id="L933">                            } catch (AceException e) {</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                                if (!includeExi) {</span>
<span class="nc" id="L935">                                    this.cti--; // roll-back</span>
                                } else {
                                    // roll-back
<span class="nc" id="L938">                                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                }
<span class="nc" id="L940">                                LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding previously released token): &quot;</span>
<span class="nc" id="L941">                                        + e.getMessage());</span>
<span class="nc" id="L942">                                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                        &quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L944">                                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L945">                            }</span>

<span class="fc" id="L947">                            String myAud = this.cti2aud.get(myCti);</span>

                            // Check especially if the previously released Token
                            // was intended to the same Resource Server intended
                            // to consume the just requested Token
<span class="pc bpc" id="L952" title="1 of 4 branches missed.">                            if (myAud != null &amp;&amp; audStr.equals(myAud)) {</span>

                                // Retrieve the claims of the previously
                                // released Token
<span class="fc" id="L956">                                Map&lt;Short, CBORObject&gt; myClaims = null;</span>
                                try {
<span class="fc" id="L958">                                    myClaims = this.db.getClaims(myCti);</span>
<span class="nc" id="L959">                                } catch (AceException e) {</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                                    if (!includeExi) {</span>
<span class="nc" id="L961">                                        this.cti--; // roll-back</span>
                                    } else {
                                        // roll-back
<span class="nc" id="L964">                                        exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                    }
<span class="nc" id="L966">                                    LOGGER.severe(&quot;Message processing aborted &quot;</span>
<span class="nc" id="L967">                                            + &quot;(finding previously released token): &quot; + e.getMessage());</span>
<span class="nc" id="L968">                                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                            &quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L970">                                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L971">                                }</span>

<span class="fc" id="L973">                                CBORObject oldCnf = myClaims.get(Constants.CNF);</span>

<span class="pc bpc" id="L975" title="1 of 2 branches missed.">                                if (oldCnf.get(Constants.COSE_KID) != null) {</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(),</span>
<span class="nc" id="L977">                                            oldCnf.get(Constants.COSE_KID).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (not the first update
                                        // in the series)
<span class="nc" id="L981">                                        updateAccessRights = true;</span>
<span class="nc" id="L982">                                        oldCti = new String(myCti);</span>
<span class="nc" id="L983">                                        break;</span>
                                    }
                                    continue;
                                }

                                // OSCORE profile
<span class="fc bfc" id="L989" title="All 2 branches covered.">                                if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.OSCORE_Input_Material)</span>
<span class="fc" id="L991">                                            .get(Constants.OS_ID).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (first update in the
                                        // series)
<span class="fc" id="L995">                                        updateAccessRights = true;</span>
<span class="fc" id="L996">                                        oldCti = new String(myCti);</span>
<span class="fc" id="L997">                                        break;</span>
                                    }
                                    continue;
                                }
                                // DTLS profile
                                else {
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.COSE_KEY)</span>
<span class="fc" id="L1004">                                            .get(KeyKeys.KeyId.AsCBOR()).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (first update in the
                                        // series)
<span class="fc" id="L1008">                                        updateAccessRights = true;</span>
<span class="fc" id="L1009">                                        oldCti = new String(myCti);</span>
<span class="fc" id="L1010">                                        break;</span>
                                    }
                                    continue;
                                }
                            }
<span class="fc" id="L1015">                        }</span>

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">                        if (updateAccessRights == true) {</span>
                            // The new Token is intended to update access rights

                            // OSCORE profile
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                            if (profile == Constants.COAP_OSCORE) {</span>
                                // Generate OSCORE cnf
<span class="fc" id="L1023">                                CBORObject oscId = this.cti2oscId.get(oldCti);</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">                                if (oscId == null) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                                    if (!includeExi) {</span>
<span class="nc" id="L1026">                                        this.cti--; // roll-back</span>
                                    } else {
                                        // roll-back
<span class="nc" id="L1029">                                        exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                    }
<span class="nc" id="L1031">                                    LOGGER.severe(&quot;Message processing aborted &quot;</span>
                                            + &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1033">                                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                            &quot;Message processing aborted &quot;
                                                    + &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1036">                                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
                                }
<span class="fc" id="L1038">                                CBORObject osc = makeOscoreCnfUpdateAccessRights(oscId);</span>
<span class="fc" id="L1039">                                claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L1040">                            }</span>
                            // DTLS profile
                            else {
                                // Make a DTLS style psk
<span class="fc" id="L1044">                                CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L1045">                                CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L1047">                                keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

<span class="fc" id="L1049">                                CBORObject kidCbor = this.cti2kid.get(oldCti);</span>

<span class="fc" id="L1051">                                keyData.Add(KeyKeys.KeyId.AsCBOR(), kidCbor);</span>

<span class="fc" id="L1053">                                coseKey.Add(Constants.COSE_KEY, keyData);</span>
<span class="fc" id="L1054">                                claims.put(Constants.CNF, coseKey);</span>
<span class="fc" id="L1055">                            }</span>
                        } else {
<span class="nc" id="L1057">                            LOGGER.severe(&quot;Message processing aborted &quot;</span>
                                    + &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1059">                            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted &quot;
                                            + &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1062">                            CBORObject myMap = CBORObject.NewMap();</span>
<span class="nc" id="L1063">                            myMap.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1064">                            return msg.failReply(Message.FAIL_BAD_REQUEST, myMap);</span>
                        }
                    }

<span class="fc" id="L1068">                } else {// Client has provided a key</span>
                    // Check what key the client provided
<span class="fc" id="L1070">                    OneKey key = null;</span>
                    try {
<span class="fc" id="L1072">                        key = getKey(cnf, id);</span>
<span class="fc" id="L1073">                    } catch (AceException | CoseException e) {</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1075">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L1078">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L1080">                        LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1081">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">                        if (e.getMessage().startsWith(&quot;Malformed&quot;)) {</span>
<span class="fc" id="L1083">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1084">                            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1085">                            map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed 'cnf' parameter in request&quot;);</span>
<span class="fc" id="L1086">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="fc" id="L1088">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1089">                    }</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">                    if (key == null) {</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1092">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1095">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1097">                        CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1098">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1099">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1100">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1101">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);
<span class="nc" id="L1103">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }

<span class="fc bfc" id="L1106" title="All 2 branches covered.">                    if (key.get(KeyKeys.KeyType).equals(KeyKeys.KeyType_Octet)) {</span>
                        // Client tried to submit a symmetric key =&gt; reject
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1109">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L1112">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L1114">                        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1115">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1116">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1117">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1118">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);
<span class="fc" id="L1120">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }

                    // At this point we assume the client wants to use RPK
<span class="fc" id="L1124">                    keyType = &quot;RPK&quot;;</span>

                    // Check that the client used this RPK to create this
                    // session
                    try {
<span class="fc" id="L1129">                        RawPublicKeyIdentity rpkId = new RawPublicKeyIdentity(key.AsPublicKey());</span>
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">                        if (!rpkId.getName().equals(id)) {</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L1132">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="fc" id="L1135">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="fc" id="L1137">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1138">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L1139">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);</span>
<span class="fc" id="L1140">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);
<span class="fc" id="L1142">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }

<span class="nc" id="L1145">                    } catch (CoseException e) {</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1147">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1150">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1152">                        CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1153">                        map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1154">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1155">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1157">                        LOGGER.log(Level.FINEST, e.getMessage());</span>
<span class="nc" id="L1158">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
<span class="nc" id="L1159">                    }</span>

                    // Can the audience support this?
                    try {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                        if (!isSupported(keyType, aud)) {</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L1165">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="nc" id="L1168">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="nc" id="L1170">                            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1171">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1172">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1173">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1175">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="nc" id="L1177">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1179">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1182">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1184">                        LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1185">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1186">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1187">                    }</span>

                    // Audience support RPK, use provided RPK
<span class="nc" id="L1190">                    CBORObject coseKey = CBORObject.NewMap();</span>
<span class="nc" id="L1191">                    coseKey.Add(Constants.COSE_KEY, key.AsCBOR());</span>
<span class="nc" id="L1192">                    claims.put(Constants.CNF, coseKey);</span>
                }
<span class="nc" id="L1194">                break;</span>
            case Constants.PROFILE:
<span class="nc" id="L1196">                claims.put(Constants.PROFILE, CBORObject.FromObject(profile));</span>
<span class="nc" id="L1197">                break;</span>
            default:
<span class="nc" id="L1199">                LOGGER.severe(&quot;Unknown claim type in /token endpoint configuration: &quot; + c);</span>
<span class="nc" id="L1200">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Unknown claim type in /token endpoint configuration: &quot; + c);
<span class="nc" id="L1202">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
            }
<span class="fc" id="L1204">        }</span>

<span class="fc" id="L1206">        AccessToken token = null;</span>
        try {
<span class="fc" id="L1208">            token = AccessTokenFactory.generateToken(tokenType, claims);</span>
<span class="nc" id="L1209">        } catch (AceException e) {</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1211">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L1214">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

            // If the OSCORE profile is used, and this was a first-released
            // Token to this client for RS in question, roll-back the counter
            // used for the 'id' parameter in the OSCORE Security Context and
            // the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1221" title="All 4 branches missed.">            if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1222">                this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">                if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1224">                    this.idContextInfoMap.get(audStr).rollback();</span>
                }
            }

<span class="nc" id="L1228">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1229">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1230">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1231">        }</span>

<span class="fc" id="L1233">        CBORObject rsInfo = CBORObject.NewMap();</span>
        try {

<span class="fc" id="L1236">            boolean includeProfile = false;</span>

<span class="fc bfc" id="L1238" title="All 2 branches covered.">            if (!this.db.hasDefaultProfile(id)) {</span>
                // This client supports multiple profiles; need to specify the
                // exact one to use
<span class="fc" id="L1241">                includeProfile = true;</span>
            } else {
<span class="fc" id="L1243">                CBORObject profileParameter = msg.getParameter(Constants.PROFILE);</span>
<span class="pc bpc" id="L1244" title="3 of 4 branches missed.">                if (profileParameter != null &amp;&amp; profileParameter.equals(CBORObject.Null)) {</span>
                    // The client has requested an explicit indication of the
                    // profile to use
<span class="nc" id="L1247">                    includeProfile = true;</span>
                }
            }

<span class="fc bfc" id="L1251" title="All 2 branches covered.">            if (includeProfile == true) {</span>
<span class="fc" id="L1252">                rsInfo.Add(Constants.PROFILE, CBORObject.FromObject(profile));</span>
            }
            // Otherwise, no need to explicitly indicate the used profile

<span class="nc" id="L1256">        } catch (AceException e) {</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1258">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L1261">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

            // If the OSCORE profile is used, and this was a first-released
            // Token to this client for RS in question, roll-back the counter
            // used for the 'id' parameter in the OSCORE Security Context and
            // the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1268" title="All 4 branches missed.">            if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1269">                this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1271">                    this.idContextInfoMap.get(audStr).rollback();</span>
                }
            }

<span class="nc" id="L1275">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1276">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1277">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1278">        }</span>

<span class="fc bfc" id="L1280" title="All 4 branches covered.">        if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">            if (profile == Constants.COAP_OSCORE) {</span>

<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">                if (updateAccessRights == false) {</span>
<span class="fc" id="L1284">                    rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
                }
                // Do not add 'cnf' if the OSCORE profile is used and
                // the Token is released for updating access rights

            } else {
<span class="fc" id="L1290">                rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
            }
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">        } else if (keyType != null &amp;&amp; keyType.equals(&quot;RPK&quot;)) {</span>
<span class="nc" id="L1293">            Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
            try {
<span class="nc" id="L1295">                rscnfs = makeRsCnf(aud);</span>
<span class="nc" id="L1296">            } catch (AceException e) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1298">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1301">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1309" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1310">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1312">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1316">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1317">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1318">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1319">            }</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">            for (CBORObject rscnf : rscnfs) {</span>
<span class="nc" id="L1321">                rsInfo.Add(Constants.RS_CNF, rscnf);</span>
<span class="nc" id="L1322">            }</span>
        } // Skip cnf if client requested specific KID.

        // Handle &quot;scope&quot; both as String and as Byte Array
<span class="fc bfc" id="L1326" title="All 4 branches covered.">        if (scope instanceof String &amp;&amp; !allowedScopes.equals(scope)) {</span>
<span class="fc" id="L1327">            rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
        }
<span class="fc bfc" id="L1329" title="All 4 branches covered.">        if (scope instanceof byte[] &amp;&amp; !(Arrays.equals((byte[]) allowedScopes, (byte[]) scope))) {</span>
<span class="fc" id="L1330">            rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
        }

<span class="fc bfc" id="L1333" title="All 2 branches covered.">        if (token instanceof CWT) {</span>

<span class="fc" id="L1335">            CwtCryptoCtx ctx = null;</span>
            try {
<span class="fc" id="L1337">                ctx = EndpointUtils.makeCommonCtx(aud, this.db, this.privateKey, sign);</span>
<span class="nc" id="L1338">            } catch (AceException | CoseException e) {</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1340">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1343">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1351" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1352">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1354">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1358">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1359">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1360">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1361">            }</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">            if (ctx == null) {</span>
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1364">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="fc" id="L1367">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="pc bpc" id="L1375" title="2 of 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="fc" id="L1376">                    this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1377" title="1 of 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1378">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="fc" id="L1382">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1383">                map.Add(Constants.ERROR, &quot;No common security context found for audience&quot;);</span>
<span class="fc" id="L1384">                LOGGER.log(Level.INFO, &quot;Message processing aborted: No common security context found for audience&quot;);</span>
<span class="fc" id="L1385">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: No common security context found for audience&quot;);
<span class="fc" id="L1387">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, map);</span>
            }
<span class="fc" id="L1389">            CWT cwt = (CWT) token;</span>
<span class="fc" id="L1390">            Map&lt;HeaderKeys, CBORObject&gt; uHeaders = null;</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">            if (this.setAudHeader) {</span>
                // Add the audience as the KID in the header, so it can be
                // referenced by introspection requests.
<span class="nc" id="L1394">                CBORObject requestedAud = CBORObject.NewArray();</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                for (String a : aud) {</span>
<span class="nc" id="L1396">                    requestedAud.Add(a);</span>
<span class="nc" id="L1397">                }</span>
<span class="nc" id="L1398">                uHeaders = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1399">                uHeaders.put(HeaderKeys.KID, requestedAud);</span>
            }
            try {
<span class="fc" id="L1402">                rsInfo.Add(Constants.ACCESS_TOKEN, cwt.encode(ctx, null, uHeaders).EncodeToBytes());</span>
<span class="nc" id="L1403">            } catch (IllegalStateException | InvalidCipherTextException | CoseException | AceException e) {</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1405">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1408">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1416" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1417">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1419">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1423">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1424">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1425">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1426">            }</span>
<span class="fc" id="L1427">        } else {</span>
<span class="fc" id="L1428">            rsInfo.Add(Constants.ACCESS_TOKEN, token.encode().EncodeToBytes());</span>
        }

        try {

            // If the claim set includes EXI but not EXP, then extend the claim
            // set to be stored as follows:
            //
            // 1. Add an EXP claim, computed as current time plus the EXI value.
            // This allows to purge the token if expired, even though it was
            // created without the EXP claim.
            //
            // 2. Add an internal &quot;sentinel claim&quot; to signal the presence of the
            // artificially added EXP claim.
            // In case of introspection, this allows the Authorization Server to
            // return the Access Token like it was originally issued, i.e.,
            // without the EXI claim if this was artificially added.
<span class="pc bpc" id="L1445" title="1 of 4 branches missed.">            if (claims.containsKey(Constants.EXI) &amp;&amp; !claims.containsKey(Constants.EXP)) {</span>

<span class="fc" id="L1447">                Long now = this.time.getCurrentTime();</span>
<span class="fc" id="L1448">                Long exp = now + claims.get(Constants.EXI).AsNumber().ToInt64Checked();</span>

<span class="fc" id="L1450">                claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>

                // Add the &quot;sentinel claim&quot;
<span class="fc" id="L1453">                claims.put(Constants.LATE_ADDED_EXP, CBORObject.True);</span>
            }

<span class="fc" id="L1456">            this.db.addToken(ctiStr, claims);</span>
<span class="fc" id="L1457">            this.db.addCti2Client(ctiStr, id);</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if (!includeExi) {</span>
<span class="fc" id="L1459">                this.db.saveCtiCounter(this.cti);</span>
            } else {
<span class="fc" id="L1461">                this.db.saveExiSequenceNumber(exiSeqNum + 1, rsName);</span>
            }

            // In case the client has asked to use a PSK, store further
            // associations, to support the issuing of Access Tokens for
            // updating access rights
<span class="fc bfc" id="L1467" title="All 4 branches covered.">            if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="fc" id="L1469">                this.cti2aud.put(ctiStr, audStr);</span>

<span class="fc bfc" id="L1471" title="All 2 branches covered.">                if (profile == Constants.COAP_OSCORE) {</span>
                    CBORObject oscId;
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">                    if (updateAccessRights == false) {</span>
                        // The Token is not updating access rights, hence the
                        // identifier of the OSCORE Input Material is the 'id'
                        // 'OSCORE_Input_Material' element of the 'cnf' claim
<span class="fc" id="L1477">                        oscId = claims.get(Constants.CNF).get(Constants.OSCORE_Input_Material).get(Constants.OS_ID);</span>
                    } else {
                        // The Token is updating access rights, hence the
                        // identifier of the
                        // OSCORE Input Material is used as 'kid' in the 'cnf'
                        // claim of the Token
<span class="nc" id="L1483">                        oscId = claims.get(Constants.CNF).get(Constants.COSE_KID_CBOR);</span>
                    }

                    // A deep copy is needed
<span class="fc" id="L1487">                    byte[] oscIdCopy = Arrays.copyOf(oscId.GetByteString(), oscId.GetByteString().length);</span>
<span class="fc" id="L1488">                    this.cti2oscId.put(ctiStr, CBORObject.FromObject(oscIdCopy));</span>

<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">                } else if (profile == Constants.COAP_DTLS) {</span>
                    // Regardless if the Token is updating access rights or not,
                    // the identifier of the PoP key is the 'kid' parameter
                    // inside the 'COSE_Key' parameter of the 'cnf' claim
<span class="fc" id="L1494">                    CBORObject kid = claims.get(Constants.CNF).get(Constants.COSE_KEY).get(KeyKeys.KeyId.AsCBOR());</span>

                    // A deep copy is needed
<span class="fc" id="L1497">                    byte[] kidCopy = Arrays.copyOf(kid.GetByteString(), kid.GetByteString().length);</span>
<span class="fc" id="L1498">                    this.cti2kid.put(ctiStr, CBORObject.FromObject(kidCopy));</span>

                }

                // The just issued Token is updating access rights, hence delete
                // the superseded Token
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">                if (updateAccessRights == true) {</span>
<span class="nc" id="L1505">                    removeToken(oldCti);</span>
                }

            }

<span class="fc" id="L1510">        } catch (AceException e) {</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1512">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L1515">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

<span class="fc" id="L1518">            this.cti2aud.remove(ctiStr);</span>

<span class="pc bpc" id="L1520" title="2 of 4 branches missed.">            if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">                if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">                    if (updateAccessRights == false) {</span>
                        // Roll-back the counter used for the 'id' parameter in
                        // the OSCORE Security Context and the Id Context value
                        // assigned for this Resource Server
<span class="fc" id="L1527">                        this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1528" title="1 of 2 branches missed.">                        if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1529">                            this.idContextInfoMap.get(audStr).rollback();</span>
                        }
                    }

<span class="fc" id="L1533">                    this.cti2oscId.remove(ctiStr);</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                } else if (profile == Constants.COAP_DTLS) {</span>
<span class="nc" id="L1535">                    this.cti2kid.remove(ctiStr);</span>
                }

            }

<span class="fc" id="L1540">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1541">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc" id="L1542">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1543">        }</span>
<span class="fc" id="L1544">        LOGGER.log(Level.INFO, &quot;Returning token: &quot; + ctiStr);</span>
<span class="fc" id="L1545">        DhtLogger.sendLog(TYPE_INFO, PRIO_LOW, CAT_STATUS, DEVICE_NAME, &quot;Returning token. &quot; + &quot;[ctiStr: &quot; + ctiStr</span>
                + &quot;. &quot; + &quot;rsName: &quot; + rsName + &quot;. &quot; + &quot;audStr: &quot; + audStr + &quot;. &quot; + &quot;id: &quot; + id + &quot;]&quot;);

        // ctiStr in base64, rsName, audStr, id
        //
        // If the EXP claim was added after the actual creation of the Access
        // Token, then print all the claims except for EXP and the sentinel
        // claim.
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        if (claims.containsKey(Constants.LATE_ADDED_EXP)) {</span>
<span class="fc" id="L1554">            Map&lt;Short, CBORObject&gt; actualClaims = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">            for (Short s : claims.keySet()) {</span>
<span class="fc" id="L1556">                actualClaims.put(s, claims.get(s));</span>
<span class="fc" id="L1557">            }</span>
<span class="fc" id="L1558">            LOGGER.log(Level.FINEST, &quot;Claims: &quot; + actualClaims.toString());</span>
        }
<span class="fc" id="L1560">        return msg.successReply(Message.CREATED, rsInfo);</span>
    }

    /**
     * Populate RS_CNF
     * 
     * @throws AceException
     */
    private Set&lt;CBORObject&gt; makeRsCnf(Set&lt;String&gt; aud) throws AceException {
<span class="nc" id="L1569">        Set&lt;String&gt; rss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1570">        Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        for (String audE : aud) {</span>
<span class="nc" id="L1572">            rss.addAll(this.db.getRSS(audE));</span>
<span class="nc" id="L1573">        }</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">        for (String rs : rss) {</span>
<span class="nc" id="L1575">            OneKey rsKey = this.db.getRsRPK(rs);</span>
<span class="nc" id="L1576">            CBORObject rscnf = CBORObject.NewMap();</span>
<span class="nc" id="L1577">            rscnf.Add(Constants.COSE_KEY_CBOR, rsKey.AsCBOR());</span>
<span class="nc" id="L1578">            rscnfs.add(rscnf);</span>

<span class="nc" id="L1580">        }</span>
<span class="nc" id="L1581">        return rscnfs;</span>
    }

    /**
     * Create the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR object.
     * 
     * @param masterSecret the OSCORE Master Secret
     * @param rsName the name of the Resource Server
     * 
     * @return the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR object
     */
    synchronized private CBORObject makeOscoreCnf(byte[] masterSecret, String rsName) {
<span class="fc" id="L1593">        CBORObject osccnf = CBORObject.NewMap();</span>
<span class="fc" id="L1594">        CBORObject osc = CBORObject.NewMap();</span>

<span class="fc" id="L1596">        osc.Add(Constants.OS_MS, masterSecret);</span>

<span class="fc" id="L1598">        osc.Add(Constants.OS_ID, Util.intToBytes(OSCORE_material_counter));</span>
<span class="fc" id="L1599">        OSCORE_material_counter++;</span>

<span class="fc bfc" id="L1601" title="All 2 branches covered.">        if (masterSaltSize != 0) {</span>
<span class="fc" id="L1602">            byte[] masterSalt = new byte[masterSaltSize];</span>
<span class="fc" id="L1603">            new SecureRandom().nextBytes(masterSalt);</span>
<span class="fc" id="L1604">            osc.Add(Constants.OS_SALT, masterSalt);</span>
        }

<span class="fc bfc" id="L1607" title="All 2 branches covered.">        if (this.provideIdContext == true) {</span>

            IdContextInfo idContextInfo;
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">            if (this.idContextInfoMap.containsKey(rsName)) {</span>
<span class="nc" id="L1611">                idContextInfo = this.idContextInfoMap.get(rsName);</span>
            } else {
                // This is the first Access Token for this Resource Server
<span class="fc" id="L1614">                idContextInfo = new IdContextInfo();</span>
<span class="fc" id="L1615">                this.idContextInfoMap.put(rsName, idContextInfo);</span>
            }

<span class="fc" id="L1618">            byte[] idContext = idContextInfo.getIdContext();</span>
<span class="fc" id="L1619">            osc.Add(Constants.OS_CONTEXTID, idContext);</span>

        }

<span class="fc" id="L1623">        osccnf.Add(Constants.OSCORE_Input_Material, osc);</span>
<span class="fc" id="L1624">        return osccnf;</span>
    }

    /**
     * Create the value of a 'cnf' claim as a &quot;kid&quot; CBOR object.
     * 
     * @param oscId the Identifier of the OSCORE Input Material object
     * 
     * @return the value of a 'cnf' claim as a &quot;kid&quot; CBOR object
     */
    private CBORObject makeOscoreCnfUpdateAccessRights(CBORObject oscId) {
<span class="fc" id="L1635">        CBORObject osccnf = CBORObject.NewMap();</span>

<span class="fc" id="L1637">        osccnf.Add(Constants.COSE_KID_CBOR, oscId);</span>
<span class="fc" id="L1638">        return osccnf;</span>
    }

    /**
     * Process an authorization grant message
     * 
     * @param msg the message
     * 
     * @return the reply
     */
    private Message processAC(Message msg) {
        // 3. Check if the request has a grant
<span class="fc" id="L1650">        CBORObject cbor = msg.getParameter(Constants.CODE);</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">        if (cbor == null) {</span>
<span class="nc" id="L1652">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1653">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1654">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No code found for message&quot;);</span>
<span class="nc" id="L1655">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No code found for message&quot;);</span>
<span class="nc" id="L1656">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">        if (!cbor.getType().equals(CBORType.TextString)) {</span>
<span class="nc" id="L1659">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1660">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1661">            map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1662">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1663">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L1665">        String code = cbor.AsString();</span>

        // 4. Check if grant valid and unused
        try {
<span class="pc bpc" id="L1669" title="1 of 2 branches missed.">            if (!this.db.isGrantValid(code)) {</span>
<span class="nc" id="L1670">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1671">                map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1672">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant&quot;);</span>
<span class="nc" id="L1673">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
<span class="nc" id="L1675">        } catch (AceException e) {</span>
<span class="nc" id="L1676">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(checking grant): &quot; + e.getMessage());</span>
<span class="nc" id="L1677">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1678">        }</span>

        // 5. Mark grant invalid
        try {
<span class="fc" id="L1682">            this.db.useGrant(code);</span>
<span class="nc" id="L1683">        } catch (AceException e) {</span>
<span class="nc" id="L1684">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(marking grant invalid): &quot; + e.getMessage());</span>
<span class="nc" id="L1685">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1686">        }</span>

        // 6. Return the RS Information
<span class="fc" id="L1689">        CBORObject rsInfo = CBORObject.NewMap();</span>

        try {
<span class="fc" id="L1692">            Map&lt;Short, CBORObject&gt; rsInfoDB = this.db.getRsInfo(code);</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">            for (Map.Entry&lt;Short, CBORObject&gt; e : rsInfoDB.entrySet()) {</span>
<span class="fc" id="L1694">                rsInfo.Add(e.getKey(), e.getValue());</span>
<span class="fc" id="L1695">            }</span>
<span class="nc" id="L1696">        } catch (AceException e) {</span>
<span class="nc" id="L1697">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(collecting RS Info&quot; + e.getMessage());</span>
<span class="nc" id="L1698">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1699">        }</span>

<span class="pc bpc" id="L1701" title="2 of 4 branches missed.">        if (rsInfo == null || !rsInfo.getType().equals(CBORType.Map)) {</span>
<span class="nc" id="L1702">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted: &quot; + &quot;no RS information found for grant: &quot; + code);</span>
<span class="nc" id="L1703">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1704">            map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1705">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No token found for grant&quot;);</span>
<span class="nc" id="L1706">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L1708">        return msg.successReply(Message.CREATED, rsInfo);</span>
    }

    private boolean isSupported(String keyType, Set&lt;String&gt; aud) throws AceException {
<span class="fc" id="L1712">        Set&lt;String&gt; keyTypes = this.db.getSupportedPopKeyTypes(aud);</span>
<span class="fc" id="L1713">        return keyTypes.contains(keyType);</span>
    }

    /**
     * Retrieves a key from a cnf structure.
     * 
     * @param cnf the cnf structure
     * 
     * @return the key
     * 
     * @throws AceException
     * @throws CoseException
     */
    private OneKey getKey(CBORObject cnf, String id) throws AceException, CoseException {
<span class="fc" id="L1727">        CBORObject crpk = null;</span>
<span class="fc bfc" id="L1728" title="All 2 branches covered.">        if (cnf.ContainsKey(Constants.COSE_KEY_CBOR)) {</span>
<span class="fc" id="L1729">            crpk = cnf.get(Constants.COSE_KEY_CBOR);</span>
<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">            if (crpk == null) {</span>
<span class="nc" id="L1731">                return null;</span>
            }
<span class="fc" id="L1733">            return new OneKey(crpk);</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        } else if (cnf.ContainsKey(Constants.COSE_ENCRYPTED_CBOR)) {</span>
<span class="fc" id="L1735">            Encrypt0Message msg = new Encrypt0Message();</span>
<span class="fc" id="L1736">            CBORObject encC = cnf.get(Constants.COSE_ENCRYPTED_CBOR);</span>
            try {
<span class="nc" id="L1738">                msg.DecodeFromCBORObject(encC);</span>
<span class="nc" id="L1739">                OneKey psk = this.db.getCPSK(id);</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                if (psk == null) {</span>
<span class="nc" id="L1741">                    LOGGER.severe(&quot;Couldn't find a key to decrypt cnf parameter&quot;);</span>
<span class="nc" id="L1742">                    throw new AceException(&quot;No key found to decrypt cnf parameter&quot;);</span>
                }
<span class="nc" id="L1744">                CBORObject key = psk.get(KeyKeys.Octet_K);</span>
<span class="nc bnc" id="L1745" title="All 4 branches missed.">                if (key == null || !key.getType().equals(CBORType.ByteString)) {</span>
<span class="nc" id="L1746">                    LOGGER.severe(&quot;Corrupt key retrieved from database&quot;);</span>
<span class="nc" id="L1747">                    throw new AceException(&quot;Key error in the database&quot;);</span>
                }
<span class="nc" id="L1749">                msg.decrypt(key.GetByteString());</span>
<span class="nc" id="L1750">                CBORObject keyData = CBORObject.DecodeFromBytes(msg.GetContent());</span>
<span class="nc" id="L1751">                return new OneKey(keyData);</span>
<span class="fc" id="L1752">            } catch (CoseException e) {</span>
<span class="fc" id="L1753">                LOGGER.severe(&quot;Error while decrypting a cnf claim: &quot; + e.getMessage());</span>
<span class="fc" id="L1754">                throw new AceException(&quot;Error while decrypting a cnf parameter&quot;);</span>
            }
        } // Note: We checked the COSE_KID_CBOR case before
<span class="fc" id="L1757">        throw new AceException(&quot;Malformed cnf structure&quot;);</span>
    }

    /**
     * Removes a token from the registry
     * 
     * @param cti the token identifier Base64 encoded
     * @throws AceException
     */
    public void removeToken(String cti) throws AceException {
<span class="nc" id="L1767">        this.db.deleteToken(cti);</span>

<span class="nc" id="L1769">        this.cti2aud.remove(cti);</span>
<span class="nc" id="L1770">        this.cti2oscId.remove(cti);</span>
<span class="nc" id="L1771">        this.cti2kid.remove(cti);</span>

        // FIXME: Add the token to the TRL
<span class="nc" id="L1774">    }</span>

    @Override
    public void close() throws AceException {
<span class="nc" id="L1778">        this.db.saveCtiCounter(this.cti);</span>

<span class="nc bnc" id="L1780" title="All 2 branches missed.">        for (String rs : exiSequenceNumbers.keySet())</span>
<span class="nc" id="L1781">            this.db.saveExiSequenceNumber(exiSequenceNumbers.get(rs).intValue(), rs);</span>

<span class="nc" id="L1783">        this.db.close();</span>
<span class="nc" id="L1784">    }</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * An instance of this class tracks the status of OSCORE Id Contexts assigned to a Resource Server
     */
    class IdContextInfo {

        short currentSize;
        int currentValue;

<span class="fc" id="L1796">        public IdContextInfo() {</span>
<span class="fc" id="L1797">            currentSize = 1;</span>
<span class="fc" id="L1798">            currentValue = 0;</span>
<span class="fc" id="L1799">        }</span>

        // Retrieve the next unassigned IdContext for this Resource Server,
        // using the smallest possible size in bytes. That is, first consume all
        // the Id Contexts of 1 byte in size, then all the Id Contexts of 2
        // bytes in size, and so on up to 4 bytes in size.
        synchronized public byte[] getIdContext() {

            // Check if the size has to be changed
<span class="pc bpc" id="L1808" title="2 of 3 branches missed.">            switch (currentSize) {</span>

            case 1: // Max value: 2^8 - 1
            case 2: // Max value: 2^16 - 1
            case 3: // Max value: 2^24 - 1
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">                if (currentValue == ((1 &lt;&lt; (currentSize * 8)) - 1)) {</span>
<span class="nc" id="L1814">                    currentSize++;</span>
<span class="nc" id="L1815">                    currentValue = 0;</span>
                }
                break;
            case 4: // Max value: 2^31 - 1 --- The other half is for negative
                    // integers
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                if (currentValue == ((1 &lt;&lt; ((currentSize * 8) - 1)) - 1)) {</span>
<span class="nc" id="L1821">                    currentSize = 1;</span>
<span class="nc" id="L1822">                    currentValue = 0;</span>
                }
                break;
            default:
<span class="nc" id="L1826">                return null;</span>
            }

<span class="fc" id="L1829">            byte[] idContext = null;</span>
<span class="pc bpc" id="L1830" title="4 of 5 branches missed.">            switch (currentSize) {</span>
            case 1:
<span class="fc" id="L1832">                idContext = new byte[] { (byte) (currentValue) };</span>
<span class="fc" id="L1833">                break;</span>
            case 2:
<span class="nc" id="L1835">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };</span>
<span class="nc" id="L1836">                break;</span>
            case 3:
<span class="nc" id="L1838">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 16), (byte) (currentValue &gt;&gt;&gt; 8),</span>
                                        (byte) currentValue };
<span class="nc" id="L1840">                break;</span>
            case 4:
<span class="nc" id="L1842">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 24), (byte) (currentValue &gt;&gt;&gt; 16),</span>
                                        (byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };
                break;
            }

<span class="fc" id="L1847">            currentValue++;</span>
<span class="fc" id="L1848">            return idContext;</span>

        }

        // Free up the Id Context latest assigned for this Resource Server
        synchronized public void rollback() {

<span class="nc bnc" id="L1855" title="All 2 branches missed.">            if (currentValue != 0) {</span>
<span class="nc" id="L1856">                currentValue--;</span>
            } else {
<span class="nc bnc" id="L1858" title="All 3 branches missed.">                switch (currentSize) {</span>
                case 1: // Restore the maximum value: 2^31 - 1 --- The other
                        // half is for negative integers
<span class="nc" id="L1861">                    currentSize = 4;</span>
<span class="nc" id="L1862">                    currentValue = (1 &lt;&lt; ((currentSize * 8) - 1)) - 1;</span>
<span class="nc" id="L1863">                    break;</span>
                case 2: // Restore the maximum value: 2^8 - 1
                case 3: // Restore the maximum value: 2^16 - 1
                case 4: // Restore the maximum value: 2^24 - 1
<span class="nc" id="L1867">                    currentSize--;</span>
<span class="nc" id="L1868">                    currentValue = (1 &lt;&lt; (currentSize * 8)) - 1;</span>
                    break;
                }
            }
<span class="nc" id="L1872">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Token.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace.as</a> &gt; <span class="el_source">Token.java</span></div><h1>Token.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019, RISE AB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
package se.sics.ace.as;

import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.eclipse.californium.elements.auth.RawPublicKeyIdentity;

import com.upokecenter.cbor.CBORObject;
import com.upokecenter.cbor.CBORType;

import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;

import se.sics.ace.AccessToken;
import se.sics.ace.AceException;
import se.sics.ace.Constants;
import se.sics.ace.Endpoint;
import se.sics.ace.Message;
import se.sics.ace.TimeProvider;
import se.sics.ace.Util;
import se.sics.ace.as.logging.DhtLogger;
import se.sics.ace.cwt.CWT;
import se.sics.ace.cwt.CwtCryptoCtx;

/**
 * Implements the /token endpoint on the authorization server.
 * 
 * Note: If a client requests a scope that is not supported by (parts) of the audience this endpoint will just ignore
 * that, assuming that the client will be denied by the PDP anyway. This requires a default deny policy in the PDP.
 * 
 * Note: This endpoint assigns a cti to each issued token based on a counter. The same value is also used as kid for the
 * proof-of-possession key associated to the token by means of the 'cnf' claim.
 * 
 * Note: This endpoint assumes that the sender Id (the one you get from Message.getSenderId()) for a secure session
 * created with a raw public key is generated with org.eclipse.californium.scandium.auth.RawPublicKeyIdentity.getName()
 * 
 * @author Ludwig Seitz and Marco Tiloca
 *
 */
public class Token implements Endpoint, AutoCloseable {

    /**
     * Enums for DHT logging levels
     */
<span class="fc" id="L92">    private static String TYPE_INFO = &quot;info&quot;;</span>
<span class="fc" id="L93">    private static String TYPE_WARNING = &quot;warning&quot;;</span>
<span class="fc" id="L94">    private static String TYPE_ERROR = &quot;error&quot;;</span>
<span class="fc" id="L95">    private static String PRIO_LOW = &quot;low&quot;;</span>
<span class="fc" id="L96">    private static String PRIO_MEDIUM = &quot;medium&quot;;</span>
<span class="fc" id="L97">    private static String PRIO_HIGH = &quot;high&quot;;</span>
<span class="fc" id="L98">    private static String CAT_STATUS = &quot;status&quot;;</span>
<span class="fc" id="L99">    private static String DEVICE_NAME = &quot;ACE Authorization Server&quot;;</span>

    /**
     * The logger
     */
<span class="fc" id="L104">    private static final Logger LOGGER = Logger.getLogger(Token.class.getName());</span>

    /**
     * Boolean for not verify
     */
<span class="fc" id="L109">    private static boolean sign = false;</span>

    /**
     * The PDP this endpoint uses to make access control decisions.
     */
    private PDP pdp;

    /**
     * The database connector for storing and retrieving stuff.
     */
    private DBConnector db;

    /**
     * The identifier of this AS for the iss claim.
     */
    private String asId;

    /**
     * The time provider for this AS.
     */
    private TimeProvider time;

    /**
     * The default expiration time of an access token
     */
<span class="fc" id="L134">    private static long expiration = 1000 * 60 * 10; // 10 minutes</span>

    /**
     * The counter for generating the cti
     */
<span class="fc" id="L139">    private Long cti = 0L;</span>

    /**
     * The private key of the AS or null if there isn't any
     */
    private OneKey privateKey;

    /**
     * The client credentials grant type as CBOR-integer
     */
<span class="fc" id="L149">    public static CBORObject clientCredentials = CBORObject.FromObject(Constants.GT_CLI_CRED);</span>

    /**
     * The authorizaton_code grant type as CBOR-integer
     */
<span class="fc" id="L154">    public static CBORObject authzCode = CBORObject.FromObject(Constants.GT_AUTHZ_CODE);</span>

    /**
     * Converter to create the byte array from the cti number
     */
<span class="fc" id="L159">    private static ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);</span>

    /**
     * The claim types included in tokens generated by this Token instance
     */
    private Set&lt;Short&gt; claims;

<span class="fc" id="L166">    private static Set&lt;Short&gt; defaultClaims = new HashSet&lt;&gt;();</span>

    static {
<span class="fc" id="L169">        defaultClaims.add(Constants.CTI);</span>
<span class="fc" id="L170">        defaultClaims.add(Constants.ISS);</span>
<span class="fc" id="L171">        defaultClaims.add(Constants.EXI);</span>
<span class="fc" id="L172">        defaultClaims.add(Constants.AUD);</span>
<span class="fc" id="L173">        defaultClaims.add(Constants.SCOPE);</span>
<span class="fc" id="L174">        defaultClaims.add(Constants.CNF);</span>
<span class="fc" id="L175">    }</span>

    /**
     * If true the AUD claim is inserted in the COSE header of a CWT generated by this AS in order to be able to
     * retrieve the right keys when the CWT is presented by the client instead of the RS for introspection
     */
<span class="fc" id="L181">    private boolean setAudHeader = false;</span>

    /**
     * Incremented after having released an Access Token including OSCORE input material The current value is used for
     * the 'id' parameter in the OSCORE Security Context object in 'cnf'
     */
<span class="fc" id="L187">    private int OSCORE_material_counter = 0;</span>

    /**
     * Store the association between the cti of an issued Access Token and the target audience intended to consume it.
     */
<span class="fc" id="L192">    private Map&lt;String, String&gt; cti2aud = new HashMap&lt;&gt;();</span>

    /**
     * Store the association between the name of the Resource Server and the next value to use as Sequence Number to
     * build the 'cti' claim when the 'exi' claim is included in the Access Token
     * 
     * The entry for a Resource Server is created when the first Access Token including 'exi' is issues, since the AS
     * process has started. The initial value of the Sequence Number is retrieved from the database.
     */
<span class="fc" id="L201">    private Map&lt;String, Integer&gt; exiSequenceNumbers = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the DTLS profile is used with symmetric PoP key
     * 
     * Store the association between the cti of an issued Acced Token and the 'kid' of the associated symmetric PoP key
     * generated by the AS
     */
<span class="fc" id="L209">    private Map&lt;String, CBORObject&gt; cti2kid = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * Store the association between the cti of an issued Acced Token and the ID identifying the OSCORE Input Material.
     * Such an ID is stored as a CBOR byte string.
     */
<span class="fc" id="L217">    private Map&lt;String, CBORObject&gt; cti2oscId = new HashMap&lt;&gt;();</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * The size in bytes of the OSCORE Master Salt to provide to the Client and to include in the Token. It can be 0, to
     * not provide a Master Salt.
     */
    private short masterSaltSize;

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * True if the OSCORE Id Context has to be provided, false otherwise
     */
    private boolean provideIdContext;

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * It specifies information on the next Id Context to assign for each Resource Server
     */
<span class="fc" id="L239">    private Map&lt;String, IdContextInfo&gt; idContextInfoMap = new HashMap&lt;&gt;();</span>

    /**
     * Mapping between security identities of the peers and their names; it can be null
     * 
     * This is relevant especially for the OSCORE profile, since all peers are registered in the AS database by
     * nicknames. Instead, their OSCORE identities as retrieved from incoming OSCORE messages are structured base64
     * strings encoding the Context ID and Sender ID for that peer
     */
<span class="fc" id="L248">    private Map&lt;String, String&gt; peerIdentitiesToNames = null;</span>

    /**
     * Constructor using default set of claims.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey,
            Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L264">        this(asId, pdp, db, time, privateKey, defaultClaims, false, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L265">    }</span>

    /**
     * Constructor that allows configuration of the claims included in the token.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param claims the claim types to include in tokens issued by this Token instance
     * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE header of a CWT generated by this AS in
     *        order to be able to retrieve the right keys when the CWT is presented by the client instead of the RS for
     *        introspection
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
            boolean setAudInCwtHeader, Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {
<span class="fc" id="L285">        this(asId, pdp, db, time, privateKey, claims, setAudInCwtHeader, (short) 0, false, peerIdentitiesToNames);</span>
<span class="fc" id="L286">    }</span>

    /**
     * Constructor that allows configuration of everything.
     * 
     * @param asId the identifier of this AS
     * @param pdp the PDP for deciding access
     * @param db the database connector
     * @param time the time provider
     * @param privateKey the private key of the AS or null if there isn't any
     * @param claims the claim types to include in tokens issued by this Token instance
     * @param setAudInCwtHeader if true the AUD claim is inserted in the COSE header of a CWT generated by this AS in
     *        order to be able to retrieve the right keys when the CWT is presented by the client instead of the RS for
     *        introspection
     * @param masterSaltSize the size in bytes of the OSCORE Master Salt
     * @param provideIdContext true if the OSCORE Id Context has to be provided, false otherwise
     * @param peerIdentitiesToNames mapping between security identities of the peers and their names; it can be null
     * 
     * @throws AceException if fetching the cti from the database fails
     */
    public Token(String asId, PDP pdp, DBConnector db, TimeProvider time, OneKey privateKey, Set&lt;Short&gt; claims,
            boolean setAudInCwtHeader, short masterSaltSize, boolean provideIdContext,
<span class="fc" id="L308">            Map&lt;String, String&gt; peerIdentitiesToNames) throws AceException {</span>

<span class="fc" id="L310">        Set&lt;Short&gt; localClaims = claims;</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (localClaims == null) {</span>
<span class="fc" id="L313">            localClaims = defaultClaims;</span>
        }

        // Time for checks
<span class="pc bpc" id="L317" title="2 of 4 branches missed.">        if (asId == null || asId.isEmpty()) {</span>
<span class="nc" id="L318">            LOGGER.severe(&quot;Token endpoint's AS identifier was null or empty&quot;);</span>
<span class="nc" id="L319">            throw new AceException(&quot;AS identifier must be non-null and non-empty&quot;);</span>
        }
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (pdp == null) {</span>
<span class="nc" id="L322">            LOGGER.severe(&quot;Token endpoint's PDP was null&quot;);</span>
<span class="nc" id="L323">            throw new AceException(&quot;Token endpoint's PDP must be non-null&quot;);</span>
        }
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (db == null) {</span>
<span class="nc" id="L326">            LOGGER.severe(&quot;Token endpoint's DBConnector was null&quot;);</span>
<span class="nc" id="L327">            throw new AceException(&quot;Token endpoint's DBConnector must be non-null&quot;);</span>
        }
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (time == null) {</span>
<span class="nc" id="L330">            LOGGER.severe(&quot;Token endpoint's TimeProvider was null&quot;);</span>
<span class="nc" id="L331">            throw new AceException(&quot;Token endpoint's TimeProvider &quot; + &quot;must be non-null&quot;);</span>
        }
        // All checks passed
<span class="fc" id="L334">        this.asId = asId;</span>
<span class="fc" id="L335">        this.pdp = pdp;</span>
<span class="fc" id="L336">        this.db = db;</span>
<span class="fc" id="L337">        this.time = time;</span>
<span class="fc" id="L338">        this.privateKey = privateKey;</span>
<span class="fc" id="L339">        this.cti = db.getCtiCounter();</span>
<span class="fc" id="L340">        this.claims = new HashSet&lt;&gt;();</span>
<span class="fc" id="L341">        this.claims.addAll(localClaims);</span>
<span class="fc" id="L342">        this.setAudHeader = setAudInCwtHeader;</span>
<span class="fc" id="L343">        this.masterSaltSize = masterSaltSize;</span>
<span class="fc" id="L344">        this.provideIdContext = provideIdContext;</span>
<span class="fc" id="L345">        this.peerIdentitiesToNames = peerIdentitiesToNames;</span>

<span class="fc" id="L347">    }</span>

    @Override
    public Message processMessage(Message msg) {
        // Purge expired tokens from the database
        try {
<span class="fc" id="L353">            this.db.purgeExpiredTokens(this.time.getCurrentTime());</span>
<span class="nc" id="L354">        } catch (AceException e) {</span>
<span class="nc" id="L355">            LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L356">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L357">        }</span>

<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (msg == null) {// This should not happen</span>
<span class="nc" id="L360">            LOGGER.severe(&quot;Token.processMessage() received null message&quot;);</span>
<span class="nc" id="L361">            return null;</span>
        }
<span class="fc" id="L363">        LOGGER.log(Level.INFO, &quot;Token received message: &quot; + msg.getParameters());</span>

        // 1. Check if this client can request tokens
<span class="fc" id="L366">        String id = msg.getSenderId();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (id == null) {</span>
<span class="fc" id="L368">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L369">            map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L370">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="fc" id="L371">            return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
        }

<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L375">            id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">            if (id == null) {</span>
<span class="nc" id="L377">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L378">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L379">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="nc" id="L380">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
        }

        try {
<span class="fc bfc" id="L385" title="All 2 branches covered.">            if (!this.pdp.canAccessToken(id)) {</span>
<span class="fc" id="L386">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L387">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="fc" id="L388">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="fc" id="L389">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
<span class="nc" id="L391">        } catch (AceException e) {</span>
<span class="nc" id="L392">            LOGGER.severe(&quot;Database error: &quot; + e.getMessage());</span>
<span class="nc" id="L393">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L394">        }</span>

        // 2. Check that this is a supported grant type
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (msg.getParameter(Constants.GRANT_TYPE) == null</span>
                // grant type == client credentials implied
<span class="fc bfc" id="L399" title="All 2 branches covered.">                || msg.getParameter(Constants.GRANT_TYPE).equals(clientCredentials)) {</span>
<span class="fc" id="L400">            return processCC(msg);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        } else if (msg.getParameter(Constants.GRANT_TYPE).equals(authzCode)) {</span>
<span class="fc" id="L402">            return processAC(msg);</span>
        }
<span class="fc" id="L404">        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L405">        map.Add(Constants.ERROR, Constants.UNSUPPORTED_GRANT_TYPE);</span>
<span class="fc" id="L406">        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unsupported_grant_type&quot;);</span>
<span class="fc" id="L407">        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
    }

    /**
     * Process a Client Credentials grant.
     * 
     * @param msg the message
     * @param id the identifier of the requester
     * 
     * @return the reply
     */
    private Message processCC(Message msg) {
<span class="fc" id="L419">        String id = msg.getSenderId();</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (peerIdentitiesToNames != null) {</span>
<span class="fc" id="L422">            id = peerIdentitiesToNames.get(id);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (id == null) {</span>
<span class="nc" id="L424">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L425">                map.Add(Constants.ERROR, Constants.UNAUTHORIZED_CLIENT);</span>
<span class="nc" id="L426">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);</span>
<span class="nc" id="L427">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;unauthorized client: &quot; + id);
<span class="nc" id="L429">                return msg.failReply(Message.FAIL_UNAUTHORIZED, map);</span>
            }
        }

        // 3. Check if the request has a scope
<span class="fc" id="L434">        CBORObject cbor = msg.getParameter(Constants.SCOPE);</span>
<span class="fc" id="L435">        Object scope = null;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (cbor == null) {</span>
            try {
<span class="fc" id="L438">                scope = this.db.getDefaultScope(id);</span>
<span class="nc" id="L439">            } catch (AceException e) {</span>
<span class="nc" id="L440">                LOGGER.severe(&quot;Message processing aborted (checking scope): &quot; + e.getMessage());</span>
<span class="nc" id="L441">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted (checking scope)&quot;);
<span class="nc" id="L443">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L444">            }</span>
        } else {
<span class="fc bfc" id="L446" title="All 2 branches covered.">            if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L447">                scope = cbor.AsString();</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            } else if (cbor.getType().equals(CBORType.ByteString)) {</span>
<span class="fc" id="L449">                scope = cbor.GetByteString();</span>
            } else {
<span class="fc" id="L451">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L452">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L453">                map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid datatype for scope&quot;);</span>
<span class="fc" id="L454">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);</span>
<span class="fc" id="L455">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;Invalid datatype for scope in message&quot;);
<span class="fc" id="L457">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
        }
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (scope == null) {</span>
<span class="fc" id="L461">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L462">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L463">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No scope found for message&quot;);</span>
<span class="fc" id="L464">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);</span>
<span class="fc" id="L465">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No scope found for message&quot;);
<span class="fc" id="L467">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 4. Check if the request has an audience or if there is a default
        // audience
<span class="fc" id="L472">        cbor = msg.getParameter(Constants.AUDIENCE);</span>

        // The audience has to be a text string. A set is built for
        // compatibility with other methods
<span class="fc" id="L476">        Set&lt;String&gt; aud = new HashSet&lt;&gt;();</span>

<span class="fc" id="L478">        String audStr = &quot;&quot;; // used to save the audience for later, for possible</span>
                            // update of access rights
<span class="fc" id="L480">        String oldCti = &quot;&quot;; // used to track the cti of a Token to supersede, in</span>
                            // case of update of access rights

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (cbor == null) {</span>
            try {
<span class="fc" id="L485">                String dAud = this.db.getDefaultAudience(id);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                if (dAud != null) {</span>
<span class="fc" id="L487">                    aud.add(dAud);</span>
<span class="fc" id="L488">                    audStr = new String(dAud);</span>
                }
<span class="nc" id="L490">            } catch (AceException e) {</span>
<span class="nc" id="L491">                LOGGER.severe(&quot;Message processing aborted (checking aud): &quot; + e.getMessage());</span>
<span class="nc" id="L492">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted (checking aud)&quot;);
<span class="nc" id="L494">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L495">            }</span>
        } else {
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (cbor.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L498">                aud.add(cbor.AsString());</span>
<span class="fc" id="L499">                audStr = new String(cbor.AsString());</span>
            } else {// error
<span class="fc" id="L501">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L502">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L503">                map.Add(Constants.ERROR_DESCRIPTION, &quot;Audience malformed&quot;);</span>
<span class="fc" id="L504">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);</span>
<span class="fc" id="L505">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: &quot; + &quot;Audience malformed&quot;);
<span class="fc" id="L507">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
        }
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (aud.isEmpty()) {</span>
<span class="fc" id="L511">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L512">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L513">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No audience found for message&quot;);</span>
<span class="fc" id="L514">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);</span>
<span class="fc" id="L515">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No audience found for message&quot;);
<span class="fc" id="L517">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 5. Check if the scope is allowed
<span class="fc" id="L521">        Object allowedScopes = null;</span>
        try {
<span class="fc" id="L523">            allowedScopes = this.pdp.canAccess(id, aud, scope);</span>
<span class="nc" id="L524">        } catch (AceException e) {</span>
<span class="nc" id="L525">            LOGGER.severe(&quot;Message processing aborted (checking permissions): &quot; + e.getMessage());</span>
<span class="nc" id="L526">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (checking permissions)&quot;);
<span class="nc" id="L528">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L529">        }</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        if (allowedScopes == null) {</span>
<span class="fc" id="L531">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L532">            map.Add(Constants.ERROR, Constants.INVALID_SCOPE);</span>
<span class="fc" id="L533">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);</span>
<span class="fc" id="L534">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;invalid_scope&quot;);
<span class="fc" id="L536">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

        // 6. Create token
        // Find supported token type
<span class="fc" id="L541">        Short tokenType = null;</span>
        try {
<span class="fc" id="L543">            tokenType = this.db.getSupportedTokenType(aud);</span>
<span class="nc" id="L544">        } catch (AceException e) {</span>
<span class="nc" id="L545">            LOGGER.severe(&quot;Message processing aborted (creating token): &quot; + e.getMessage());</span>
<span class="nc" id="L546">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (creating token)&quot;);
<span class="nc" id="L548">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L549">        }</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (tokenType == null) {</span>
<span class="fc" id="L551">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L552">            map.Add(Constants.ERROR, &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L553">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);</span>
<span class="fc" id="L554">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;Audience incompatible on token type&quot;);
<span class="fc" id="L556">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }

<span class="fc" id="L559">        boolean includeExi = this.claims.contains(Constants.EXI);</span>
        // If the 'exi' claim is included, ensure that the 'cti' claim is also
        // included
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (includeExi) {</span>
<span class="fc" id="L563">            this.claims.add(Constants.CTI);</span>
        }

        // The construction of 'cti' depends on the presence/absence of the
        // 'exi' claim.
        //
        // If the 'exi' claim is not present, 'cti' is the serialization of a
        // global counter.
        //
        // If the 'exi' claim is present, 'cti' is the serialization of two
        // concatenated strings, i.e., the name of the Resource Server and the
        // current value of the Exi Sequence Number
<span class="fc" id="L575">        byte[] ctiB = null;</span>
<span class="fc" id="L576">        String ctiStr = null;</span>
<span class="fc" id="L577">        String rsName = null;</span>
<span class="fc" id="L578">        int exiSeqNum = -1;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (!includeExi) {</span>
            // The 'exi' claim is not included in the Access Token.
            // Thus, 'cti' can be easily built by using the related single
            // counter
<span class="fc" id="L583">            ctiB = buffer.putLong(0, this.cti).array();</span>
<span class="fc" id="L584">            ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>
<span class="fc" id="L585">            this.cti++;</span>
        } else {
            // The 'exi' claim is included in the Access Token.
            //
            // Thus, 'cti' has to be built according to a particular semantics,
            // as the serialization of the text string S1 = (S2 | S3), where S2
            // is the name of the Resource Server and S3 is the text encoding of
            // the Exi Sequence Number to use for that Resource Server.

            // Determine the name of the Resource Server associated to the
            // specified Audience
<span class="fc" id="L596">            Set&lt;String&gt; rsSet = new HashSet&lt;&gt;();</span>
            try {
<span class="fc" id="L598">                rsSet = db.getRSS(audStr);</span>
<span class="nc" id="L599">            } catch (AceException e) {</span>
<span class="nc" id="L600">                LOGGER.severe(&quot;Message processing aborted: Error when retrieving the name&quot;</span>
<span class="nc" id="L601">                        + &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot; + e.getMessage());</span>
<span class="nc" id="L602">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: Error when retrieving the name&quot;
                                + &quot; of the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L605">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L606">            }</span>
            // Check the the specified Audience is associated to exactly one
            // Resource Server
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if (rsSet.size() != 1) {</span>
<span class="nc" id="L610">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L611">                map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L612">                map.Add(Constants.ERROR_DESCRIPTION, &quot;The 'exi' claim has to be included, thus Audience must contain&quot;</span>
                        + &quot; exactly one Resource Server&quot;);
<span class="nc" id="L614">                LOGGER.log(Level.INFO, &quot;Message processing aborted: The 'exi' claim has to be included,&quot;</span>
                        + &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L616">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: The 'exi' claim has to be included,&quot;
                                + &quot;thus Audience must contain exactly one Resource Server&quot;);
<span class="nc" id="L619">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
<span class="fc bfc" id="L621" title="All 2 branches covered.">            for (String rs : rsSet)</span>
<span class="fc" id="L622">                rsName = new String(rs);</span>

            // Retrieve the value of the Exi Sequence Number to use for this
            // Resource Server
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (exiSequenceNumbers.containsKey(rsName)) {</span>
<span class="fc" id="L627">                exiSeqNum = exiSequenceNumbers.get(rsName).intValue();</span>
            } else {
                // This is going to be the first Access Token including the
                // 'exi' claim issued to this Resource Server since the AS
                // process started. Then, retrieve the current Exi Sequence
                // Number value for this Resource Server from the database.
                try {
<span class="fc" id="L634">                    exiSeqNum = db.getExiSequenceNumber(rsName);</span>
<span class="nc" id="L635">                } catch (AceException e) {</span>
<span class="nc" id="L636">                    LOGGER.severe(&quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;</span>
                            + &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.\n&quot;
<span class="nc" id="L638">                            + e.getMessage());</span>
<span class="nc" id="L639">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted: Error when retrieving the Exi Sequence Number&quot;
                                    + &quot; for the Resource Server with Audience &quot; + audStr + &quot; from the database.&quot;);
<span class="nc" id="L642">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L643">                }</span>
            }

            // Update the local collection of Exi Sequence Numbers
<span class="fc" id="L647">            Integer newSeqNum = Integer.valueOf(exiSeqNum + 1);</span>
<span class="fc" id="L648">            exiSequenceNumbers.put(rsName, newSeqNum);</span>

<span class="fc" id="L650">            String rawCti = new String(rsName + String.valueOf(exiSeqNum));</span>
<span class="fc" id="L651">            ctiB = rawCti.getBytes(Constants.charset);</span>
<span class="fc" id="L652">            ctiStr = Base64.getEncoder().encodeToString(ctiB);</span>

        }

        // Find supported profile

<span class="fc" id="L658">        String profileStr = null;</span>
        try {
<span class="fc" id="L660">            profileStr = this.db.getSupportedProfile(id, aud);</span>
<span class="nc" id="L661">        } catch (AceException e) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L663">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L666">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="nc" id="L668">            LOGGER.severe(&quot;Message processing aborted (finding profile): &quot; + e.getMessage());</span>
<span class="nc" id="L669">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted (finding profile)&quot;);
<span class="nc" id="L671">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L672">        }</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (profileStr == null) {</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L675">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L678">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="fc" id="L680">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L681">            map.Add(Constants.ERROR, Constants.INCOMPATIBLE_PROFILES);</span>
<span class="fc" id="L682">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);</span>
<span class="fc" id="L683">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;No compatible profile found&quot;);
<span class="fc" id="L685">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L687">        short profile = Constants.getProfileAbbrev(profileStr);</span>

<span class="fc bfc" id="L689" title="All 4 branches covered.">        if (tokenType != AccessTokenFactory.CWT_TYPE &amp;&amp; tokenType != AccessTokenFactory.REF_TYPE) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L691">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L694">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }
<span class="fc" id="L696">            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L697">            map.Add(Constants.ERROR, &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L698">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);</span>
<span class="fc" id="L699">            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                    &quot;Message processing aborted: &quot; + &quot;Unsupported token type&quot;);
<span class="fc" id="L701">            return msg.failReply(Message.FAIL_NOT_IMPLEMENTED, map);</span>
        }

        // This flag will be set to true if the Token is intended to update
        // access rights
<span class="fc" id="L706">        boolean updateAccessRights = false;</span>

<span class="fc" id="L708">        String keyType = null; // Save the key type for later</span>
<span class="fc" id="L709">        Map&lt;Short, CBORObject&gt; claims = new HashMap&lt;&gt;();</span>

        // ISS SUB AUD EXP NBF IAT CTI SCOPE CNF RS_CNF PROFILE EXI
<span class="fc bfc" id="L712" title="All 2 branches covered.">        for (Short c : this.claims) {</span>
<span class="pc bpc" id="L713" title="6 of 12 branches missed.">            switch (c) {</span>
            case Constants.ISS:
<span class="fc" id="L715">                claims.put(Constants.ISS, CBORObject.FromObject(this.asId));</span>
<span class="fc" id="L716">                break;</span>
            case Constants.SUB:
<span class="nc" id="L718">                claims.put(Constants.SUB, CBORObject.FromObject(id));</span>
<span class="nc" id="L719">                break;</span>
            case Constants.AUD:
                // Check if AUDIENCE is a singleton
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                if (aud.size() == 1) {</span>
<span class="fc" id="L723">                    claims.put(Constants.AUD, CBORObject.FromObject(aud.iterator().next()));</span>
                } else {
<span class="nc" id="L725">                    claims.put(Constants.AUD, CBORObject.FromObject(aud));</span>
                }
<span class="nc" id="L727">                break;</span>
            case Constants.EXP:
<span class="nc" id="L729">                long now = this.time.getCurrentTime();</span>
<span class="nc" id="L730">                long exp = Long.MAX_VALUE;</span>
                try {
<span class="nc" id="L732">                    exp = this.db.getExpTime(aud);</span>
<span class="nc" id="L733">                } catch (AceException e) {</span>
<span class="nc" id="L734">                    LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L735">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L737">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L738">                }</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                if (exp == Long.MAX_VALUE) { // == No expiration time found</span>
                    // using default
<span class="nc" id="L741">                    exp = now + expiration;</span>
                } else {
<span class="nc" id="L743">                    exp = now + exp;</span>
                }
<span class="nc" id="L745">                claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>
<span class="nc" id="L746">                break;</span>
            case Constants.EXI:
<span class="fc" id="L748">                long exi = Long.MAX_VALUE;</span>
                try {
<span class="fc" id="L750">                    exi = this.db.getExpTime(aud);</span>
<span class="nc" id="L751">                } catch (AceException e) {</span>
<span class="nc" id="L752">                    LOGGER.severe(&quot;Message processing aborted (setting exp): &quot; + e.getMessage());</span>
<span class="nc" id="L753">                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                            &quot;Message processing aborted (setting exp)&quot;);
<span class="nc" id="L755">                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L756">                }</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">                if (exi == Long.MAX_VALUE) { // == No expiration time found</span>
                    // using default
<span class="nc" id="L759">                    exi = expiration;</span>
                }
<span class="fc" id="L761">                claims.put(Constants.EXI, CBORObject.FromObject(exi));</span>
<span class="fc" id="L762">                break;</span>
            case Constants.NBF:
                // XXX: NBF is not configurable in this version
<span class="nc" id="L765">                now = this.time.getCurrentTime();</span>
<span class="nc" id="L766">                claims.put(Constants.NBF, CBORObject.FromObject(now));</span>
<span class="nc" id="L767">                break;</span>
            case Constants.IAT:
<span class="nc" id="L769">                now = this.time.getCurrentTime();</span>
<span class="nc" id="L770">                claims.put(Constants.IAT, CBORObject.FromObject(now));</span>
<span class="nc" id="L771">                break;</span>
            case Constants.CTI:
<span class="fc" id="L773">                claims.put(Constants.CTI, CBORObject.FromObject(ctiB));</span>
<span class="fc" id="L774">                break;</span>
            case Constants.SCOPE:
<span class="fc" id="L776">                claims.put(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
<span class="fc" id="L777">                break;</span>
            case Constants.CNF:
<span class="fc" id="L779">                CBORObject cnf = msg.getParameter(Constants.REQ_CNF);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                if (cnf == null) { // The client wants to use PSK</span>
<span class="fc" id="L781">                    keyType = &quot;PSK&quot;; // save for later</span>

                    // check if PSK is supported for proof-of-possession
                    try {
<span class="fc bfc" id="L785" title="All 2 branches covered.">                        if (!isSupported(keyType, aud)) {</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L787">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="fc" id="L790">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="fc" id="L792">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L793">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L794">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);</span>
<span class="fc" id="L795">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type PSK&quot;);
<span class="fc" id="L797">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="nc" id="L799">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L801">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L804">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L806">                        LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding key type): &quot; + e.getMessage());</span>
<span class="nc" id="L807">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(finding key type)&quot;);
<span class="nc" id="L809">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L810">                    }</span>

                    // Audience supports PSK, make a new PSK
                    try {
<span class="fc" id="L814">                        KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;);</span>

                        // OSCORE profile
<span class="fc bfc" id="L817" title="All 2 branches covered.">                        if (profile == Constants.COAP_OSCORE) {</span>
                            // Generate OSCORE cnf
<span class="fc" id="L819">                            SecretKey key = kg.generateKey();</span>
<span class="fc" id="L820">                            byte[] masterSecret = key.getEncoded();</span>
<span class="fc" id="L821">                            CBORObject osc = makeOscoreCnf(masterSecret, audStr);</span>
<span class="fc" id="L822">                            claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L823">                        }</span>
                        // DTLS profile
                        else {
                            // Make a DTLS style psk
<span class="fc" id="L827">                            CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L828">                            CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L830">                            keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

                            // Note: kid is the same as cti
<span class="fc" id="L833">                            byte[] kid = ctiB;</span>
<span class="fc" id="L834">                            keyData.Add(KeyKeys.KeyId.AsCBOR(), kid);</span>

<span class="fc" id="L836">                            SecretKey key = kg.generateKey();</span>
<span class="fc" id="L837">                            keyData.Add(KeyKeys.Octet_K.AsCBOR(), CBORObject.FromObject(key.getEncoded()));</span>

<span class="fc" id="L839">                            OneKey psk = new OneKey(keyData);</span>
<span class="fc" id="L840">                            coseKey.Add(Constants.COSE_KEY, psk.AsCBOR());</span>
<span class="fc" id="L841">                            claims.put(Constants.CNF, coseKey);</span>
                        }
<span class="nc" id="L843">                    } catch (NoSuchAlgorithmException | CoseException e) {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L845">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L848">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L850">                        LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(making PSK): &quot; + e.getMessage());</span>
<span class="nc" id="L851">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(making PSK)&quot;);
<span class="nc" id="L853">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L854">                    }</span>

<span class="fc bfc" id="L856" title="All 2 branches covered.">                } else if (cnf.ContainsKey(Constants.COSE_KID_CBOR)) {</span>
                    // The client requested a specific kid

                    // Check that the kid is well-formed
<span class="fc" id="L860">                    CBORObject kidC = cnf.get(Constants.COSE_KID_CBOR);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">                    if (!kidC.getType().equals(CBORType.ByteString)) {</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L863">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L866">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L868">                        LOGGER.info(&quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);</span>
<span class="fc" id="L869">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot; Malformed kid in request parameter 'cnf'&quot;);
<span class="fc" id="L871">                        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L872">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L873">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed kid in 'cnf' parameter&quot;);</span>
<span class="fc" id="L874">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }
<span class="fc" id="L876">                    keyType = &quot;KID&quot;;</span>

                    // Check if the new Token is intended to update the access
                    // rights for this client
<span class="fc" id="L880">                    Set&lt;String&gt; ctiSet = new HashSet&lt;&gt;();</span>
                    try {
<span class="fc" id="L882">                        ctiSet = this.db.getCtis4Client(id);</span>

<span class="nc" id="L884">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L886">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L889">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L891">                        LOGGER.severe(</span>
<span class="nc" id="L892">                                &quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens): &quot; + e.getMessage());</span>
<span class="nc" id="L893">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted &quot; + &quot;(finding cti of issues tokens)&quot;);
<span class="nc" id="L895">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L896">                    }</span>

<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                    if (ctiSet.size() != 0) {</span>
                        // Some Tokens have been issued to this client.

<span class="pc bpc" id="L901" title="1 of 2 branches missed.">                        for (String myCti : ctiSet) {</span>

                            // Check that not only the Token was released at
                            // some point in time, but that it is also currently
                            // stored in the Database. If so, it is possible to
                            // retrieve a non empty set of claims through its
                            // cti.
                            try {
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">                                if (this.db.getClaims(myCti).size() == 0) {</span>
                                    // A Token with this cti is not active
                                    // anymore. Continue with checking the next
                                    // Token.

                                    // But first take the opportunity to clean
                                    // up some other data structures, which
                                    // might not have happened already
<span class="nc" id="L917">                                    this.cti2aud.remove(myCti);</span>
<span class="nc" id="L918">                                    this.cti2oscId.remove(myCti);</span>
<span class="nc" id="L919">                                    this.cti2kid.remove(myCti);</span>

<span class="nc" id="L921">                                    continue;</span>
                                }
<span class="nc" id="L923">                            } catch (AceException e) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                                if (!includeExi) {</span>
<span class="nc" id="L925">                                    this.cti--; // roll-back</span>
                                } else {
                                    // roll-back
<span class="nc" id="L928">                                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                }
<span class="nc" id="L930">                                LOGGER.severe(&quot;Message processing aborted &quot; + &quot;(finding previously released token): &quot;</span>
<span class="nc" id="L931">                                        + e.getMessage());</span>
<span class="nc" id="L932">                                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                        &quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L934">                                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L935">                            }</span>

<span class="fc" id="L937">                            String myAud = this.cti2aud.get(myCti);</span>

                            // Check especially if the previously released Token
                            // was intended to the same Resource Server intended
                            // to consume the just requested Token
<span class="pc bpc" id="L942" title="1 of 4 branches missed.">                            if (myAud != null &amp;&amp; audStr.equals(myAud)) {</span>

                                // Retrieve the claims of the previously
                                // released Token
<span class="fc" id="L946">                                Map&lt;Short, CBORObject&gt; myClaims = null;</span>
                                try {
<span class="fc" id="L948">                                    myClaims = this.db.getClaims(myCti);</span>
<span class="nc" id="L949">                                } catch (AceException e) {</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                                    if (!includeExi) {</span>
<span class="nc" id="L951">                                        this.cti--; // roll-back</span>
                                    } else {
                                        // roll-back
<span class="nc" id="L954">                                        exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                    }
<span class="nc" id="L956">                                    LOGGER.severe(&quot;Message processing aborted &quot;</span>
<span class="nc" id="L957">                                            + &quot;(finding previously released token): &quot; + e.getMessage());</span>
<span class="nc" id="L958">                                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                            &quot;Message processing aborted &quot; + &quot;(finding previously released token)&quot;);
<span class="nc" id="L960">                                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L961">                                }</span>

<span class="fc" id="L963">                                CBORObject oldCnf = myClaims.get(Constants.CNF);</span>

<span class="pc bpc" id="L965" title="1 of 2 branches missed.">                                if (oldCnf.get(Constants.COSE_KID) != null) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(),</span>
<span class="nc" id="L967">                                            oldCnf.get(Constants.COSE_KID).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (not the first update
                                        // in the series)
<span class="nc" id="L971">                                        updateAccessRights = true;</span>
<span class="nc" id="L972">                                        oldCti = new String(myCti);</span>
<span class="nc" id="L973">                                        break;</span>
                                    }
                                    continue;
                                }

                                // OSCORE profile
<span class="fc bfc" id="L979" title="All 2 branches covered.">                                if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.OSCORE_Input_Material)</span>
<span class="fc" id="L981">                                            .get(Constants.OS_ID).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (first update in the
                                        // series)
<span class="fc" id="L985">                                        updateAccessRights = true;</span>
<span class="fc" id="L986">                                        oldCti = new String(myCti);</span>
<span class="fc" id="L987">                                        break;</span>
                                    }
                                    continue;
                                }
                                // DTLS profile
                                else {
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                                    if (Arrays.equals(kidC.GetByteString(), oldCnf.get(Constants.COSE_KEY)</span>
<span class="fc" id="L994">                                            .get(KeyKeys.KeyId.AsCBOR()).GetByteString())) {</span>
                                        // The new Token is intended to update
                                        // access rights (first update in the
                                        // series)
<span class="fc" id="L998">                                        updateAccessRights = true;</span>
<span class="fc" id="L999">                                        oldCti = new String(myCti);</span>
<span class="fc" id="L1000">                                        break;</span>
                                    }
                                    continue;
                                }
                            }
<span class="fc" id="L1005">                        }</span>

<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">                        if (updateAccessRights == true) {</span>
                            // The new Token is intended to update access rights

                            // OSCORE profile
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                            if (profile == Constants.COAP_OSCORE) {</span>
                                // Generate OSCORE cnf
<span class="fc" id="L1013">                                CBORObject oscId = this.cti2oscId.get(oldCti);</span>
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">                                if (oscId == null) {</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                                    if (!includeExi) {</span>
<span class="nc" id="L1016">                                        this.cti--; // roll-back</span>
                                    } else {
                                        // roll-back
<span class="nc" id="L1019">                                        exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                                    }
<span class="nc" id="L1021">                                    LOGGER.severe(&quot;Message processing aborted &quot;</span>
                                            + &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1023">                                    DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                            &quot;Message processing aborted &quot;
                                                    + &quot;(finding OSCORE ID when updating access rights)&quot;);
<span class="nc" id="L1026">                                    return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
                                }
<span class="fc" id="L1028">                                CBORObject osc = makeOscoreCnfUpdateAccessRights(oscId);</span>
<span class="fc" id="L1029">                                claims.put(Constants.CNF, osc);</span>
<span class="fc" id="L1030">                            }</span>
                            // DTLS profile
                            else {
                                // Make a DTLS style psk
<span class="fc" id="L1034">                                CBORObject keyData = CBORObject.NewMap();</span>
<span class="fc" id="L1035">                                CBORObject coseKey = CBORObject.NewMap();</span>

<span class="fc" id="L1037">                                keyData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_Octet);</span>

<span class="fc" id="L1039">                                CBORObject kidCbor = this.cti2kid.get(oldCti);</span>

<span class="fc" id="L1041">                                keyData.Add(KeyKeys.KeyId.AsCBOR(), kidCbor);</span>

<span class="fc" id="L1043">                                coseKey.Add(Constants.COSE_KEY, keyData);</span>
<span class="fc" id="L1044">                                claims.put(Constants.CNF, coseKey);</span>
<span class="fc" id="L1045">                            }</span>
                        } else {
<span class="nc" id="L1047">                            LOGGER.severe(&quot;Message processing aborted &quot;</span>
                                    + &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1049">                            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted &quot;
                                            + &quot;(cannot find access token for which access right have to be updated)&quot;);
<span class="nc" id="L1052">                            CBORObject myMap = CBORObject.NewMap();</span>
<span class="nc" id="L1053">                            myMap.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1054">                            return msg.failReply(Message.FAIL_BAD_REQUEST, myMap);</span>
                        }
                    }

<span class="fc" id="L1058">                } else {// Client has provided a key</span>
                    // Check what key the client provided
<span class="fc" id="L1060">                    OneKey key = null;</span>
                    try {
<span class="fc" id="L1062">                        key = getKey(cnf, id);</span>
<span class="fc" id="L1063">                    } catch (AceException | CoseException e) {</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1065">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L1068">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L1070">                        LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1071">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                        if (e.getMessage().startsWith(&quot;Malformed&quot;)) {</span>
<span class="fc" id="L1073">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1074">                            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1075">                            map.Add(Constants.ERROR_DESCRIPTION, &quot;Malformed 'cnf' parameter in request&quot;);</span>
<span class="fc" id="L1076">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="fc" id="L1078">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1079">                    }</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">                    if (key == null) {</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1082">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1085">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1087">                        CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1088">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1089">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1090">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);</span>
<span class="nc" id="L1091">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Couldn't retrieve RPK&quot;);
<span class="nc" id="L1093">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }

<span class="fc bfc" id="L1096" title="All 2 branches covered.">                    if (key.get(KeyKeys.KeyType).equals(KeyKeys.KeyType_Octet)) {</span>
                        // Client tried to submit a symmetric key =&gt; reject
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1099">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="fc" id="L1102">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="fc" id="L1104">                        CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1105">                        map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="fc" id="L1106">                        map.Add(Constants.ERROR_DESCRIPTION, &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1107">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);</span>
<span class="fc" id="L1108">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Client tried to provide cnf PSK&quot;);
<span class="fc" id="L1110">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                    }

                    // At this point we assume the client wants to use RPK
<span class="fc" id="L1114">                    keyType = &quot;RPK&quot;;</span>

                    // Check that the client used this RPK to create this
                    // session
                    try {
<span class="fc" id="L1119">                        RawPublicKeyIdentity rpkId = new RawPublicKeyIdentity(key.AsPublicKey());</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">                        if (!rpkId.getName().equals(id)) {</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L1122">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="fc" id="L1125">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="fc" id="L1127">                            CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1128">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="fc" id="L1129">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);</span>
<span class="fc" id="L1130">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Client used unauthenticated RPK&quot;);
<span class="fc" id="L1132">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }

<span class="nc" id="L1135">                    } catch (CoseException e) {</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1137">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1140">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1142">                        CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1143">                        map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1144">                        LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1145">                        DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1147">                        LOGGER.log(Level.FINEST, e.getMessage());</span>
<span class="nc" id="L1148">                        return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
<span class="nc" id="L1149">                    }</span>

                    // Can the audience support this?
                    try {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                        if (!isSupported(keyType, aud)) {</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                            if (!includeExi) {</span>
<span class="nc" id="L1155">                                this.cti--; // roll-back</span>
                            } else {
                                // roll-back
<span class="nc" id="L1158">                                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                            }
<span class="nc" id="L1160">                            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1161">                            map.Add(Constants.ERROR, Constants.UNSUPPORTED_POP_KEY);</span>
<span class="nc" id="L1162">                            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);</span>
<span class="nc" id="L1163">                            DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                                    &quot;Message processing aborted: &quot; + &quot;Unsupported pop key type RPK&quot;);
<span class="nc" id="L1165">                            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
                        }
<span class="nc" id="L1167">                    } catch (AceException e) {</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                        if (!includeExi) {</span>
<span class="nc" id="L1169">                            this.cti--; // roll-back</span>
                        } else {
                            // roll-back
<span class="nc" id="L1172">                            exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                        }
<span class="nc" id="L1174">                        LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1175">                        DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1176">                        return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1177">                    }</span>

                    // Audience support RPK, use provided RPK
<span class="nc" id="L1180">                    CBORObject coseKey = CBORObject.NewMap();</span>
<span class="nc" id="L1181">                    coseKey.Add(Constants.COSE_KEY, key.AsCBOR());</span>
<span class="nc" id="L1182">                    claims.put(Constants.CNF, coseKey);</span>
                }
<span class="nc" id="L1184">                break;</span>
            case Constants.PROFILE:
<span class="nc" id="L1186">                claims.put(Constants.PROFILE, CBORObject.FromObject(profile));</span>
<span class="nc" id="L1187">                break;</span>
            default:
<span class="nc" id="L1189">                LOGGER.severe(&quot;Unknown claim type in /token endpoint configuration: &quot; + c);</span>
<span class="nc" id="L1190">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Unknown claim type in /token endpoint configuration: &quot; + c);
<span class="nc" id="L1192">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
            }
<span class="fc" id="L1194">        }</span>

<span class="fc" id="L1196">        AccessToken token = null;</span>
        try {
<span class="fc" id="L1198">            token = AccessTokenFactory.generateToken(tokenType, claims);</span>
<span class="nc" id="L1199">        } catch (AceException e) {</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1201">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L1204">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

            // If the OSCORE profile is used, and this was a first-released
            // Token to this client for RS in question, roll-back the counter
            // used for the 'id' parameter in the OSCORE Security Context and
            // the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1211" title="All 4 branches missed.">            if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1212">                this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1214">                    this.idContextInfoMap.get(audStr).rollback();</span>
                }
            }

<span class="nc" id="L1218">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1219">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1220">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1221">        }</span>

<span class="fc" id="L1223">        CBORObject rsInfo = CBORObject.NewMap();</span>
        try {

<span class="fc" id="L1226">            boolean includeProfile = false;</span>

<span class="fc bfc" id="L1228" title="All 2 branches covered.">            if (!this.db.hasDefaultProfile(id)) {</span>
                // This client supports multiple profiles; need to specify the
                // exact one to use
<span class="fc" id="L1231">                includeProfile = true;</span>
            } else {
<span class="fc" id="L1233">                CBORObject profileParameter = msg.getParameter(Constants.PROFILE);</span>
<span class="pc bpc" id="L1234" title="3 of 4 branches missed.">                if (profileParameter != null &amp;&amp; profileParameter.equals(CBORObject.Null)) {</span>
                    // The client has requested an explicit indication of the
                    // profile to use
<span class="nc" id="L1237">                    includeProfile = true;</span>
                }
            }

<span class="fc bfc" id="L1241" title="All 2 branches covered.">            if (includeProfile == true) {</span>
<span class="fc" id="L1242">                rsInfo.Add(Constants.PROFILE, CBORObject.FromObject(profile));</span>
            }
            // Otherwise, no need to explicitly indicate the used profile

<span class="nc" id="L1246">        } catch (AceException e) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1248">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="nc" id="L1251">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

            // If the OSCORE profile is used, and this was a first-released
            // Token to this client for RS in question, roll-back the counter
            // used for the 'id' parameter in the OSCORE Security Context and
            // the Id Context value assigned for this Resource Server
<span class="nc bnc" id="L1258" title="All 4 branches missed.">            if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1259">                this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1261">                    this.idContextInfoMap.get(audStr).rollback();</span>
                }
            }

<span class="nc" id="L1265">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1266">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1267">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1268">        }</span>

<span class="fc bfc" id="L1270" title="All 4 branches covered.">        if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">            if (profile == Constants.COAP_OSCORE) {</span>

<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">                if (updateAccessRights == false) {</span>
<span class="fc" id="L1274">                    rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
                }
                // Do not add 'cnf' if the OSCORE profile is used and
                // the Token is released for updating access rights

            } else {
<span class="fc" id="L1280">                rsInfo.Add(Constants.CNF, claims.get(Constants.CNF));</span>
            }
<span class="pc bpc" id="L1282" title="1 of 4 branches missed.">        } else if (keyType != null &amp;&amp; keyType.equals(&quot;RPK&quot;)) {</span>
<span class="nc" id="L1283">            Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
            try {
<span class="nc" id="L1285">                rscnfs = makeRsCnf(aud);</span>
<span class="nc" id="L1286">            } catch (AceException e) {</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1288">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1291">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1299" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1300">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1302">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1306">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1307">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1308">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="nc" id="L1309">            }</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">            for (CBORObject rscnf : rscnfs) {</span>
<span class="nc" id="L1311">                rsInfo.Add(Constants.RS_CNF, rscnf);</span>
<span class="nc" id="L1312">            }</span>
        } // Skip cnf if client requested specific KID.

        // Handle &quot;scope&quot; both as String and as Byte Array
<span class="fc bfc" id="L1316" title="All 4 branches covered.">        if (scope instanceof String &amp;&amp; !allowedScopes.equals(scope)) {</span>
<span class="fc" id="L1317">            rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
        }
<span class="fc bfc" id="L1319" title="All 4 branches covered.">        if (scope instanceof byte[] &amp;&amp; !(Arrays.equals((byte[]) allowedScopes, (byte[]) scope))) {</span>
<span class="fc" id="L1320">            rsInfo.Add(Constants.SCOPE, CBORObject.FromObject(allowedScopes));</span>
        }

<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if (token instanceof CWT) {</span>

<span class="fc" id="L1325">            CwtCryptoCtx ctx = null;</span>
            try {
<span class="fc" id="L1327">                ctx = EndpointUtils.makeCommonCtx(aud, this.db, this.privateKey, sign);</span>
<span class="nc" id="L1328">            } catch (AceException | CoseException e) {</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1330">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1333">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1341" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1342">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1344">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1348">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1349">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1350">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1351">            }</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">            if (ctx == null) {</span>
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1354">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="fc" id="L1357">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="pc bpc" id="L1365" title="2 of 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="fc" id="L1366">                    this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1368">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="fc" id="L1372">                CBORObject map = CBORObject.NewMap();</span>
<span class="fc" id="L1373">                map.Add(Constants.ERROR, &quot;No common security context found for audience&quot;);</span>
<span class="fc" id="L1374">                LOGGER.log(Level.INFO, &quot;Message processing aborted: No common security context found for audience&quot;);</span>
<span class="fc" id="L1375">                DhtLogger.sendLog(TYPE_WARNING, PRIO_MEDIUM, CAT_STATUS, DEVICE_NAME,</span>
                        &quot;Message processing aborted: No common security context found for audience&quot;);
<span class="fc" id="L1377">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, map);</span>
            }
<span class="fc" id="L1379">            CWT cwt = (CWT) token;</span>
<span class="fc" id="L1380">            Map&lt;HeaderKeys, CBORObject&gt; uHeaders = null;</span>
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">            if (this.setAudHeader) {</span>
                // Add the audience as the KID in the header, so it can be
                // referenced by introspection requests.
<span class="nc" id="L1384">                CBORObject requestedAud = CBORObject.NewArray();</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                for (String a : aud) {</span>
<span class="nc" id="L1386">                    requestedAud.Add(a);</span>
<span class="nc" id="L1387">                }</span>
<span class="nc" id="L1388">                uHeaders = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1389">                uHeaders.put(HeaderKeys.KID, requestedAud);</span>
            }
            try {
<span class="fc" id="L1392">                rsInfo.Add(Constants.ACCESS_TOKEN, cwt.encode(ctx, null, uHeaders).EncodeToBytes());</span>
<span class="nc" id="L1393">            } catch (IllegalStateException | InvalidCipherTextException | CoseException | AceException e) {</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                if (!includeExi) {</span>
<span class="nc" id="L1395">                    this.cti--; // roll-back</span>
                } else {
                    // roll-back
<span class="nc" id="L1398">                    exiSequenceNumbers.put(rsName, exiSeqNum);</span>
                }

                // If the OSCORE profile is used, and this was a first-released
                // Token to this client for RS in question, roll-back the
                // counter used for the 'id' parameter in the OSCORE Security
                // Context and the Id Context value assigned for this Resource
                // Server
<span class="nc bnc" id="L1406" title="All 4 branches missed.">                if (profile == Constants.COAP_OSCORE &amp;&amp; updateAccessRights == false) {</span>
<span class="nc" id="L1407">                    this.OSCORE_material_counter--;</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                    if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1409">                        this.idContextInfoMap.get(audStr).rollback();</span>
                    }
                }

<span class="nc" id="L1413">                LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="nc" id="L1414">                DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="nc" id="L1415">                return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1416">            }</span>
<span class="fc" id="L1417">        } else {</span>
<span class="fc" id="L1418">            rsInfo.Add(Constants.ACCESS_TOKEN, token.encode().EncodeToBytes());</span>
        }

        try {

            // If the claim set includes EXI but not EXP, then extend the claim
            // set to be stored as follows:
            //
            // 1. Add an EXP claim, computed as current time plus the EXI value.
            // This allows to purge the token if expired, even though it was
            // created without the EXP claim.
            //
            // 2. Add an internal &quot;sentinel claim&quot; to signal the presence of the
            // artificially added EXP claim.
            // In case of introspection, this allows the Authorization Server to
            // return the Access Token like it was originally issued, i.e.,
            // without the EXI claim if this was artificially added.
<span class="pc bpc" id="L1435" title="1 of 4 branches missed.">            if (claims.containsKey(Constants.EXI) &amp;&amp; !claims.containsKey(Constants.EXP)) {</span>

<span class="fc" id="L1437">                Long now = this.time.getCurrentTime();</span>
<span class="fc" id="L1438">                Long exp = now + claims.get(Constants.EXI).AsNumber().ToInt64Checked();</span>

<span class="fc" id="L1440">                claims.put(Constants.EXP, CBORObject.FromObject(exp));</span>

                // Add the &quot;sentinel claim&quot;
<span class="fc" id="L1443">                claims.put(Constants.LATE_ADDED_EXP, CBORObject.True);</span>
            }

<span class="fc" id="L1446">            this.db.addToken(ctiStr, claims);</span>
<span class="fc" id="L1447">            this.db.addCti2Client(ctiStr, id);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">            if (!includeExi) {</span>
<span class="fc" id="L1449">                this.db.saveCtiCounter(this.cti);</span>
            } else {
<span class="fc" id="L1451">                this.db.saveExiSequenceNumber(exiSeqNum + 1, rsName);</span>
            }

            // In case the client has asked to use a PSK, store further
            // associations, to support the issuing of Access Tokens for
            // updating access rights
<span class="fc bfc" id="L1457" title="All 4 branches covered.">            if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="fc" id="L1459">                this.cti2aud.put(ctiStr, audStr);</span>

<span class="fc bfc" id="L1461" title="All 2 branches covered.">                if (profile == Constants.COAP_OSCORE) {</span>
                    CBORObject oscId;
<span class="pc bpc" id="L1463" title="1 of 2 branches missed.">                    if (updateAccessRights == false) {</span>
                        // The Token is not updating access rights, hence the
                        // identifier of the OSCORE Input Material is the 'id'
                        // 'OSCORE_Input_Material' element of the 'cnf' claim
<span class="fc" id="L1467">                        oscId = claims.get(Constants.CNF).get(Constants.OSCORE_Input_Material).get(Constants.OS_ID);</span>
                    } else {
                        // The Token is updating access rights, hence the
                        // identifier of the
                        // OSCORE Input Material is used as 'kid' in the 'cnf'
                        // claim of the Token
<span class="nc" id="L1473">                        oscId = claims.get(Constants.CNF).get(Constants.COSE_KID_CBOR);</span>
                    }

                    // A deep copy is needed
<span class="fc" id="L1477">                    byte[] oscIdCopy = Arrays.copyOf(oscId.GetByteString(), oscId.GetByteString().length);</span>
<span class="fc" id="L1478">                    this.cti2oscId.put(ctiStr, CBORObject.FromObject(oscIdCopy));</span>

<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">                } else if (profile == Constants.COAP_DTLS) {</span>
                    // Regardless if the Token is updating access rights or not,
                    // the identifier of the PoP key is the 'kid' parameter
                    // inside the 'COSE_Key' parameter of the 'cnf' claim
<span class="fc" id="L1484">                    CBORObject kid = claims.get(Constants.CNF).get(Constants.COSE_KEY).get(KeyKeys.KeyId.AsCBOR());</span>

                    // A deep copy is needed
<span class="fc" id="L1487">                    byte[] kidCopy = Arrays.copyOf(kid.GetByteString(), kid.GetByteString().length);</span>
<span class="fc" id="L1488">                    this.cti2kid.put(ctiStr, CBORObject.FromObject(kidCopy));</span>

                }

                // The just issued Token is updating access rights, hence delete
                // the superseded Token
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">                if (updateAccessRights == true) {</span>
<span class="nc" id="L1495">                    removeToken(oldCti);</span>
                }

            }

<span class="fc" id="L1500">        } catch (AceException e) {</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">            if (!includeExi) {</span>
<span class="nc" id="L1502">                this.cti--; // roll-back</span>
            } else {
                // roll-back
<span class="fc" id="L1505">                exiSequenceNumbers.put(rsName, exiSeqNum);</span>
            }

<span class="fc" id="L1508">            this.cti2aud.remove(ctiStr);</span>

<span class="pc bpc" id="L1510" title="2 of 4 branches missed.">            if (keyType != null &amp;&amp; keyType.equals(&quot;PSK&quot;)) {</span>

<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">                if (profile == Constants.COAP_OSCORE) {</span>
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">                    if (updateAccessRights == false) {</span>
                        // Roll-back the counter used for the 'id' parameter in
                        // the OSCORE Security Context and the Id Context value
                        // assigned for this Resource Server
<span class="fc" id="L1517">                        this.OSCORE_material_counter--;</span>
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">                        if (this.idContextInfoMap.containsKey(audStr)) {</span>
<span class="nc" id="L1519">                            this.idContextInfoMap.get(audStr).rollback();</span>
                        }
                    }

<span class="fc" id="L1523">                    this.cti2oscId.remove(ctiStr);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                } else if (profile == Constants.COAP_DTLS) {</span>
<span class="nc" id="L1525">                    this.cti2kid.remove(ctiStr);</span>
                }

            }

<span class="fc" id="L1530">            LOGGER.severe(&quot;Message processing aborted: &quot; + e.getMessage());</span>
<span class="fc" id="L1531">            DhtLogger.sendLog(TYPE_ERROR, PRIO_HIGH, CAT_STATUS, DEVICE_NAME, &quot;Message processing aborted&quot;);</span>
<span class="fc" id="L1532">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1533">        }</span>
<span class="fc" id="L1534">        LOGGER.log(Level.INFO, &quot;Returning token: &quot; + ctiStr);</span>
<span class="fc" id="L1535">        DhtLogger.sendLog(TYPE_INFO, PRIO_LOW, CAT_STATUS, DEVICE_NAME, &quot;Returning token. &quot; + &quot;[ctiStr: &quot; + ctiStr</span>
                + &quot;. &quot; + &quot;rsName: &quot; + rsName + &quot;. &quot; + &quot;audStr: &quot; + audStr + &quot;. &quot; + &quot;id: &quot; + id + &quot;]&quot;);

        // ctiStr in base64, rsName, audStr, id
        //
        // If the EXP claim was added after the actual creation of the Access
        // Token, then print all the claims except for EXP and the sentinel
        // claim.
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        if (claims.containsKey(Constants.LATE_ADDED_EXP)) {</span>
<span class="fc" id="L1544">            Map&lt;Short, CBORObject&gt; actualClaims = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">            for (Short s : claims.keySet()) {</span>
<span class="fc" id="L1546">                actualClaims.put(s, claims.get(s));</span>
<span class="fc" id="L1547">            }</span>
<span class="fc" id="L1548">            LOGGER.log(Level.FINEST, &quot;Claims: &quot; + actualClaims.toString());</span>
        }
<span class="fc" id="L1550">        return msg.successReply(Message.CREATED, rsInfo);</span>
    }

    /**
     * Populate RS_CNF
     * 
     * @throws AceException
     */
    private Set&lt;CBORObject&gt; makeRsCnf(Set&lt;String&gt; aud) throws AceException {
<span class="nc" id="L1559">        Set&lt;String&gt; rss = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1560">        Set&lt;CBORObject&gt; rscnfs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">        for (String audE : aud) {</span>
<span class="nc" id="L1562">            rss.addAll(this.db.getRSS(audE));</span>
<span class="nc" id="L1563">        }</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">        for (String rs : rss) {</span>
<span class="nc" id="L1565">            OneKey rsKey = this.db.getRsRPK(rs);</span>
<span class="nc" id="L1566">            CBORObject rscnf = CBORObject.NewMap();</span>
<span class="nc" id="L1567">            rscnf.Add(Constants.COSE_KEY_CBOR, rsKey.AsCBOR());</span>
<span class="nc" id="L1568">            rscnfs.add(rscnf);</span>

<span class="nc" id="L1570">        }</span>
<span class="nc" id="L1571">        return rscnfs;</span>
    }

    /**
     * Create the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR object.
     * 
     * @param masterSecret the OSCORE Master Secret
     * @param rsName the name of the Resource Server
     * 
     * @return the value of a 'cnf' claim as an &quot;OSCORE_Input_Material&quot; CBOR object
     */
    synchronized private CBORObject makeOscoreCnf(byte[] masterSecret, String rsName) {
<span class="fc" id="L1583">        CBORObject osccnf = CBORObject.NewMap();</span>
<span class="fc" id="L1584">        CBORObject osc = CBORObject.NewMap();</span>

<span class="fc" id="L1586">        osc.Add(Constants.OS_MS, masterSecret);</span>

<span class="fc" id="L1588">        osc.Add(Constants.OS_ID, Util.intToBytes(OSCORE_material_counter));</span>
<span class="fc" id="L1589">        OSCORE_material_counter++;</span>

<span class="fc bfc" id="L1591" title="All 2 branches covered.">        if (masterSaltSize != 0) {</span>
<span class="fc" id="L1592">            byte[] masterSalt = new byte[masterSaltSize];</span>
<span class="fc" id="L1593">            new SecureRandom().nextBytes(masterSalt);</span>
<span class="fc" id="L1594">            osc.Add(Constants.OS_SALT, masterSalt);</span>
        }

<span class="fc bfc" id="L1597" title="All 2 branches covered.">        if (this.provideIdContext == true) {</span>

            IdContextInfo idContextInfo;
<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">            if (this.idContextInfoMap.containsKey(rsName)) {</span>
<span class="nc" id="L1601">                idContextInfo = this.idContextInfoMap.get(rsName);</span>
            } else {
                // This is the first Access Token for this Resource Server
<span class="fc" id="L1604">                idContextInfo = new IdContextInfo();</span>
<span class="fc" id="L1605">                this.idContextInfoMap.put(rsName, idContextInfo);</span>
            }

<span class="fc" id="L1608">            byte[] idContext = idContextInfo.getIdContext();</span>
<span class="fc" id="L1609">            osc.Add(Constants.OS_CONTEXTID, idContext);</span>

        }

<span class="fc" id="L1613">        osccnf.Add(Constants.OSCORE_Input_Material, osc);</span>
<span class="fc" id="L1614">        return osccnf;</span>
    }

    /**
     * Create the value of a 'cnf' claim as a &quot;kid&quot; CBOR object.
     * 
     * @param oscId the Identifier of the OSCORE Input Material object
     * 
     * @return the value of a 'cnf' claim as a &quot;kid&quot; CBOR object
     */
    private CBORObject makeOscoreCnfUpdateAccessRights(CBORObject oscId) {
<span class="fc" id="L1625">        CBORObject osccnf = CBORObject.NewMap();</span>

<span class="fc" id="L1627">        osccnf.Add(Constants.COSE_KID_CBOR, oscId);</span>
<span class="fc" id="L1628">        return osccnf;</span>
    }

    /**
     * Process an authorization grant message
     * 
     * @param msg the message
     * 
     * @return the reply
     */
    private Message processAC(Message msg) {
        // 3. Check if the request has a grant
<span class="fc" id="L1640">        CBORObject cbor = msg.getParameter(Constants.CODE);</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">        if (cbor == null) {</span>
<span class="nc" id="L1642">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1643">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1644">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No code found for message&quot;);</span>
<span class="nc" id="L1645">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;No code found for message&quot;);</span>
<span class="nc" id="L1646">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">        if (!cbor.getType().equals(CBORType.TextString)) {</span>
<span class="nc" id="L1649">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1650">            map.Add(Constants.ERROR, Constants.INVALID_REQUEST);</span>
<span class="nc" id="L1651">            map.Add(Constants.ERROR_DESCRIPTION, &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1652">            LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant format&quot;);</span>
<span class="nc" id="L1653">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L1655">        String code = cbor.AsString();</span>

        // 4. Check if grant valid and unused
        try {
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">            if (!this.db.isGrantValid(code)) {</span>
<span class="nc" id="L1660">                CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1661">                map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1662">                LOGGER.log(Level.INFO, &quot;Message processing aborted: &quot; + &quot;Invalid grant&quot;);</span>
<span class="nc" id="L1663">                return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
            }
<span class="nc" id="L1665">        } catch (AceException e) {</span>
<span class="nc" id="L1666">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(checking grant): &quot; + e.getMessage());</span>
<span class="nc" id="L1667">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1668">        }</span>

        // 5. Mark grant invalid
        try {
<span class="fc" id="L1672">            this.db.useGrant(code);</span>
<span class="nc" id="L1673">        } catch (AceException e) {</span>
<span class="nc" id="L1674">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(marking grant invalid): &quot; + e.getMessage());</span>
<span class="nc" id="L1675">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1676">        }</span>

        // 6. Return the RS Information
<span class="fc" id="L1679">        CBORObject rsInfo = CBORObject.NewMap();</span>

        try {
<span class="fc" id="L1682">            Map&lt;Short, CBORObject&gt; rsInfoDB = this.db.getRsInfo(code);</span>
<span class="fc bfc" id="L1683" title="All 2 branches covered.">            for (Map.Entry&lt;Short, CBORObject&gt; e : rsInfoDB.entrySet()) {</span>
<span class="fc" id="L1684">                rsInfo.Add(e.getKey(), e.getValue());</span>
<span class="fc" id="L1685">            }</span>
<span class="nc" id="L1686">        } catch (AceException e) {</span>
<span class="nc" id="L1687">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted &quot; + &quot;(collecting RS Info&quot; + e.getMessage());</span>
<span class="nc" id="L1688">            return msg.failReply(Message.FAIL_INTERNAL_SERVER_ERROR, null);</span>
<span class="fc" id="L1689">        }</span>

<span class="pc bpc" id="L1691" title="2 of 4 branches missed.">        if (rsInfo == null || !rsInfo.getType().equals(CBORType.Map)) {</span>
<span class="nc" id="L1692">            LOGGER.log(Level.SEVERE, &quot;Message processing aborted: &quot; + &quot;no RS information found for grant: &quot; + code);</span>
<span class="nc" id="L1693">            CBORObject map = CBORObject.NewMap();</span>
<span class="nc" id="L1694">            map.Add(Constants.ERROR, Constants.INVALID_GRANT);</span>
<span class="nc" id="L1695">            map.Add(Constants.ERROR_DESCRIPTION, &quot;No token found for grant&quot;);</span>
<span class="nc" id="L1696">            return msg.failReply(Message.FAIL_BAD_REQUEST, map);</span>
        }
<span class="fc" id="L1698">        return msg.successReply(Message.CREATED, rsInfo);</span>
    }

    private boolean isSupported(String keyType, Set&lt;String&gt; aud) throws AceException {
<span class="fc" id="L1702">        Set&lt;String&gt; keyTypes = this.db.getSupportedPopKeyTypes(aud);</span>
<span class="fc" id="L1703">        return keyTypes.contains(keyType);</span>
    }

    /**
     * Retrieves a key from a cnf structure.
     * 
     * @param cnf the cnf structure
     * 
     * @return the key
     * 
     * @throws AceException
     * @throws CoseException
     */
    private OneKey getKey(CBORObject cnf, String id) throws AceException, CoseException {
<span class="fc" id="L1717">        CBORObject crpk = null;</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        if (cnf.ContainsKey(Constants.COSE_KEY_CBOR)) {</span>
<span class="fc" id="L1719">            crpk = cnf.get(Constants.COSE_KEY_CBOR);</span>
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">            if (crpk == null) {</span>
<span class="nc" id="L1721">                return null;</span>
            }
<span class="fc" id="L1723">            return new OneKey(crpk);</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        } else if (cnf.ContainsKey(Constants.COSE_ENCRYPTED_CBOR)) {</span>
<span class="fc" id="L1725">            Encrypt0Message msg = new Encrypt0Message();</span>
<span class="fc" id="L1726">            CBORObject encC = cnf.get(Constants.COSE_ENCRYPTED_CBOR);</span>
            try {
<span class="nc" id="L1728">                msg.DecodeFromCBORObject(encC);</span>
<span class="nc" id="L1729">                OneKey psk = this.db.getCPSK(id);</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">                if (psk == null) {</span>
<span class="nc" id="L1731">                    LOGGER.severe(&quot;Couldn't find a key to decrypt cnf parameter&quot;);</span>
<span class="nc" id="L1732">                    throw new AceException(&quot;No key found to decrypt cnf parameter&quot;);</span>
                }
<span class="nc" id="L1734">                CBORObject key = psk.get(KeyKeys.Octet_K);</span>
<span class="nc bnc" id="L1735" title="All 4 branches missed.">                if (key == null || !key.getType().equals(CBORType.ByteString)) {</span>
<span class="nc" id="L1736">                    LOGGER.severe(&quot;Corrupt key retrieved from database&quot;);</span>
<span class="nc" id="L1737">                    throw new AceException(&quot;Key error in the database&quot;);</span>
                }
<span class="nc" id="L1739">                msg.decrypt(key.GetByteString());</span>
<span class="nc" id="L1740">                CBORObject keyData = CBORObject.DecodeFromBytes(msg.GetContent());</span>
<span class="nc" id="L1741">                return new OneKey(keyData);</span>
<span class="fc" id="L1742">            } catch (CoseException e) {</span>
<span class="fc" id="L1743">                LOGGER.severe(&quot;Error while decrypting a cnf claim: &quot; + e.getMessage());</span>
<span class="fc" id="L1744">                throw new AceException(&quot;Error while decrypting a cnf parameter&quot;);</span>
            }
        } // Note: We checked the COSE_KID_CBOR case before
<span class="fc" id="L1747">        throw new AceException(&quot;Malformed cnf structure&quot;);</span>
    }

    /**
     * Removes a token from the registry
     * 
     * @param cti the token identifier Base64 encoded
     * @throws AceException
     */
    public void removeToken(String cti) throws AceException {
<span class="nc" id="L1757">        this.db.deleteToken(cti);</span>

<span class="nc" id="L1759">        this.cti2aud.remove(cti);</span>
<span class="nc" id="L1760">        this.cti2oscId.remove(cti);</span>
<span class="nc" id="L1761">        this.cti2kid.remove(cti);</span>

        // FIXME: Add the token to the TRL
<span class="nc" id="L1764">    }</span>

    @Override
    public void close() throws AceException {
<span class="nc" id="L1768">        this.db.saveCtiCounter(this.cti);</span>

<span class="nc bnc" id="L1770" title="All 2 branches missed.">        for (String rs : exiSequenceNumbers.keySet())</span>
<span class="nc" id="L1771">            this.db.saveExiSequenceNumber(exiSequenceNumbers.get(rs).intValue(), rs);</span>

<span class="nc" id="L1773">        this.db.close();</span>
<span class="nc" id="L1774">    }</span>

    /**
     * Relevant only when the OSCORE profile is used
     * 
     * An instance of this class tracks the status of OSCORE Id Contexts assigned to a Resource Server
     */
    class IdContextInfo {

        short currentSize;
        int currentValue;

<span class="fc" id="L1786">        public IdContextInfo() {</span>
<span class="fc" id="L1787">            currentSize = 1;</span>
<span class="fc" id="L1788">            currentValue = 0;</span>
<span class="fc" id="L1789">        }</span>

        // Retrieve the next unassigned IdContext for this Resource Server,
        // using the smallest possible size in bytes. That is, first consume all
        // the Id Contexts of 1 byte in size, then all the Id Contexts of 2
        // bytes in size, and so on up to 4 bytes in size.
        synchronized public byte[] getIdContext() {

            // Check if the size has to be changed
<span class="pc bpc" id="L1798" title="2 of 3 branches missed.">            switch (currentSize) {</span>

            case 1: // Max value: 2^8 - 1
            case 2: // Max value: 2^16 - 1
            case 3: // Max value: 2^24 - 1
<span class="pc bpc" id="L1803" title="1 of 2 branches missed.">                if (currentValue == ((1 &lt;&lt; (currentSize * 8)) - 1)) {</span>
<span class="nc" id="L1804">                    currentSize++;</span>
<span class="nc" id="L1805">                    currentValue = 0;</span>
                }
                break;
            case 4: // Max value: 2^31 - 1 --- The other half is for negative
                    // integers
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                if (currentValue == ((1 &lt;&lt; ((currentSize * 8) - 1)) - 1)) {</span>
<span class="nc" id="L1811">                    currentSize = 1;</span>
<span class="nc" id="L1812">                    currentValue = 0;</span>
                }
                break;
            default:
<span class="nc" id="L1816">                return null;</span>
            }

<span class="fc" id="L1819">            byte[] idContext = null;</span>
<span class="pc bpc" id="L1820" title="4 of 5 branches missed.">            switch (currentSize) {</span>
            case 1:
<span class="fc" id="L1822">                idContext = new byte[] { (byte) (currentValue) };</span>
<span class="fc" id="L1823">                break;</span>
            case 2:
<span class="nc" id="L1825">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };</span>
<span class="nc" id="L1826">                break;</span>
            case 3:
<span class="nc" id="L1828">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 16), (byte) (currentValue &gt;&gt;&gt; 8),</span>
                                        (byte) currentValue };
<span class="nc" id="L1830">                break;</span>
            case 4:
<span class="nc" id="L1832">                idContext = new byte[] { (byte) (currentValue &gt;&gt;&gt; 24), (byte) (currentValue &gt;&gt;&gt; 16),</span>
                                        (byte) (currentValue &gt;&gt;&gt; 8), (byte) currentValue };
                break;
            }

<span class="fc" id="L1837">            currentValue++;</span>
<span class="fc" id="L1838">            return idContext;</span>

        }

        // Free up the Id Context latest assigned for this Resource Server
        synchronized public void rollback() {

<span class="nc bnc" id="L1845" title="All 2 branches missed.">            if (currentValue != 0) {</span>
<span class="nc" id="L1846">                currentValue--;</span>
            } else {
<span class="nc bnc" id="L1848" title="All 3 branches missed.">                switch (currentSize) {</span>
                case 1: // Restore the maximum value: 2^31 - 1 --- The other
                        // half is for negative integers
<span class="nc" id="L1851">                    currentSize = 4;</span>
<span class="nc" id="L1852">                    currentValue = (1 &lt;&lt; ((currentSize * 8) - 1)) - 1;</span>
<span class="nc" id="L1853">                    break;</span>
                case 2: // Restore the maximum value: 2^8 - 1
                case 3: // Restore the maximum value: 2^16 - 1
                case 4: // Restore the maximum value: 2^24 - 1
<span class="nc" id="L1857">                    currentSize--;</span>
<span class="nc" id="L1858">                    currentValue = (1 &lt;&lt; (currentSize * 8)) - 1;</span>
                    break;
                }
            }
<span class="nc" id="L1862">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
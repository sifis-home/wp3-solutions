<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncryptCommon.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.cose</a> &gt; <span class="el_source">EncryptCommon.java</span></div><h1>EncryptCommon.java</h1><pre class="source lang-java linenums">/*******************************************************************************

 * Copyright (c) 2016, Jim Schaad
 * Copyright (c) 2018, Tobias Andersson, RISE SICS
 * Copyright (c) 2018, Rikard HÃ¶glund, RISE SICS
 * All rights reserved.

 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.

 * Neither the name of COSE-JAVA nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     
 ******************************************************************************/
package org.eclipse.californium.cose;

import com.upokecenter.cbor.CBORObject;
import com.upokecenter.cbor.CBORType;

import java.nio.ByteBuffer;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.scandium.dtls.cipher.CCMBlockCipher;

/**
 * 
 * This class is copied from the COSE Java repository. Changes made: Directly
 * changed the used cipher to Scandiums CCMBlockCipher code. Removing support
 * for a wider array of AES algorithms.
 *
 */
<span class="fc" id="L59">public abstract class EncryptCommon extends Message {</span>

	private final static int AES_CCM_16_IV_LENGTH = 13;
	private final static int AES_CCM_64_IV_LENGTH = 7;

<span class="fc" id="L64">	private final String AES_SPEC = &quot;AES&quot;;</span>
<span class="fc" id="L65">	private final String AES_GCM_SPEC = AES_SPEC + &quot;/GCM/NoPadding&quot;;</span>
	private final static int AES_GCM_IV_LENGTH = 12;

	protected String context;
	protected byte[] rgbEncrypt;
<span class="fc" id="L70">	SecureRandom random = new SecureRandom();</span>

	protected byte[] decryptWithKey(byte[] rgbKey) throws CoseException {
<span class="fc" id="L73">		CBORObject algX = findAttribute(HeaderKeys.Algorithm);</span>
<span class="fc" id="L74">		AlgorithmID alg = AlgorithmID.FromCBOR(algX);</span>

<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (rgbEncrypt == null)</span>
<span class="nc" id="L77">			throw new CoseException(&quot;No Encrypted Content Specified&quot;);</span>

<span class="pc bpc" id="L79" title="1 of 3 branches missed.">		switch (alg) {</span>
		case AES_GCM_128:
		case AES_GCM_192:
		case AES_GCM_256:
<span class="fc" id="L83">			AES_GCM_Decrypt(alg, rgbKey);</span>
<span class="fc" id="L84">			break;</span>

		case AES_CCM_16_64_128:
		case AES_CCM_16_128_128:
		case AES_CCM_16_128_256:
		case AES_CCM_64_64_128:
		case AES_CCM_64_128_128:
<span class="fc" id="L91">			AES_CCM_Decrypt(alg, rgbKey);</span>
<span class="fc" id="L92">			break;</span>

		default:
<span class="nc" id="L95">			throw new CoseException(&quot;Unsupported Algorithm Specified&quot;);</span>
		}

<span class="fc" id="L98">		return rgbContent;</span>
	}

	void encryptWithKey(byte[] rgbKey) throws CoseException, IllegalStateException {
<span class="fc" id="L102">		CBORObject algX = findAttribute(HeaderKeys.Algorithm);</span>
<span class="fc" id="L103">		AlgorithmID alg = AlgorithmID.FromCBOR(algX);</span>

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		if (rgbContent == null)</span>
<span class="nc" id="L106">			throw new CoseException(&quot;No Content Specified&quot;);</span>

<span class="pc bpc" id="L108" title="1 of 3 branches missed.">		switch (alg) {</span>
		case AES_GCM_128:
		case AES_GCM_192:
		case AES_GCM_256:
<span class="fc" id="L112">			AES_GCM_Encrypt(alg, rgbKey);</span>
<span class="fc" id="L113">			break;</span>

		case AES_CCM_16_64_128:
		case AES_CCM_16_128_128:
		case AES_CCM_16_128_256:
		case AES_CCM_64_64_128:
		case AES_CCM_64_128_128:
<span class="fc" id="L120">			AES_CCM_Encrypt(alg, rgbKey);</span>
<span class="fc" id="L121">			break;</span>

		default:
<span class="nc" id="L124">			throw new CoseException(&quot;Unsupported Algorithm Specified&quot;);</span>
		}
		
<span class="fc" id="L127">		ProcessCounterSignatures();</span>
<span class="fc" id="L128">	}</span>

	// Method taken from EncryptCommon in COSE. This will provide the full AAD /
	// Encrypt0-structure.
	private byte[] getAADBytes() {
<span class="fc" id="L133">		CBORObject obj = CBORObject.NewArray();</span>

<span class="fc" id="L135">		obj.Add(context);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">		if (objProtected.size() == 0)</span>
<span class="fc" id="L137">			rgbProtected = new byte[0];</span>
		else
<span class="nc" id="L139">			rgbProtected = objProtected.EncodeToBytes();</span>

<span class="fc" id="L141">		obj.Add(rgbProtected);</span>
<span class="fc" id="L142">		obj.Add(CBORObject.FromObject(externalData));</span>

<span class="fc" id="L144">		return obj.EncodeToBytes();</span>
	}

	private void AES_CCM_Decrypt(AlgorithmID alg, byte[] rgbKey) throws CoseException, IllegalStateException {
		// validate key
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">		if (rgbKey.length != alg.getKeySize() / Byte.SIZE) {</span>
<span class="nc" id="L150">			throw new CoseException(&quot;Key Size is incorrect&quot;);</span>
		}

		// obtain and validate IV
<span class="fc" id="L154">		final int ivLen = ivLength(alg);</span>
<span class="fc" id="L155">		CBORObject iv = findAttribute(HeaderKeys.IV);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">		if (iv == null) {</span>
<span class="nc" id="L157">			throw new CoseException(&quot;Missing IV during decryption&quot;);</span>
		}
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">		if (iv.getType() != CBORType.ByteString) {</span>
<span class="nc" id="L160">			throw new CoseException(&quot;IV is incorrectly formed&quot;);</span>
		}
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">		if (iv.GetByteString().length != ivLen) {</span>
<span class="nc" id="L163">			throw new CoseException(&quot;IV size is incorrect&quot;);</span>
		}

		//Modified to use the full AAD here rather than just the external AAD
		// Tag length (last parameter) was also included
<span class="fc" id="L168">		byte[] aad = getAADBytes();</span>
		
		try {
<span class="fc" id="L171">			rgbContent = CCMBlockCipher.decrypt(new SecretKeySpec(rgbKey, &quot;AES&quot;), iv.GetByteString(), aad,</span>
<span class="fc" id="L172">					getEncryptedContent(), alg.getTagSize() / Byte.SIZE);</span>
<span class="nc" id="L173">		} catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L174">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L175">		} catch (InvalidKeyException ex) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (ex.getMessage().equals(&quot;Illegal key size&quot;)) {</span>
<span class="nc" id="L177">				throw new CoseException(&quot;Unsupported key size&quot;, ex);</span>
			}
<span class="nc" id="L179">			throw new CoseException(&quot;Decryption failure&quot;, ex);</span>
<span class="fc" id="L180">		} catch (Exception ex) {</span>
<span class="fc" id="L181">			ex.printStackTrace();</span>
<span class="fc" id="L182">			throw new CoseException(&quot;Decryption failure&quot;, ex);</span>
<span class="fc" id="L183">		}</span>
<span class="fc" id="L184">	}</span>

	private void AES_CCM_Encrypt(AlgorithmID alg, byte[] rgbKey) throws CoseException, IllegalStateException {
<span class="fc" id="L187">		SecureRandom random = new SecureRandom();</span>

		// validate key
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		if (rgbKey.length != alg.getKeySize() / Byte.SIZE) {</span>
<span class="nc" id="L191">			throw new CoseException(&quot;Key Size is incorrect&quot;);</span>
		}

		// obtain and validate iv
<span class="fc" id="L195">		CBORObject iv = findAttribute(HeaderKeys.IV);</span>
<span class="fc" id="L196">		int ivLen = ivLength(alg);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if (iv == null) {</span>
<span class="nc" id="L198">			byte[] tmp = new byte[ivLen];</span>
<span class="nc" id="L199">			random.nextBytes(tmp);</span>
<span class="nc" id="L200">			iv = CBORObject.FromObject(tmp);</span>
<span class="nc" id="L201">			addAttribute(HeaderKeys.IV, iv, Attribute.UNPROTECTED);</span>
<span class="nc" id="L202">		} else {</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">			if (iv.getType() != CBORType.ByteString) {</span>
<span class="nc" id="L204">				throw new CoseException(&quot;IV is incorreclty formed.&quot;);</span>
			}
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">			if (iv.GetByteString().length &gt; ivLen) {</span>
<span class="nc" id="L207">				throw new CoseException(&quot;IV is too long.&quot;);</span>
			}
		}
		
		//Modified to use the full AAD here rather than just the external AAD
		// Tag length (last parameter) was also included
<span class="fc" id="L213">		byte[] aad = getAADBytes();</span>
		
		try {
<span class="fc" id="L216">			rgbEncrypt = CCMBlockCipher.encrypt(new SecretKeySpec(rgbKey, &quot;AES&quot;), iv.GetByteString(), aad, GetContent(),</span>
<span class="fc" id="L217">					alg.getTagSize() / Byte.SIZE);</span>
<span class="nc" id="L218">		} catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L219">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L220">		} catch (Exception ex) {</span>
<span class="nc" id="L221">			throw new CoseException(&quot;Encryption failure&quot;, ex);</span>
<span class="fc" id="L222">		}</span>
<span class="fc" id="L223">	}</span>

	private void AES_GCM_Decrypt(AlgorithmID alg, byte[] rgbKey) throws CoseException {
<span class="fc" id="L226">		CBORObject iv = findAttribute(HeaderKeys.IV);</span>

		// validate key
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">		if (rgbKey.length != alg.getKeySize() / 8) {</span>
<span class="nc" id="L230">			throw new CoseException(&quot;Key Size is incorrect&quot;);</span>
		}

		// get and validate iv
<span class="fc" id="L234">		final int ivLen = ivLength(alg);</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">		if (iv == null) {</span>
<span class="nc" id="L236">			throw new CoseException(&quot;Missing IV during decryption&quot;);</span>
		}
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">		if (iv.getType() != CBORType.ByteString) {</span>
<span class="nc" id="L239">			throw new CoseException(&quot;IV is incorrectly formed&quot;);</span>
		}
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">		if (iv.GetByteString().length != ivLen) {</span>
<span class="nc" id="L242">			throw new CoseException(&quot;IV size is incorrect&quot;);</span>
		}

		try {
			// create and prepare cipher
			Cipher cipher;
<span class="fc" id="L248">			cipher = Cipher.getInstance(AES_GCM_SPEC);</span>
<span class="fc" id="L249">			cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(rgbKey, &quot;AES&quot;),</span>
<span class="fc" id="L250">					new GCMParameterSpec(alg.getTagSize(), iv.GetByteString()));</span>
<span class="fc" id="L251">			cipher.updateAAD(getAADBytes());</span>

			// setup plaintext output
<span class="fc" id="L254">			rgbContent = new byte[cipher.getOutputSize(rgbEncrypt.length)];</span>

			// decryptit!
<span class="fc" id="L257">			ByteBuffer input = ByteBuffer.wrap(rgbEncrypt);</span>
<span class="fc" id="L258">			ByteBuffer output = ByteBuffer.wrap(rgbContent);</span>
<span class="fc" id="L259">			cipher.doFinal(input, output);</span>
<span class="nc" id="L260">		} catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L261">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L262">		} catch (InvalidKeyException ex) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			if (ex.getMessage() == &quot;Illegal key size&quot;) {</span>
<span class="nc" id="L264">				throw new CoseException(&quot;Unsupported key size&quot;, ex);</span>
			}
<span class="nc" id="L266">			throw new CoseException(&quot;Decryption failure&quot;, ex);</span>
<span class="nc" id="L267">		} catch (Exception ex) {</span>
<span class="nc" id="L268">			throw new CoseException(&quot;Decryption failure&quot;, ex);</span>
<span class="fc" id="L269">		}</span>
<span class="fc" id="L270">	}</span>

	private void AES_GCM_Encrypt(AlgorithmID alg, byte[] rgbKey) throws CoseException, IllegalStateException {
		// validate key
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">		if (rgbKey.length != alg.getKeySize() / 8) {</span>
<span class="nc" id="L275">			throw new CoseException(&quot;Key Size is incorrect&quot;);</span>
		}

		// obtain and validate iv
<span class="fc" id="L279">		final int ivLen = ivLength(alg);</span>
<span class="fc" id="L280">		CBORObject iv = findAttribute(HeaderKeys.IV);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">		if (iv == null) {</span>
			// generate IV
<span class="nc" id="L283">			byte[] tmp = new byte[ivLen];</span>
<span class="nc" id="L284">			random.nextBytes(tmp);</span>
<span class="nc" id="L285">			iv = CBORObject.FromObject(tmp);</span>
<span class="nc" id="L286">			addAttribute(HeaderKeys.IV, iv, PROTECTED);</span>
<span class="nc" id="L287">		} else {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">			if (iv.getType() != CBORType.ByteString) {</span>
<span class="nc" id="L289">				throw new CoseException(&quot;IV is incorrectly formed&quot;);</span>
			}
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">			if (iv.GetByteString().length != ivLen) {</span>
<span class="nc" id="L292">				throw new CoseException(&quot;IV size is incorrect&quot;);</span>
			}
		}

		try {
<span class="fc" id="L297">			Cipher cipher = Cipher.getInstance(AES_GCM_SPEC);</span>
<span class="fc" id="L298">			cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(rgbKey, AES_SPEC),</span>
<span class="fc" id="L299">					new GCMParameterSpec(alg.getTagSize(), iv.GetByteString()));</span>
<span class="fc" id="L300">			cipher.updateAAD(getAADBytes());</span>

<span class="fc" id="L302">			rgbEncrypt = new byte[cipher.getOutputSize(rgbContent.length)];</span>
<span class="fc" id="L303">			ByteBuffer input = ByteBuffer.wrap(rgbContent);</span>
<span class="fc" id="L304">			ByteBuffer output = ByteBuffer.wrap(rgbEncrypt);</span>
<span class="fc" id="L305">			cipher.doFinal(input, output);</span>
<span class="nc" id="L306">		} catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L307">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L308">		} catch (Exception ex) {</span>
<span class="nc" id="L309">			throw new CoseException(&quot;Encryption failure&quot;, ex);</span>
<span class="fc" id="L310">		}</span>
<span class="fc" id="L311">	}</span>

	/**
	 * Used to obtain the encrypted content for the cases where detached content
	 * is requested.
	 * 
	 * @return bytes of the encrypted content
	 * @throws CoseException if content has not been encrypted
	 */
	public byte[] getEncryptedContent() throws CoseException {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		if (rgbEncrypt == null)</span>
<span class="nc" id="L322">			throw new CoseException(&quot;No Encrypted Content Specified&quot;);</span>

<span class="fc" id="L324">		return rgbEncrypt;</span>
	}

	/**
	 * Set the encrypted content for detached content cases.
	 * 
	 * @param rgb encrypted content to be used
	 */
	public void setEncryptedContent(byte[] rgb) {
<span class="fc" id="L333">		rgbEncrypt = rgb;</span>
<span class="fc" id="L334">	}</span>

	protected void ProcessCounterSignatures() throws CoseException {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (!counterSignList.isEmpty()) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			if (counterSignList.size() == 1) {</span>
<span class="nc" id="L339">				counterSignList.get(0).sign(rgbProtected, rgbEncrypt);</span>
<span class="nc" id="L340">				addAttribute(HeaderKeys.CounterSignature, counterSignList.get(0).EncodeToCBORObject(),</span>
						Attribute.UNPROTECTED);
			} else {
<span class="nc" id="L343">				CBORObject list = CBORObject.NewArray();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">				for (CounterSign sig : counterSignList) {</span>
<span class="nc" id="L345">					sig.sign(rgbProtected, rgbEncrypt);</span>
<span class="nc" id="L346">					list.Add(sig.EncodeToCBORObject());</span>
<span class="nc" id="L347">				}</span>
<span class="nc" id="L348">				addAttribute(HeaderKeys.CounterSignature, list, Attribute.UNPROTECTED);</span>
			}
		}

<span class="fc bfc" id="L352" title="All 2 branches covered.">		if (counterSign1 != null) {</span>
<span class="fc" id="L353">			counterSign1.sign(rgbProtected, rgbEncrypt);</span>
<span class="fc" id="L354">			addAttribute(HeaderKeys.CounterSignature0, counterSign1.EncodeToCBORObject(), Attribute.UNPROTECTED);</span>
		}
<span class="fc" id="L356">	}</span>

	public boolean validate(CounterSign1 countersignature) throws CoseException {

		// Fix issue with rgbProtected being NULL instead of empty CBOR bstr
		// when doing verification before decryption.
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">		if (objProtected.size() == 0)</span>
<span class="fc" id="L363">			rgbProtected = new byte[0];</span>
		else
<span class="nc" id="L365">			rgbProtected = objProtected.EncodeToBytes();</span>

<span class="fc" id="L367">		return countersignature.validate(rgbProtected, rgbEncrypt);</span>
	}

	public boolean validate(CounterSign countersignature) throws CoseException {
<span class="nc" id="L371">		return countersignature.validate(rgbProtected, rgbEncrypt);</span>
	}

	/**
	 * Get IV length in bytes.
	 * 
	 * @param alg algorithm ID:
	 * @return iv length
	 */
	public static int ivLength(AlgorithmID alg) {
<span class="fc bfc" id="L381" title="All 4 branches covered.">		switch (alg) {</span>
		case AES_CCM_16_64_128:
		case AES_CCM_16_128_128:
		case AES_CCM_16_128_256:
<span class="fc" id="L385">			return AES_CCM_16_IV_LENGTH;</span>
		case AES_CCM_64_64_128:
		case AES_CCM_64_128_128:
<span class="fc" id="L388">			return AES_CCM_64_IV_LENGTH;</span>
		case AES_GCM_128:
		case AES_GCM_192:
		case AES_GCM_256:
<span class="fc" id="L392">			return AES_GCM_IV_LENGTH;</span>
		default:
<span class="fc" id="L394">			return -1;</span>
		}
	}

	/**
	 * Check if an algorithm is supported.
	 * 
	 * @param alg the algorithm
	 * @return if it is supported
	 */
	public static boolean isSupportedAes(AlgorithmID alg) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (ivLength(alg) == -1) {</span>
<span class="nc" id="L406">			return false;</span>
		} else {
<span class="nc" id="L408">			return true;</span>
		}
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
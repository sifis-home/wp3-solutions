<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyRemapping.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore.group</a> &gt; <span class="el_source">KeyRemapping.java</span></div><h1>KeyRemapping.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2023 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore.group;

import java.math.BigInteger;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;
import org.eclipse.californium.elements.util.StringUtil;

import net.i2p.crypto.eddsa.EdDSAPublicKey;
import net.i2p.crypto.eddsa.math.Field;
import net.i2p.crypto.eddsa.math.FieldElement;
import net.i2p.crypto.eddsa.math.bigint.BigIntegerFieldElement;
import net.i2p.crypto.eddsa.math.bigint.BigIntegerLittleEndianEncoding;

/**
 * Class implementing functionality for key remapping from Edwards coordinates
 * to Montgomery coordinates.
 *
 */
<span class="nc" id="L36">public class KeyRemapping {</span>

	/*
	 * Useful links:
	 * https://crypto.stackexchange.com/questions/63732/curve-25519-x25519-
	 * ed25519-convert-coordinates-between-montgomery-curve-and-t/63734
	 * 
	 * https://tools.ietf.org/html/rfc7748
	 * 
	 * https://tools.ietf.org/html/rfc8032
	 */

	// Create the ed25519 field
<span class="fc" id="L49">	private static Field ed25519Field = new Field(256, // b</span>
<span class="fc" id="L50">			StringUtil.hex2ByteArray(&quot;edffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f&quot;), // q(2^255-19)</span>
			new BigIntegerLittleEndianEncoding());

	// Value of sqrt(-486664) hardcoded (note that there are 2 roots)
<span class="fc" id="L54">	private static BigIntegerFieldElement root = new BigIntegerFieldElement(ed25519Field,</span>
			new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));

	/**
	 * Calculate Curve25519 u coordinate from Ed25519 y coordinate
	 * 
	 * @param y the Ed25519 y coordinate
	 * @return the Curve25519 u coordinate
	 */
	static FieldElement calcCurve25519_u(FieldElement y) {

		/* Calculate u from y */
		// u = (1+y)/(1-y)

		// 1 + y -&gt; y + 1
<span class="fc" id="L69">		FieldElement one_plus_y = y.addOne();</span>

		// 1 - y -&gt; -y + 1
<span class="fc" id="L72">		FieldElement one_minus_y = (y.negate()).addOne();</span>

		// invert(1 - y)
<span class="fc" id="L75">		FieldElement one_minus_y_invert = one_minus_y.invert();</span>

		// (1 + y) / (1 - y) -&gt; (1 + y) * invert(1 - y)
<span class="fc" id="L78">		FieldElement u = one_plus_y.multiply(one_minus_y_invert);</span>

<span class="fc" id="L80">		return u;</span>

	}

	/**
	 * Calculate Curve25519 v coordinate from Ed25519 x coordinate and
	 * Curve25519 u coordinate
	 * 
	 * @param x the Ed25519 x coordinate
	 * @param u the Curve25519 u coordinate
	 * @return the Curve25519 v coordinate
	 */
	static FieldElement calcCurve25519_v(FieldElement x, FieldElement u) {

		/* Calculate v from u and x */
		// v = sqrt(-486664)*u/x

		// invert(x)
<span class="fc" id="L98">		FieldElement x_invert = x.invert();</span>

		// u / x -&gt; u * invert(x)
<span class="fc" id="L101">		FieldElement u_over_x = u.multiply(x_invert);</span>

		// calculate v
<span class="fc" id="L104">		FieldElement v = root.multiply(u_over_x);</span>

<span class="fc" id="L106">		return v;</span>

	}

	/* COSE related functions below */

	/**
	 * Extract the y point coordinate from a COSE Key (OneKey). Alternative way
	 * using division.
	 * 
	 * @param key the COSE key
	 * @return the y point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_y_alt(OneKey key) throws CoseException {
<span class="fc" id="L122">		EdDSAPublicKey pubKey = (EdDSAPublicKey) key.AsPublicKey();</span>

		// Get projective coordinates for Y and Z
<span class="fc" id="L125">		FieldElement Y = pubKey.getA().getY();</span>
<span class="fc" id="L126">		FieldElement Z = pubKey.getA().getZ();</span>

		// y = Y/Z -&gt; y = Y * invert(Z)
<span class="fc" id="L129">		FieldElement recip = Z.invert();</span>
<span class="fc" id="L130">		FieldElement y = Y.multiply(recip);</span>

<span class="fc" id="L132">		return y;</span>
	}

	/**
	 * Extract the y point coordinate from a COSE Key (OneKey). Way using the X
	 * value of the key directly, clearing one bit.
	 * https://tools.ietf.org/html/rfc8032#section-5.1.2
	 * 
	 * @param key the COSE key
	 * @return the y point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_y(OneKey key) throws CoseException {

		// Retrieve X value from COSE key as byte array
<span class="fc" id="L148">		byte[] X_value = key.get(KeyKeys.OKP_X).GetByteString();</span>

		// Clear most significant bit of the final octet in the X value (that
		// indicates sign of x coordinate). The result is the y coordinate.
<span class="fc" id="L152">		byte[] y_array = X_value.clone();</span>
<span class="fc" id="L153">		y_array[y_array.length - 1] &amp;= 0B01111111;</span>

		// The array must be reversed to have correct byte order
		// BigInteger wants Big Endian but it is in Little Endian
<span class="fc" id="L157">		byte[] y_array_inv = invertArray(y_array);</span>

		// Create field element for y from updated X value
<span class="fc" id="L160">		FieldElement y = new BigIntegerFieldElement(ed25519Field, new BigInteger(y_array_inv));</span>

<span class="fc" id="L162">		return y;</span>
	}

	/**
	 * Extract the x point coordinate from a COSE Key (OneKey). Way using
	 * division.
	 * 
	 * @param key the COSE key
	 * @return the x point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_x(OneKey key) throws CoseException {
<span class="fc" id="L175">		EdDSAPublicKey pubKey = (EdDSAPublicKey) key.AsPublicKey();</span>

		// Get projective coordinates for X and Z
<span class="fc" id="L178">		FieldElement X = pubKey.getA().getX();</span>
<span class="fc" id="L179">		FieldElement Z = pubKey.getA().getZ();</span>

		// x = X/Z -&gt; x = X * invert(Z)
<span class="fc" id="L182">		FieldElement recip = Z.invert();</span>
<span class="fc" id="L183">		FieldElement x = X.multiply(recip);</span>

<span class="fc" id="L185">		return x;</span>
	}

	/**
	 * Invert a byte array
	 * 
	 * @param input the input byte array
	 * @return the inverted byte array
	 */
	public static byte[] invertArray(byte[] input) {
<span class="fc" id="L195">		byte[] output = input.clone();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">		for (int i = 0; i &lt; input.length; i++) {</span>
<span class="fc" id="L197">			output[i] = input[input.length - i - 1];</span>
		}
<span class="fc" id="L199">		return output;</span>
	}

	/* Methods for Weierstrass conversions below */
	// https://tools.ietf.org/html/draft-ietf-lwig-curve-representations-10#appendix-E.2

	/**
	 * Remap a Curve25519 u coordinate to a Wei25519 X coordinate.
	 * 
	 * @param u the Curve25519 u coordinate
	 * 
	 * @return the Wei25519 X coordinate
	 */
	public static FieldElement curve25519uToWei25519X(FieldElement u) {
<span class="fc" id="L213">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L214">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>

		// X = u + A/3
<span class="fc" id="L217">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L219">		FieldElement X = u.add(AoverThree);</span>

<span class="fc" id="L221">		return X;</span>

	}

	/**
	 * Remap a Curve25519 v coordinate to a Wei25519 Y coordinate.
	 * 
	 * @param v the Curve25519 v coordinate
	 * 
	 * @return the Wei25519 Y coordinate
	 */
	public static FieldElement curve25519vToWei25519Y(FieldElement v) {
		// Y = v
<span class="fc" id="L234">		FieldElement Y = v;</span>

<span class="fc" id="L236">		return Y;</span>
	}

	/**
	 * Remap a Wei25519 X coordinate to a Curve25519 u coordinate.
	 * 
	 * @param X the Wei25519 X coordinate
	 * 
	 * @return the Curve25519 u coordinate
	 */
	public static FieldElement wei25519XToCurve25519u(FieldElement X) {
<span class="fc" id="L247">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L248">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>

		// u = X - A/3
<span class="fc" id="L251">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L253">		FieldElement u = X.subtract(AoverThree);</span>

<span class="fc" id="L255">		return u;</span>
	}

	/**
	 * Remap a Wei25519 Y coordinate to a Curve25519 v coordinate.
	 * 
	 * @param Y the Wei25519 Y coordinate
	 * 
	 * @return the Curve25519 v coordinate
	 */
	public static FieldElement wei25519YToCurve25519v(FieldElement Y) {
		// v = Y
<span class="fc" id="L267">		FieldElement v = Y;</span>

<span class="fc" id="L269">		return v;</span>

	}

	/**
	 * Remap a Edwards25519 y coordinate to a Wei25519 X coordinate
	 * 
	 * @param y the Edwards25519 y coordinate
	 * @return the Wei25519 X coordinate
	 */
	public static FieldElement edwards25519yToWei25519X(FieldElement y) {
		// X = ((1+y)/(1-y)+A/3

<span class="fc" id="L282">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L283">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L284">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>
<span class="fc" id="L285">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L287">		FieldElement onePlusY = one.add(y);</span>
<span class="fc" id="L288">		FieldElement oneMinusY = one.subtract(y);</span>

<span class="fc" id="L290">		FieldElement divided = onePlusY.multiply(oneMinusY.invert());</span>

<span class="fc" id="L292">		FieldElement X = divided.add(AoverThree);</span>

<span class="fc" id="L294">		return X;</span>
	}

	/**
	 * Remap a Edwards25519 x (&amp; y) coordinate to a Wei25519 Y coordinate
	 * 
	 * @param x the Edwards25519 x coordinate
	 * @param y the Edwards25519 y coordinate
	 * @return the Wei25519 Y coordinate
	 */
	public static FieldElement edwards25519xToWei25519Y(FieldElement x, FieldElement y) {
		// Y = c*(1+y)/((1-y)*x)

<span class="fc" id="L307">		BigIntegerFieldElement c = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));
<span class="fc" id="L309">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>

<span class="fc" id="L311">		FieldElement onePlusY = one.add(y);</span>
<span class="fc" id="L312">		FieldElement oneMinusY = one.subtract(y);</span>

<span class="fc" id="L314">		FieldElement onePlusYmultC = c.multiply(onePlusY);</span>
<span class="fc" id="L315">		FieldElement oneMinusYmultX = oneMinusY.multiply(x);</span>

<span class="fc" id="L317">		FieldElement Y = onePlusYmultC.multiply((oneMinusYmultX.invert()));</span>

<span class="fc" id="L319">		return Y;</span>
	}

	/**
	 * Remap a Weierstrass X coordinate to a Edwards25519 y coordinate
	 * 
	 * @param X the Weierstrass X coordinate
	 * @return the Edwards25519 y coordinate
	 */
	public static FieldElement wei25519XToEdwards25519y(FieldElement X) {
		// y = (X-A/3-1)/(X-A/3+1)

<span class="fc" id="L331">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L332">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L333">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>
<span class="fc" id="L334">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L336">		FieldElement numerator = X.subtract(AoverThree).subtract(one);</span>
<span class="fc" id="L337">		FieldElement denominator = X.subtract(AoverThree).add(one);</span>

<span class="fc" id="L339">		FieldElement y = numerator.multiply(denominator.invert());</span>

<span class="fc" id="L341">		return y;</span>
	}

	/**
	 * Remap a Weierstrass Y (&amp; X) coordinate to an Edwards25519 x coordinate
	 * 
	 * @param Y the Weierstrass Y coordinate
	 * @param X the Weierstrass X coordinate
	 * @return the Edwards25519 x coordinate
	 */
	public static FieldElement wei25519YToEdwards25519x(FieldElement Y, FieldElement X) {
		// x = (c*(X-A/3)/Y

<span class="fc" id="L354">		BigIntegerFieldElement c = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));

<span class="fc" id="L357">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L358">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L359">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L361">		FieldElement XminusAoverThree = X.subtract(AoverThree);</span>

<span class="fc" id="L363">		FieldElement numerator = XminusAoverThree.multiply(c);</span>
<span class="fc" id="L364">		FieldElement denominator = Y;</span>

<span class="fc" id="L366">		FieldElement x = numerator.multiply(denominator.invert());</span>

<span class="fc" id="L368">		return x;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
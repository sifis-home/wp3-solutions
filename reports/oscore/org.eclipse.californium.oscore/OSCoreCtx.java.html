<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OSCoreCtx.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">OSCoreCtx.java</span></div><h1>OSCoreCtx.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.eclipse.californium.core.coap.CoAP.Code;
import org.eclipse.californium.core.config.CoapConfig;
import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.EncryptCommon;
import org.eclipse.californium.elements.config.Configuration;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.oscore.group.GroupRecipientCtx;
import org.eclipse.californium.oscore.group.GroupSenderCtx;
import org.eclipse.californium.scandium.dtls.cipher.CCMBlockCipher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.upokecenter.cbor.CBORObject;

/**
 * 
 * Represents the Security Context and its parameters. At initiation derives the
 * keys and IVs. Also maintains replay window.
 *
 */
public class OSCoreCtx {

	/**
	 * The logger
	 */
<span class="fc" id="L64">	private static final Logger LOGGER = LoggerFactory.getLogger(OSCoreCtx.class);</span>

	private static final byte ZERO = 0;
	private static final byte ONE = 1;

	private AlgorithmID common_alg;
	private byte[] common_master_secret;
	private byte[] common_master_salt;
	private byte[] common_iv;
	private byte[] context_id;

	protected byte[] sender_id;
	protected byte[] sender_key;
	protected int sender_seq;

	protected byte[] recipient_id;
	protected byte[] recipient_key;
	protected int recipient_seq;
	protected int internal_recipient_seq;
	protected int recipient_replay_window_size;
	protected int recipient_replay_window;

	private AlgorithmID kdf;

<span class="fc" id="L88">	private int rollback_recipient_seq = -1;</span>
<span class="fc" id="L89">	private int rollback_recipient_replay = -1;</span>
<span class="fc" id="L90">	private byte[] rollback_last_block_tag = null;</span>

<span class="fc" id="L92">	private byte[] last_block_tag = null;</span>
<span class="fc" id="L93">	private int seqMax = Integer.MAX_VALUE;</span>

	private int id_length;
	private int iv_length;
	private int key_length;

<span class="fc" id="L99">	private Code CoAPCode = null;</span>

	/**
	 * Include the context id in messages generated using this context. This is
	 * generally optional and can be controlled by the application.
	 *
	 * Default value is false.
	 */
	private boolean includeContextId;

	/**
	 * Generate a new partial IV for outgoing Response messages. If this
	 * variable is false the same nonce from the original request will be used.
	 * Otherwise a new partial IV will be generated by the sender and included
	 * in the Response. This affects the calculation of the nonce.
	 *
	 * See https://tools.ietf.org/html/rfc8613#section-5.2
	 *
	 * This variable will control the behaviour when sending Response messages
	 * with this context. Note that Observe notifications will always include a
	 * new partial IV.
	 *
	 * Default value is false.
	 */
	private boolean responsesIncludePartialIV;
	
	/**
	 * Indicates if this client/server shall support the context re-derivation
	 * procedure.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#appendix-B.2
	 */
	private boolean contextRederivationEnabled;

	/**
	 * When using outer block-wise with OSCORE a proxy can maliciously inject
	 * block fragments. To protect against this a message with size exceeding
	 * this parameter should never be sent without inner block-wise. Likewise
	 * when receiving a message using outer block-wise it should be discarded if
	 * the cumulated size exceeds this parameter.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#section-4.1.3.4.2
	 */
	private int maxUnfragmentedSize;

	/**
	 * URI this Context is associated with if any.
	 *
	 * That is what URI it is associated and stored under in the HashMapCtxDB.
	 */
	private String uri;

	/**
	 * String versions of the context ID, sender ID and recipient ID.
	 *
	 * These are set when the context is created (rather than for every message)
	 * to be used later when adding information about the messages to the
	 * EndpointContext on sending or receiving a message.
	 */
	private final String contextIdString;
	private final String senderIdString;
	private final String recipientIdString;

	/**
	 * Key that is used during the context re-derivation process.
	 */
	private byte[] contextRederivationKey;

	/**
	 * Makes it possible to override the Context ID to include in messages.
	 * Typically this would be the Context ID this context was generated with
	 * but that is not the case for the context re-derivation procedure.
	 */
	private byte[] overrideContextId;

	/**
	 * Indicate which phase the context re-derivation procedure is in,
	 */
	private ContextRederivation.PHASE contextRederivationPhase;

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @throws OSException if the default KDF is not supported
	 */
	public OSCoreCtx(byte[] master_secret, boolean client) throws OSException {
<span class="fc" id="L188">		this(master_secret, client, Configuration.getStandard());</span>
<span class="fc" id="L189">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @param configuration configuration to be used by this context
	 * @throws OSException if the default KDF is not supported
	 * @since 3.0
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, Configuration configuration) throws OSException {
<span class="fc" id="L202">		this(master_secret, client, null, null, null, null, null, null, null,</span>
<span class="fc" id="L203">				configuration.get(CoapConfig.MAX_RESOURCE_BODY_SIZE));</span>
<span class="fc" id="L204">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters.
	 * 
	 * @param master_secret the master secret
	 * @param alg the encryption algorithm as defined in COSE
	 * @param client is this originally the client's context
	 * @param sender_id the sender id or null for default
	 * @param recipient_id the recipient id or null for default
	 * @param kdf the COSE algorithm abbreviation of the kdf or null for the
	 *            default
	 * @param replay_size the replay window size or null for the default
	 * @param master_salt the optional master salt, can be null
	 * @param contextId the context id, can be null
	 * @param maxUnfragmentedSize maximum unfragmented size 
	 *
	 * @throws OSException if the KDF is not supported
	 * @since 3.0 (added parameter maxUnfragmentedSize)
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, int maxUnfragmentedSize) throws OSException {
<span class="fc" id="L226">		this(master_secret, client, alg, sender_id, recipient_id, kdf, replay_size, master_salt, contextId,</span>
				maxUnfragmentedSize, false);
<span class="fc" id="L228">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters.
	 * 
	 * @param master_secret the master secret
	 * @param alg the encryption algorithm as defined in COSE
	 * @param client is this originally the client's context
	 * @param sender_id the sender id or null for default
	 * @param recipient_id the recipient id or null for default
	 * @param kdf the COSE algorithm abbreviation of the kdf or null for the
	 *            default
	 * @param replay_size the replay window size or null for the default
	 * @param master_salt the optional master salt, can be null
	 * @param contextId the context id, can be null
	 * @param maxUnfragmentedSize maximum unfragmented size
	 * @param appB1Enabled usage of Appendix B.1
	 *
	 * @throws OSException if the KDF is not supported
	 * @since 3.0 (added parameter maxUnfragmentedSize)
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, int maxUnfragmentedSize,
<span class="fc" id="L251">			boolean appB1Enabled) throws OSException {</span>

<span class="fc bfc" id="L253" title="All 2 branches covered.">		if (alg == null) {</span>
<span class="fc" id="L254">			this.common_alg = AlgorithmID.AES_CCM_16_64_128;</span>
		} else {
<span class="fc" id="L256">			this.common_alg = alg;</span>
		}

<span class="fc" id="L259">		setLengths();</span>

<span class="fc" id="L261">		this.sender_seq = 0;</span>
<span class="fc" id="L262">		this.recipient_seq = -1;</span>
<span class="fc" id="L263">		this.internal_recipient_seq = 0;</span>
		
<span class="fc bfc" id="L265" title="All 2 branches covered.">		if (master_secret != null) {</span>
<span class="fc" id="L266">			this.common_master_secret = master_secret.clone();</span>
		} else {
<span class="fc" id="L268">			LOGGER.error(&quot;Input master secret is null&quot;);</span>
<span class="fc" id="L269">			throw new NullPointerException(&quot;Input master secret is null&quot;);</span>
		}
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">		if (sender_id == null || sender_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">			this.sender_id = createByteArray(client ? ZERO : ONE);</span>
		} else {
<span class="fc" id="L274">			this.sender_id = sender_id.clone();</span>
		}

<span class="pc bpc" id="L277" title="1 of 4 branches missed.">		if (recipient_id == null || recipient_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">			this.recipient_id = createByteArray(client ? ONE : ZERO);</span>
		} else {
<span class="fc" id="L280">			this.recipient_id = recipient_id.clone();</span>
		}

<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (kdf == null) {</span>
<span class="fc" id="L284">			this.kdf = AlgorithmID.HKDF_HMAC_SHA_256;</span>
		} else {
<span class="fc" id="L286">			this.kdf = kdf;</span>
		}

<span class="fc bfc" id="L289" title="All 2 branches covered.">		if (replay_size == null) {</span>
<span class="fc" id="L290">			this.recipient_replay_window_size = 32;</span>
		} else {
<span class="fc" id="L292">			this.recipient_replay_window_size = replay_size.intValue();</span>
		}
<span class="fc" id="L294">		this.recipient_replay_window = 0;</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (master_salt == null) {</span>
			// Default value. Automatically initialized with 0-es.
<span class="fc" id="L298">			this.common_master_salt = new byte[this.kdf.getKeySize() / Byte.SIZE];</span>
		} else {
<span class="fc" id="L300">			this.common_master_salt = master_salt.clone();</span>
		}

<span class="fc bfc" id="L303" title="All 2 branches covered.">		if (contextId != null) {</span>
<span class="fc" id="L304">			this.context_id = contextId.clone();</span>
		} else {
<span class="fc" id="L306">			this.context_id = null;</span>
		}

		// Set default values for these flags
		//They can be set by the application using their setters
<span class="fc" id="L311">		includeContextId = false;</span>
<span class="fc" id="L312">		responsesIncludePartialIV = false;</span>
<span class="fc" id="L313">		contextRederivationEnabled = false;</span>

		//Set string versions of sender ID, recipient ID and Context ID
<span class="fc" id="L316">		contextIdString = toHex(this.context_id);</span>
<span class="fc" id="L317">		senderIdString = toHex(this.sender_id);</span>
<span class="fc" id="L318">		recipientIdString = toHex(this.recipient_id);</span>

		//Initialize the URI associated with the context
		//It will be overwritten if this context is added to a HashMapCtxDB
<span class="fc" id="L322">		uri = &quot;&quot;;</span>

<span class="fc" id="L324">		overrideContextId = null;</span>
<span class="fc" id="L325">		contextRederivationPhase = ContextRederivation.PHASE.INACTIVE;</span>

		// Set default value of MAX_UNFRAGMENTED_SIZE
<span class="fc" id="L328">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>

		//Set digest value depending on HKDF
<span class="fc" id="L331">		String digest = null;</span>
<span class="pc bpc" id="L332" title="1 of 3 branches missed.">		switch (this.kdf) {</span>
		case HKDF_HMAC_SHA_256:
<span class="fc" id="L334">			digest = &quot;SHA256&quot;;</span>
<span class="fc" id="L335">			break;</span>
		case HKDF_HMAC_SHA_512:
<span class="fc" id="L337">			digest = &quot;SHA512&quot;;</span>
<span class="fc" id="L338">			break;</span>
		case HKDF_HMAC_AES_128:
		case HKDF_HMAC_AES_256:
		default:
<span class="nc" id="L342">			LOGGER.error(&quot;Requested HKDF algorithm is not supported: &quot; + this.kdf.toString());</span>
<span class="nc" id="L343">			throw new OSException(&quot;HKDF algorithm not supported&quot;);</span>
		}

		// Derive sender_key
<span class="fc" id="L347">		CBORObject info = CBORObject.NewArray();</span>
<span class="fc" id="L348">		info.Add(this.sender_id);</span>
<span class="fc" id="L349">		info.Add(this.context_id);</span>
<span class="fc" id="L350">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L351">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L352">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L355">			this.sender_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L356">					info.EncodeToBytes());</span>
<span class="nc" id="L357">		} catch (CoseException e) {</span>
<span class="nc" id="L358">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L359">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L360">		}</span>

		// Derive recipient_key
<span class="fc" id="L363">		info = CBORObject.NewArray();</span>
<span class="fc" id="L364">		info.Add(this.recipient_id);</span>
<span class="fc" id="L365">		info.Add(this.context_id);</span>
<span class="fc" id="L366">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L367">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L368">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L371">			this.recipient_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L372">					info.EncodeToBytes());</span>
<span class="nc" id="L373">		} catch (CoseException e) {</span>
<span class="nc" id="L374">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L375">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L376">		}</span>

		// Derive common_iv
<span class="fc" id="L379">		info = CBORObject.NewArray();</span>
<span class="fc" id="L380">		info.Add(Bytes.EMPTY);</span>
<span class="fc" id="L381">		info.Add(this.context_id);</span>
<span class="fc" id="L382">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L383">		info.Add(CBORObject.FromObject(&quot;IV&quot;));</span>
<span class="fc" id="L384">		info.Add(this.iv_length);</span>

		try {
<span class="fc" id="L387">			this.common_iv = deriveKey(this.common_master_secret, this.common_master_salt, this.iv_length, digest,</span>
<span class="fc" id="L388">					info.EncodeToBytes());</span>
<span class="nc" id="L389">		} catch (CoseException e) {</span>
<span class="nc" id="L390">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L391">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L392">		}</span>

		// Initialize cipher object
<span class="fc" id="L395">		initializeCipher(common_alg);</span>

		// Attempt to restore SSN from previous execution (Appendix B.1)
<span class="fc" id="L398">		this.useAppB1 = appB1Enabled;</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">		if (useAppB1) {</span>
<span class="nc" id="L400">			int resumeSsn = readSsn();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			if (resumeSsn != -1) {</span>
<span class="nc" id="L402">				this.sender_seq = resumeSsn;</span>
<span class="nc" id="L403">				writeSsn();</span>
<span class="nc" id="L404">				System.out.println(&quot;Resuming from SSN: &quot; + resumeSsn);</span>
			}
		}
<span class="fc" id="L407">	}</span>

	/**
	 * Overrides hasCode to provide a functional implementation for this class.
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L414">		return 31 * Arrays.hashCode(sender_id) + Arrays.hashCode(recipient_id);</span>
	}

	/**
	 * Overrides equals to provide a functional implementation for this class.
	 */
	@Override
	public boolean equals(Object o) {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">		if (!(o instanceof OSCoreCtx)) {</span>
<span class="nc" id="L423">			return false;</span>
		}
<span class="fc" id="L425">		OSCoreCtx other = (OSCoreCtx) o;</span>

<span class="pc bpc" id="L427" title="2 of 4 branches missed.">		return Arrays.equals(other.sender_id, sender_id) &amp;&amp; Arrays.equals(other.recipient_id, recipient_id);</span>
	}

	/**
	 * @return the sender key
	 */
	public byte[] getSenderKey() {
<span class="fc" id="L434">		return sender_key;</span>
	}

	/**
	 * @return the recipient key
	 */
	public byte[] getRecipientKey() {
<span class="fc" id="L441">		return recipient_key;</span>
	}

	/**
	 * @return the encryption algorithm
	 */
	public AlgorithmID getAlg() {
<span class="fc" id="L448">		return this.common_alg;</span>
	}

	/**
	 * @return the sender sequence number
	 */
	public synchronized int getSenderSeq() {
<span class="fc" id="L455">		return sender_seq;</span>
	}

	/**
	 * @return the receiver sequence number
	 */
	public synchronized int getReceiverSeq() {
<span class="fc" id="L462">		return recipient_seq;</span>
	}

	/**
	 * @return the tag of the last block processed with this context
	 */
	public byte[] getLastBlockTag() {
<span class="nc" id="L469">		return last_block_tag;</span>
	}

	/**
	 * @return the sender's identifier
	 */
	public byte[] getSenderId() {
<span class="fc" id="L476">		return sender_id;</span>
	}

	/**
	 * @return the repipient's identifier
	 */
	public byte[] getRecipientId() {
<span class="fc" id="L483">		return recipient_id;</span>
	}

	/**
	 * @return the common_iv
	 */
	public byte[] getCommonIV() {
<span class="fc" id="L490">		return common_iv;</span>
	}

	/**
	 * @return the set length of IV:s
	 */
	public int getIVLength() {
<span class="fc" id="L497">		return iv_length;</span>
	}

	/**
	 * @return size of recipient replay window
	 */
	public int getRecipientReplaySize() {
<span class="fc" id="L504">		return recipient_replay_window_size;</span>
	}

	/**
	 * @return recipient replay window
	 */
	public int getRecipientReplayWindow() {
<span class="fc" id="L511">		return recipient_replay_window;</span>
	}

	public byte[] getMasterSecret() {
<span class="fc" id="L515">		return common_master_secret;</span>
	}

	public byte[] getSalt() {
<span class="fc" id="L519">		return common_master_salt;</span>
	}

	public AlgorithmID getKdf() {
<span class="fc" id="L523">		return kdf;</span>
	}
	
	/**
	 * Enables getting the ID Context
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getIdContext() {
<span class="fc" id="L532">		return context_id;</span>
	}

	/**
	 * Enables getting the ID Context to put in an outgoing message.
	 *
	 * Typically this will be the Context ID this context was generated with but
	 * it may be different when performing the context re-derivation procedure.
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getMessageIdContext() {
<span class="fc bfc" id="L544" title="All 2 branches covered.">		if (overrideContextId != null) {</span>
<span class="fc" id="L545">			return overrideContextId;</span>
		} else {
<span class="fc" id="L547">			return context_id;</span>
		}
	}

	/**
	 * Get the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 *
	 * @return the includeContextId
	 */
	public boolean getIncludeContextId() {
<span class="fc" id="L558">		return includeContextId;</span>
	}

	/**
	 * Set the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 * 
	 * Note that this flag should never be set to true in a context without a Context ID set.
	 *
	 * @param includeContextId the includeContextId to set
	 *
	 * @throws IllegalStateException if a Context ID has not been set for this context
	 */
	public void setIncludeContextId(boolean includeContextId) {
<span class="pc bpc" id="L572" title="3 of 4 branches missed.">		if (context_id == null &amp;&amp; overrideContextId == null) {</span>
<span class="nc" id="L573">			LOGGER.error(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
<span class="nc" id="L574">			throw new IllegalStateException(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
		}
		
		// If Context ID is not to be included clear the overriding Context ID
		// possibly set to be included in messages
<span class="fc bfc" id="L579" title="All 2 branches covered.">		if (!includeContextId) {</span>
<span class="fc" id="L580">			this.overrideContextId = null;</span>
		}

<span class="fc" id="L583">		this.includeContextId = includeContextId;</span>
<span class="fc" id="L584">	}</span>

	/**
	 * Indicate as a parameter exactly what Context ID should be included.
	 * Normally that would be the Context ID this context was generated with but
	 * that is not the case for the context re-derivation procedure.
	 * 
	 * @param overrideContextId the Context ID to include in messages
	 */
	public void setIncludeContextId(byte[] overrideContextId) {
<span class="fc" id="L594">		this.overrideContextId = overrideContextId.clone();</span>
<span class="fc" id="L595">		this.setIncludeContextId(true);</span>
<span class="fc" id="L596">	}</span>

	/**
	 * Get the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @return the responsesIncludePartialIV
	 */
	public boolean getResponsesIncludePartialIV() {
<span class="fc" id="L605">		return responsesIncludePartialIV;</span>
	}

	/**
	 * Set the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @param responsesIncludePartialIV the responsesIncludePartialIV to set
	 */
	public void setResponsesIncludePartialIV(boolean responsesIncludePartialIV) {
<span class="fc" id="L615">		this.responsesIncludePartialIV = responsesIncludePartialIV;</span>
<span class="fc" id="L616">	}</span>

	/**
	 * Get the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @return the contextRederivationEnabled
	 */
	public boolean getContextRederivationEnabled() {
<span class="fc" id="L625">		return contextRederivationEnabled;</span>
	}

	/**
	 * Set the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @param contextRederivationEnabled the contextRederivationEnabled to set
	 */
	public void setContextRederivationEnabled(boolean contextRederivationEnabled) {
<span class="fc" id="L635">		this.contextRederivationEnabled = contextRederivationEnabled;</span>
<span class="fc" id="L636">	}</span>

	/**
	 * Gets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @return the current value of MAX_UNFRAGMENTED_SIZE
	 */
	public int getMaxUnfragmentedSize() {
<span class="fc" id="L645">		return maxUnfragmentedSize;</span>
	}

	/**
	 * Sets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @param maxUnfragmentedSize the desired value of MAX_UNFRAGMENTED_SIZE
	 */
	public void setMaxUnfragmentedSize(int maxUnfragmentedSize) {
<span class="fc" id="L655">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>
<span class="fc" id="L656">	}</span>

	/**
	 * Get a string representation of the context ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the contextIdString
	 */
	public String getContextIdString() {
<span class="fc" id="L665">		return contextIdString;</span>
	}

	/**
	 * Get a string representation of the sender ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the senderIdString
	 */
	public String getSenderIdString() {
<span class="fc" id="L675">		return senderIdString;</span>
	}

	/**
	 * Get a string representation of the recipient ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the recipientIdString
	 */
	public String getRecipientIdString() {
<span class="fc" id="L685">		return recipientIdString;</span>
	}

    public int rollbackRecipientSeq() {
<span class="nc" id="L689">		return rollback_recipient_seq;</span>
	}

	public int rollbackRecipientReplay() {
<span class="nc" id="L693">		return rollback_recipient_replay;</span>
	}

	/**
	 * @param seq the sender sequence number to set
	 */
	public synchronized void setSenderSeq(int seq) {
<span class="fc" id="L700">		sender_seq = seq;</span>
<span class="fc" id="L701">	}</span>

	/**
	 * @param seq the recipient sequence number to set
	 */
	public synchronized void setReceiverSeq(int seq) {
<span class="fc" id="L707">		recipient_seq = seq;</span>
<span class="fc" id="L708">	}</span>

	/**
	 * Save the tag of the last processed block
	 * 
	 * @param tag the tag
	 */
	public void setLastBlockTag(byte[] tag) {
<span class="nc" id="L716">		last_block_tag = tag.clone();</span>
<span class="nc" id="L717">	}</span>

	/**
	 * Enables setting the sender key
	 * 
	 * @param senderKey the sender key to set
	 */
	public void setSenderKey(byte[] senderKey) {
<span class="fc" id="L725">		this.sender_key = senderKey.clone();</span>
<span class="fc" id="L726">	}</span>
	
	/**
	 * Enables setting the recipient key
	 * 
	 * @param recipientKey the recipient key to set
	 */
	public void setRecipientKey(byte[] recipientKey) {
<span class="nc" id="L734">		this.recipient_key = recipientKey.clone();</span>
<span class="nc" id="L735">	}</span>
	
	/**
	 * Set the maximum sequence number.
	 * 
	 * @param seqMax the maximum sequence number.
	 */
	public void setSeqMax(int seqMax) {
<span class="fc" id="L743">		this.seqMax = seqMax;</span>
<span class="fc" id="L744">	}</span>

	/**
	 * Sets the valid lengths, in bytes, of constrained variables(ids, IVs and
	 * keys).
	 * 
	 * @throws RuntimeException if not this.common_alg has been initiated
	 */
	private void setLengths() {
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">		if (common_alg != null) {</span>

<span class="fc" id="L755">			iv_length = EncryptCommon.ivLength(common_alg);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">			if (iv_length &gt; 0) {</span>
<span class="fc" id="L757">				id_length = iv_length - 6; // RFC section 5.2</span>
<span class="fc" id="L758">				key_length = common_alg.getKeySize() / 8;</span>

			} else {
<span class="fc" id="L761">				LOGGER.error(&quot;Unable to set lengths, since algorithm&quot;);</span>
<span class="fc" id="L762">				throw new RuntimeException(&quot;Unable to set lengths, since algorithm&quot;);</span>
			}

		} else {
<span class="nc" id="L766">			LOGGER.error(&quot;Common_alg has not yet been initiated.&quot;);</span>
<span class="nc" id="L767">			throw new RuntimeException(&quot;Common_alg has not yet been initiated.&quot;);</span>
		}
<span class="fc" id="L769">	}</span>

	/**
	 * @return the URI this context is associated with if any.
	 */
	public String getUri() {
<span class="fc" id="L775">		return uri;</span>
	}

	/**
	 * Sets the URI this context is associated with.
	 * (The URI it is saved under in the HashMapCtxDB.)
	 *
	 * This will be set when added to the HashMapCtxDB.
	 *
	 * @param uri the URI this OSCORE context is associated with
	 */
	protected void setUri(String uri) {
<span class="fc" id="L787">		this.uri = uri;</span>
<span class="fc" id="L788">	}</span>

	/**
	 * Get the context re-derivation key.
	 * 
	 * @return the context re-derivation key
	 */
	protected byte[] getContextRederivationKey() {
<span class="fc" id="L796">		return contextRederivationKey;</span>
	}

	/**
	 * Sets the context re-derivation key.
	 * 
	 * @param contextRederivationKey the context re-derivation key to set
	 */
	protected void setContextRederivationKey(byte[] contextRederivationKey) {
<span class="fc" id="L805">		this.contextRederivationKey = contextRederivationKey;</span>
<span class="fc" id="L806">	}</span>

	/**
	 * Check the phase of the context re-derivation process.
	 * 
	 * @return the contextRederivationOngoing
	 */
	public ContextRederivation.PHASE getContextRederivationPhase() {
<span class="fc" id="L814">		return contextRederivationPhase;</span>
	}

	/**
	 * Set the phase of the context re-derivation process.
	 * 
	 * @param contextRederivationPhase the contextRederivationPhase to set
	 */
	public void setContextRederivationPhase(ContextRederivation.PHASE contextRederivationPhase) {
<span class="fc" id="L823">		this.contextRederivationPhase = contextRederivationPhase;</span>
<span class="fc" id="L824">	}</span>

	/**
	 * Increase the sender's sequence number by one
	 *
	 * @throws OSException if the sequence number wraps
	 */
	public synchronized void increaseSenderSeq() throws OSException {
<span class="fc bfc" id="L832" title="All 2 branches covered.">		if (sender_seq &gt;= seqMax) {</span>
<span class="fc" id="L833">			LOGGER.error(&quot;Sequence number wrapped, get a new OSCore context&quot;);</span>
<span class="fc" id="L834">			throw new OSException(&quot;Sequence number wrapped&quot;);</span>
		}

<span class="pc bpc" id="L837" title="3 of 4 branches missed.">		if (useAppB1 &amp;&amp; sender_seq % K == 0) {</span>
<span class="nc" id="L838">			writeSsn();</span>
		}

<span class="fc" id="L841">		sender_seq++;</span>
<span class="fc" id="L842">	}</span>

	// TODO: For interop testing
<span class="fc" id="L845">	public static boolean DISABLE_REPLAY_CHECKS = false;</span>


	/**
	 * Checks and sets the sequence number for incoming messages.
	 * 
	 * @param seq the incoming sequence number
	 * 
	 * @throws OSException if the sequence number wraps or if it is a replay
	 */
	public synchronized void checkIncomingSeq(int seq) throws OSException {

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">		if(DISABLE_REPLAY_CHECKS) {</span>
<span class="nc" id="L858">			return;</span>
		}
		
<span class="fc bfc" id="L861" title="All 2 branches covered.">		if (seq &gt;= seqMax) {</span>
<span class="fc" id="L862">			LOGGER.error(&quot;Sequence number wrapped, get new OSCore context&quot;);</span>
<span class="fc" id="L863">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="pc bpc" id="L866" title="1 of 2 branches missed.">		if (seq &lt; internal_recipient_seq) {</span>
<span class="nc" id="L867">			LOGGER.error(&quot;Message too old&quot;);</span>
<span class="nc" id="L868">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="fc bfc" id="L871" title="All 2 branches covered.">		boolean valid = ((recipient_replay_window &gt;&gt; (seq - internal_recipient_seq)) &amp; 1) == 0;</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">		if (!valid) {</span>
<span class="fc" id="L873">			LOGGER.error(&quot;Replayed message detected&quot;);</span>
<span class="fc" id="L874">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="fc" id="L877">		recipient_seq = seq;</span>
		// Update window
<span class="fc" id="L879">		int shift = seq - (internal_recipient_seq + recipient_replay_window_size - 1);</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">		if (shift &gt; 0) {</span>
<span class="nc" id="L881">			recipient_replay_window &gt;&gt;= shift;</span>
<span class="nc" id="L882">			internal_recipient_seq += shift;</span>
		}
<span class="fc" id="L884">		recipient_replay_window |= 1 &lt;&lt; (seq - internal_recipient_seq);</span>
<span class="fc" id="L885">	}</span>

	/**
	 * Rolls back the latest recipient sequence number update if any
	 */
	public synchronized void rollBack() {
<span class="nc bnc" id="L891" title="All 2 branches missed.">		if (rollback_recipient_replay != -1) {</span>
<span class="nc" id="L892">			recipient_replay_window = rollback_recipient_replay;</span>
<span class="nc" id="L893">			rollback_recipient_replay = -1;</span>
		}
<span class="nc bnc" id="L895" title="All 2 branches missed.">		if (rollback_recipient_seq != -1) {</span>
<span class="nc" id="L896">			recipient_seq = rollback_recipient_seq;</span>
<span class="nc" id="L897">			rollback_recipient_seq = -1;</span>
		}
<span class="nc bnc" id="L899" title="All 2 branches missed.">		if (this.rollback_last_block_tag != null) {</span>
<span class="nc" id="L900">			this.last_block_tag = this.rollback_last_block_tag;</span>
<span class="nc" id="L901">			this.rollback_last_block_tag = null;</span>
		}
<span class="nc" id="L903">	}</span>

	public static byte[] deriveKey(byte[] secret, byte[] salt, int cbitKey, String digest, byte[] rgbContext)
			throws CoseException {

<span class="fc" id="L908">		final String HMAC_ALG_NAME = &quot;Hmac&quot; + digest;</span>

		try {
<span class="fc" id="L911">			Mac hmac = Mac.getInstance(HMAC_ALG_NAME);</span>
<span class="fc" id="L912">			int hashLen = hmac.getMacLength();</span>

			// Perform extract
<span class="fc" id="L915">			hmac.init(new SecretKeySpec(salt, HMAC_ALG_NAME));</span>
<span class="fc" id="L916">			byte[] rgbExtract = hmac.doFinal(secret);</span>

			// Perform expand
<span class="fc" id="L919">			hmac.init(new SecretKeySpec(rgbExtract, HMAC_ALG_NAME));</span>
<span class="fc" id="L920">			int c = (cbitKey / hashLen) + 1;</span>
<span class="fc" id="L921">			byte[] rgbOut = new byte[cbitKey];</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">			int maxLen = (hashLen * c &gt; cbitKey) ? hashLen * c : cbitKey;</span>
<span class="fc" id="L923">			byte[] T = new byte[maxLen];</span>
<span class="fc" id="L924">			byte[] last = new byte[0];</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">			for (int i = 0; i &lt; c; i++) {</span>
<span class="fc" id="L926">				hmac.reset();</span>
<span class="fc" id="L927">				hmac.update(last);</span>
<span class="fc" id="L928">				hmac.update(rgbContext);</span>
<span class="fc" id="L929">				hmac.update((byte) (i + 1));</span>
<span class="fc" id="L930">				last = hmac.doFinal();</span>
<span class="fc" id="L931">				System.arraycopy(last, 0, T, i * hashLen, hashLen);</span>
			}
<span class="fc" id="L933">			System.arraycopy(T, 0, rgbOut, 0, cbitKey);</span>
<span class="fc" id="L934">			return rgbOut;</span>
<span class="nc" id="L935">		} catch (NoSuchAlgorithmException | InvalidKeyException ex) {</span>
<span class="nc" id="L936">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L937">		} catch (Exception ex) {</span>
<span class="nc" id="L938">			throw new CoseException(&quot;Derivation failure&quot;, ex);</span>
		}
	}

	/**
	 * Converts a byte array to a hexadecimal string representation.
	 *
	 * @param bytes the byte array to convert
	 * @return the string representation
	 */
	private String toHex(byte[] bytes) {
<span class="fc bfc" id="L949" title="All 4 branches covered.">		if(bytes == null || bytes.length == 0) {</span>
<span class="fc" id="L950">			return &quot;&quot;;</span>
		} else {
<span class="fc" id="L952">			return StringUtil.byteArray2Hex(bytes);</span>
		}
	}

	/**
	 * Returns this CoAPCode.
	 * 
	 * @return the coap code
	 */
	public Code getCoAPCode() {
<span class="fc" id="L962">		return CoAPCode;</span>
	}

	/**
	 * Sets this CoAPCode to CoAPCode
	 * 
	 * @param coapCode coap code.
	 */
	public void setCoAPCode(Code coapCode) {
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">		if (coapCode != null) {</span>
<span class="fc" id="L972">			this.CoAPCode = coapCode;</span>
		}
<span class="fc" id="L974">	}</span>

	/**
	 * Initializes the cipher object by calling CCMBlockCipher.encrypt with
	 * dummy data. Doing this at creation of the OSCORE context reduces the
	 * latency for the first request since it would otherwise happen then.
	 * 
	 * @param alg the encryption algorithm used
	 */
	private void initializeCipher(AlgorithmID alg) {
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">		switch (alg) {</span>
		case AES_CCM_16_64_128:
		case AES_CCM_16_128_128:
		case AES_CCM_64_64_128:
		case AES_CCM_64_128_128:

<span class="fc" id="L990">			byte[] key = { (byte) 0xEB, (byte) 0xDE, (byte) 0xBC, (byte) 0x51, (byte) 0xF1, (byte) 0x03,</span>
					(byte) 0x79, (byte) 0x14, (byte) 0x14, (byte) 0x4F, (byte) 0xC3, (byte) 0xAC, (byte) 0x40,
					(byte) 0x14, (byte) 0xD2, (byte) 0x4C };
<span class="fc" id="L993">			byte[] nonce = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };</span>

			try {
<span class="fc" id="L996">				CCMBlockCipher.encrypt(new SecretKeySpec(key, &quot;AES&quot;), nonce, Bytes.EMPTY,</span>
						Bytes.EMPTY, 0);
<span class="nc" id="L998">			} catch (GeneralSecurityException e) {</span>
<span class="nc" id="L999">				LOGGER.error(&quot;Failed to initialize cipher.&quot;);</span>
<span class="nc" id="L1000">				throw new RuntimeException(&quot;Failed to initialize cipher.&quot;);</span>
<span class="fc" id="L1001">			}</span>

			break;

		default:
			break;
		}
<span class="fc" id="L1008">	}</span>

	/**
	 * Create byte array from values.
	 * 
	 * @param values bytes for byte array
	 * @return initialized byte array
	 */
	private static byte[] createByteArray(byte... values) {
<span class="fc" id="L1017">		return values;</span>
	}

	/**
	 * Provides a method to check if this context is used for Group OSCORE.
	 * 
	 * @return if this is a group (Group OSCORE) context
	 */
	public boolean isGroupContext() {
<span class="fc bfc" id="L1026" title="All 4 branches covered.">		return this instanceof GroupSenderCtx || this instanceof GroupRecipientCtx;</span>
	}

	// TODO: Remove?
	protected GroupSenderCtx getSenderCtx() {
<span class="nc" id="L1031">		return null;</span>
	}

	/**
	 * Save SSN for resumption (Appendix B.1)
	 */
	private void writeSsn() {

<span class="nc" id="L1039">		String fileName = getSsnFilePath();</span>

		// Create file and folder if it does not exist
<span class="nc" id="L1042">		File targetFile = new File(fileName);</span>
<span class="nc" id="L1043">		File parent = targetFile.getParentFile();</span>
<span class="nc" id="L1044">		parent.mkdirs();</span>

		// Write file content
<span class="nc bnc" id="L1047" title="All 2 branches missed.">		if (fileName != null) {</span>
<span class="nc" id="L1048">			try (PrintWriter writer = new PrintWriter(fileName, &quot;UTF-8&quot;)) {</span>
<span class="nc" id="L1049">				writer.println(String.valueOf(sender_seq));</span>
<span class="nc" id="L1050">				writer.close();</span>
<span class="nc" id="L1051">			} catch (FileNotFoundException | UnsupportedEncodingException e) {</span>
				// Failed to write SSN for resumption
<span class="nc" id="L1053">			}</span>
		}

<span class="nc" id="L1056">	}</span>

	/**
	 * Control the usage of Appendix B.1
	 * 
	 */
	private final boolean useAppB1;

	/**
	 * Get filename to use for writing/reading SSN for resumption (Appendix B.1)
	 * 
	 * @return the path to the SSN file
	 */
	private String getSsnFilePath() {

		// Build unique filename to use
<span class="nc" id="L1072">		String jarFile = System.getProperty(&quot;java.class.path&quot;);</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">		if (jarFile.length() &gt; 4) {</span>
<span class="nc" id="L1074">			jarFile = jarFile.substring(0, jarFile.length() - 4);</span>
		}

<span class="nc" id="L1077">		String recipientId = toHex(recipient_id);</span>
<span class="nc" id="L1078">		String senderId = toHex(sender_id);</span>
<span class="nc" id="L1079">		String contextId = toHex(context_id);</span>

		String fileName;
<span class="nc bnc" id="L1082" title="All 2 branches missed.">		if (jarFile.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L1083">			fileName = &quot;.&quot; + senderId + &quot;-&quot; + recipientId + &quot;-&quot; + contextId;</span>
		} else {
<span class="nc" id="L1085">			fileName = &quot;.&quot; + jarFile + &quot;-&quot; + senderId + &quot;-&quot; + recipientId + &quot;-&quot; + contextId;</span>
		}

<span class="nc" id="L1088">		return &quot;.resume/&quot; + fileName;</span>
	}

	/**
	 * Parameter K for Appendix B.1
	 */
<span class="fc" id="L1094">	private static int K = 10;</span>

	/**
	 * Parameter F for Appendix B.1
	 */
<span class="fc" id="L1099">	private static int F = 2;</span>

	/**
	 * Read SSN for resumption (Appendix B.1)
	 * 
	 * @return the SSN to resume from
	 */
	private int readSsn() {

<span class="nc" id="L1108">		String filePath = getSsnFilePath();</span>

		// Attempt to read SSN from file
<span class="nc" id="L1111">		int resumeSsn = -1;</span>

<span class="nc bnc" id="L1113" title="All 2 branches missed.">		if (filePath == null) {</span>
<span class="nc" id="L1114">			return resumeSsn;</span>
		}

<span class="nc" id="L1117">		try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {</span>
<span class="nc" id="L1118">			String line = reader.readLine();</span>
<span class="nc" id="L1119">			reader.close();</span>
<span class="nc" id="L1120">			resumeSsn = Integer.parseInt(line);</span>
<span class="nc" id="L1121">		} catch (IOException e) {</span>
			// Failed to read or parse from file
<span class="nc" id="L1123">			return resumeSsn;</span>
<span class="nc" id="L1124">		}</span>

<span class="nc" id="L1126">		return resumeSsn + K + F;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
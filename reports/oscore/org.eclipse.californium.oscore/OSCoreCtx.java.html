<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OSCoreCtx.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">OSCoreCtx.java</span></div><h1>OSCoreCtx.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2019 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.eclipse.californium.core.coap.CoAP.Code;
import org.eclipse.californium.core.config.CoapConfig;
import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.EncryptCommon;
import org.eclipse.californium.elements.config.Configuration;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.oscore.group.GroupRecipientCtx;
import org.eclipse.californium.oscore.group.GroupSenderCtx;
import org.eclipse.californium.scandium.dtls.cipher.CCMBlockCipher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.upokecenter.cbor.CBORObject;

/**
 * 
 * Represents the Security Context and its parameters. At initiation derives the
 * keys and IVs. Also maintains replay window.
 *
 */
public class OSCoreCtx {

	/**
	 * The logger
	 */
<span class="fc" id="L57">	private static final Logger LOGGER = LoggerFactory.getLogger(OSCoreCtx.class);</span>

	private static final byte ZERO = 0;
	private static final byte ONE = 1;

	private AlgorithmID common_alg;
	private byte[] common_master_secret;
	private byte[] common_master_salt;
	private byte[] common_iv;
	private byte[] context_id;

	protected byte[] sender_id;
	protected byte[] sender_key;
	protected int sender_seq;

	protected byte[] recipient_id;
	protected byte[] recipient_key;
	protected int recipient_seq;
	protected int internal_recipient_seq;
	protected int recipient_replay_window_size;
	protected int recipient_replay_window;

	private AlgorithmID kdf;

<span class="fc" id="L81">	private int rollback_recipient_seq = -1;</span>
<span class="fc" id="L82">	private int rollback_recipient_replay = -1;</span>
<span class="fc" id="L83">	private byte[] rollback_last_block_tag = null;</span>

<span class="fc" id="L85">	private byte[] last_block_tag = null;</span>
<span class="fc" id="L86">	private int seqMax = Integer.MAX_VALUE;</span>

	private int id_length;
	private int iv_length;
	private int key_length;

<span class="fc" id="L92">	private Code CoAPCode = null;</span>

	/**
	 * Include the context id in messages generated using this context. This is
	 * generally optional and can be controlled by the application.
	 *
	 * Default value is false.
	 */
	private boolean includeContextId;

	/**
	 * Generate a new partial IV for outgoing Response messages. If this
	 * variable is false the same nonce from the original request will be used.
	 * Otherwise a new partial IV will be generated by the sender and included
	 * in the Response. This affects the calculation of the nonce.
	 *
	 * See https://tools.ietf.org/html/rfc8613#section-5.2
	 *
	 * This variable will control the behaviour when sending Response messages
	 * with this context. Note that Observe notifications will always include a
	 * new partial IV.
	 *
	 * Default value is false.
	 */
	private boolean responsesIncludePartialIV;
	
	/**
	 * Indicates if this client/server shall support the context re-derivation
	 * procedure.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#appendix-B.2
	 */
	private boolean contextRederivationEnabled;

	/**
	 * When using outer block-wise with OSCORE a proxy can maliciously inject
	 * block fragments. To protect against this a message with size exceeding
	 * this parameter should never be sent without inner block-wise. Likewise
	 * when receiving a message using outer block-wise it should be discarded if
	 * the cumulated size exceeds this parameter.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#section-4.1.3.4.2
	 */
	private int maxUnfragmentedSize;

	/**
	 * URI this Context is associated with if any.
	 *
	 * That is what URI it is associated and stored under in the HashMapCtxDB.
	 */
	private String uri;

	/**
	 * String versions of the context ID, sender ID and recipient ID.
	 *
	 * These are set when the context is created (rather than for every message)
	 * to be used later when adding information about the messages to the
	 * EndpointContext on sending or receiving a message.
	 */
	private final String contextIdString;
	private final String senderIdString;
	private final String recipientIdString;

	/**
	 * Key that is used during the context re-derivation process.
	 */
	private byte[] contextRederivationKey;

	/**
	 * Makes it possible to override the Context ID to include in messages.
	 * Typically this would be the Context ID this context was generated with
	 * but that is not the case for the context re-derivation procedure.
	 */
	private byte[] overrideContextId;

	/**
	 * Indicate which phase the context re-derivation procedure is in,
	 */
	private ContextRederivation.PHASE contextRederivationPhase;

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @throws OSException if the default KDF is not supported
	 */
	public OSCoreCtx(byte[] master_secret, boolean client) throws OSException {
<span class="fc" id="L181">		this(master_secret, client, Configuration.getStandard());</span>
<span class="fc" id="L182">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @param configuration configuration to be used by this context
	 * @throws OSException if the default KDF is not supported
	 * @since 3.0
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, Configuration configuration) throws OSException {
<span class="fc" id="L195">		this(master_secret, client, null, null, null, null, null, null, null,</span>
<span class="fc" id="L196">				configuration.get(CoapConfig.MAX_RESOURCE_BODY_SIZE));</span>
<span class="fc" id="L197">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters.
	 * 
	 * @param master_secret the master secret
	 * @param alg the encryption algorithm as defined in COSE
	 * @param client is this originally the client's context
	 * @param sender_id the sender id or null for default
	 * @param recipient_id the recipient id or null for default
	 * @param kdf the COSE algorithm abbreviation of the kdf or null for the
	 *            default
	 * @param replay_size the replay window size or null for the default
	 * @param master_salt the optional master salt, can be null
	 * @param contextId the context id, can be null
	 * @param maxUnfragmentedSize maximum unfragmented size 
	 *
	 * @throws OSException if the KDF is not supported
	 * @since 3.0 (added parameter maxUnfragmentedSize)
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
<span class="fc" id="L218">			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, int maxUnfragmentedSize) throws OSException {</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">		if (alg == null) {</span>
<span class="fc" id="L221">			this.common_alg = AlgorithmID.AES_CCM_16_64_128;</span>
		} else {
<span class="fc" id="L223">			this.common_alg = alg;</span>
		}

<span class="fc" id="L226">		setLengths();</span>

<span class="fc" id="L228">		this.sender_seq = 0;</span>
<span class="fc" id="L229">		this.recipient_seq = -1;</span>
<span class="fc" id="L230">		this.internal_recipient_seq = 0;</span>
		
<span class="fc bfc" id="L232" title="All 2 branches covered.">		if (master_secret != null) {</span>
<span class="fc" id="L233">			this.common_master_secret = master_secret.clone();</span>
		} else {
<span class="fc" id="L235">			LOGGER.error(&quot;Input master secret is null&quot;);</span>
<span class="fc" id="L236">			throw new NullPointerException(&quot;Input master secret is null&quot;);</span>
		}
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">		if (sender_id == null || sender_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">			this.sender_id = createByteArray(client ? ZERO : ONE);</span>
		} else {
<span class="fc" id="L241">			this.sender_id = sender_id.clone();</span>
		}

<span class="pc bpc" id="L244" title="1 of 4 branches missed.">		if (recipient_id == null || recipient_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			this.recipient_id = createByteArray(client ? ONE : ZERO);</span>
		} else {
<span class="fc" id="L247">			this.recipient_id = recipient_id.clone();</span>
		}

<span class="fc bfc" id="L250" title="All 2 branches covered.">		if (kdf == null) {</span>
<span class="fc" id="L251">			this.kdf = AlgorithmID.HKDF_HMAC_SHA_256;</span>
		} else {
<span class="fc" id="L253">			this.kdf = kdf;</span>
		}

<span class="fc bfc" id="L256" title="All 2 branches covered.">		if (replay_size == null) {</span>
<span class="fc" id="L257">			this.recipient_replay_window_size = 32;</span>
		} else {
<span class="fc" id="L259">			this.recipient_replay_window_size = replay_size.intValue();</span>
		}
<span class="fc" id="L261">		this.recipient_replay_window = 0;</span>

<span class="fc bfc" id="L263" title="All 2 branches covered.">		if (master_salt == null) {</span>
			// Default value. Automatically initialized with 0-es.
<span class="fc" id="L265">			this.common_master_salt = new byte[this.kdf.getKeySize() / Byte.SIZE];</span>
		} else {
<span class="fc" id="L267">			this.common_master_salt = master_salt.clone();</span>
		}

<span class="fc bfc" id="L270" title="All 2 branches covered.">		if (contextId != null) {</span>
<span class="fc" id="L271">			this.context_id = contextId.clone();</span>
		} else {
<span class="fc" id="L273">			this.context_id = null;</span>
		}

		// Set default values for these flags
		//They can be set by the application using their setters
<span class="fc" id="L278">		includeContextId = false;</span>
<span class="fc" id="L279">		responsesIncludePartialIV = false;</span>
<span class="fc" id="L280">		contextRederivationEnabled = false;</span>

		//Set string versions of sender ID, recipient ID and Context ID
<span class="fc" id="L283">		contextIdString = toHex(this.context_id);</span>
<span class="fc" id="L284">		senderIdString = toHex(this.sender_id);</span>
<span class="fc" id="L285">		recipientIdString = toHex(this.recipient_id);</span>

		//Initialize the URI associated with the context
		//It will be overwritten if this context is added to a HashMapCtxDB
<span class="fc" id="L289">		uri = &quot;&quot;;</span>

<span class="fc" id="L291">		overrideContextId = null;</span>
<span class="fc" id="L292">		contextRederivationPhase = ContextRederivation.PHASE.INACTIVE;</span>

		// Set default value of MAX_UNFRAGMENTED_SIZE
<span class="fc" id="L295">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>

		//Set digest value depending on HKDF
<span class="fc" id="L298">		String digest = null;</span>
<span class="pc bpc" id="L299" title="1 of 3 branches missed.">		switch (this.kdf) {</span>
		case HKDF_HMAC_SHA_256:
<span class="fc" id="L301">			digest = &quot;SHA256&quot;;</span>
<span class="fc" id="L302">			break;</span>
		case HKDF_HMAC_SHA_512:
<span class="fc" id="L304">			digest = &quot;SHA512&quot;;</span>
<span class="fc" id="L305">			break;</span>
		case HKDF_HMAC_AES_128:
		case HKDF_HMAC_AES_256:
		default:
<span class="nc" id="L309">			LOGGER.error(&quot;Requested HKDF algorithm is not supported: &quot; + this.kdf.toString());</span>
<span class="nc" id="L310">			throw new OSException(&quot;HKDF algorithm not supported&quot;);</span>
		}

		// Derive sender_key
<span class="fc" id="L314">		CBORObject info = CBORObject.NewArray();</span>
<span class="fc" id="L315">		info.Add(this.sender_id);</span>
<span class="fc" id="L316">		info.Add(this.context_id);</span>
<span class="fc" id="L317">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L318">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L319">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L322">			this.sender_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L323">					info.EncodeToBytes());</span>
<span class="nc" id="L324">		} catch (CoseException e) {</span>
<span class="nc" id="L325">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L326">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L327">		}</span>

		// Derive recipient_key
<span class="fc" id="L330">		info = CBORObject.NewArray();</span>
<span class="fc" id="L331">		info.Add(this.recipient_id);</span>
<span class="fc" id="L332">		info.Add(this.context_id);</span>
<span class="fc" id="L333">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L334">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L335">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L338">			this.recipient_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L339">					info.EncodeToBytes());</span>
<span class="nc" id="L340">		} catch (CoseException e) {</span>
<span class="nc" id="L341">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L342">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L343">		}</span>

		// Derive common_iv
<span class="fc" id="L346">		info = CBORObject.NewArray();</span>
<span class="fc" id="L347">		info.Add(Bytes.EMPTY);</span>
<span class="fc" id="L348">		info.Add(this.context_id);</span>
<span class="fc" id="L349">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L350">		info.Add(CBORObject.FromObject(&quot;IV&quot;));</span>
<span class="fc" id="L351">		info.Add(this.iv_length);</span>

		try {
<span class="fc" id="L354">			this.common_iv = deriveKey(this.common_master_secret, this.common_master_salt, this.iv_length, digest,</span>
<span class="fc" id="L355">					info.EncodeToBytes());</span>
<span class="nc" id="L356">		} catch (CoseException e) {</span>
<span class="nc" id="L357">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L358">			throw new OSException(e.getMessage());</span>
<span class="fc" id="L359">		}</span>

		// Initialize cipher object
<span class="fc" id="L362">		initializeCipher(common_alg);</span>

<span class="fc" id="L364">	}</span>

	/**
	 * Overrides hasCode to provide a functional implementation for this class.
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L371">		return 31 * Arrays.hashCode(sender_id) + Arrays.hashCode(recipient_id);</span>
	}

	/**
	 * Overrides equals to provide a functional implementation for this class.
	 */
	@Override
	public boolean equals(Object o) {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (!(o instanceof OSCoreCtx)) {</span>
<span class="nc" id="L380">			return false;</span>
		}
<span class="fc" id="L382">		OSCoreCtx other = (OSCoreCtx) o;</span>

<span class="pc bpc" id="L384" title="2 of 4 branches missed.">		return Arrays.equals(other.sender_id, sender_id) &amp;&amp; Arrays.equals(other.recipient_id, recipient_id);</span>
	}

	/**
	 * @return the sender key
	 */
	public byte[] getSenderKey() {
<span class="fc" id="L391">		return sender_key;</span>
	}

	/**
	 * @return the recipient key
	 */
	public byte[] getRecipientKey() {
<span class="fc" id="L398">		return recipient_key;</span>
	}

	/**
	 * @return the encryption algorithm
	 */
	public AlgorithmID getAlg() {
<span class="fc" id="L405">		return this.common_alg;</span>
	}

	/**
	 * @return the sender sequence number
	 */
	public synchronized int getSenderSeq() {
<span class="fc" id="L412">		return sender_seq;</span>
	}

	/**
	 * @return the receiver sequence number
	 */
	public synchronized int getReceiverSeq() {
<span class="fc" id="L419">		return recipient_seq;</span>
	}

	/**
	 * @return the tag of the last block processed with this context
	 */
	public byte[] getLastBlockTag() {
<span class="nc" id="L426">		return last_block_tag;</span>
	}

	/**
	 * @return the sender's identifier
	 */
	public byte[] getSenderId() {
<span class="fc" id="L433">		return sender_id;</span>
	}

	/**
	 * @return the repipient's identifier
	 */
	public byte[] getRecipientId() {
<span class="fc" id="L440">		return recipient_id;</span>
	}

	/**
	 * @return the common_iv
	 */
	public byte[] getCommonIV() {
<span class="fc" id="L447">		return common_iv;</span>
	}

	/**
	 * @return the set length of IV:s
	 */
	public int getIVLength() {
<span class="fc" id="L454">		return iv_length;</span>
	}

	/**
	 * @return size of recipient replay window
	 */
	public int getRecipientReplaySize() {
<span class="fc" id="L461">		return recipient_replay_window_size;</span>
	}

	/**
	 * @return recipient replay window
	 */
	public int getRecipientReplayWindow() {
<span class="fc" id="L468">		return recipient_replay_window;</span>
	}

	public byte[] getMasterSecret() {
<span class="fc" id="L472">		return common_master_secret;</span>
	}

	public byte[] getSalt() {
<span class="fc" id="L476">		return common_master_salt;</span>
	}

	public AlgorithmID getKdf() {
<span class="fc" id="L480">		return kdf;</span>
	}
	
	/**
	 * Enables getting the ID Context
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getIdContext() {
<span class="fc" id="L489">		return context_id;</span>
	}

	/**
	 * Enables getting the ID Context to put in an outgoing message.
	 *
	 * Typically this will be the Context ID this context was generated with but
	 * it may be different when performing the context re-derivation procedure.
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getMessageIdContext() {
<span class="fc bfc" id="L501" title="All 2 branches covered.">		if (overrideContextId != null) {</span>
<span class="fc" id="L502">			return overrideContextId;</span>
		} else {
<span class="fc" id="L504">			return context_id;</span>
		}
	}

	/**
	 * Get the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 *
	 * @return the includeContextId
	 */
	public boolean getIncludeContextId() {
<span class="fc" id="L515">		return includeContextId;</span>
	}

	/**
	 * Set the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 * 
	 * Note that this flag should never be set to true in a context without a Context ID set.
	 *
	 * @param includeContextId the includeContextId to set
	 *
	 * @throws IllegalStateException if a Context ID has not been set for this context
	 */
	public void setIncludeContextId(boolean includeContextId) {
<span class="pc bpc" id="L529" title="3 of 4 branches missed.">		if (context_id == null &amp;&amp; overrideContextId == null) {</span>
<span class="nc" id="L530">			LOGGER.error(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
<span class="nc" id="L531">			throw new IllegalStateException(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
		}
		
		// If Context ID is not to be included clear the overriding Context ID
		// possibly set to be included in messages
<span class="fc bfc" id="L536" title="All 2 branches covered.">		if (!includeContextId) {</span>
<span class="fc" id="L537">			this.overrideContextId = null;</span>
		}

<span class="fc" id="L540">		this.includeContextId = includeContextId;</span>
<span class="fc" id="L541">	}</span>

	/**
	 * Indicate as a parameter exactly what Context ID should be included.
	 * Normally that would be the Context ID this context was generated with but
	 * that is not the case for the context re-derivation procedure.
	 * 
	 * @param overrideContextId the Context ID to include in messages
	 */
	public void setIncludeContextId(byte[] overrideContextId) {
<span class="fc" id="L551">		this.overrideContextId = overrideContextId.clone();</span>
<span class="fc" id="L552">		this.setIncludeContextId(true);</span>
<span class="fc" id="L553">	}</span>

	/**
	 * Get the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @return the responsesIncludePartialIV
	 */
	public boolean getResponsesIncludePartialIV() {
<span class="fc" id="L562">		return responsesIncludePartialIV;</span>
	}

	/**
	 * Set the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @param responsesIncludePartialIV the responsesIncludePartialIV to set
	 */
	public void setResponsesIncludePartialIV(boolean responsesIncludePartialIV) {
<span class="fc" id="L572">		this.responsesIncludePartialIV = responsesIncludePartialIV;</span>
<span class="fc" id="L573">	}</span>

	/**
	 * Get the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @return the contextRederivationEnabled
	 */
	public boolean getContextRederivationEnabled() {
<span class="fc" id="L582">		return contextRederivationEnabled;</span>
	}

	/**
	 * Set the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @param contextRederivationEnabled the contextRederivationEnabled to set
	 */
	public void setContextRederivationEnabled(boolean contextRederivationEnabled) {
<span class="fc" id="L592">		this.contextRederivationEnabled = contextRederivationEnabled;</span>
<span class="fc" id="L593">	}</span>

	/**
	 * Gets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @return the current value of MAX_UNFRAGMENTED_SIZE
	 */
	public int getMaxUnfragmentedSize() {
<span class="fc" id="L602">		return maxUnfragmentedSize;</span>
	}

	/**
	 * Sets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @param maxUnfragmentedSize the desired value of MAX_UNFRAGMENTED_SIZE
	 */
	public void setMaxUnfragmentedSize(int maxUnfragmentedSize) {
<span class="fc" id="L612">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>
<span class="fc" id="L613">	}</span>

	/**
	 * Get a string representation of the context ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the contextIdString
	 */
	public String getContextIdString() {
<span class="fc" id="L622">		return contextIdString;</span>
	}

	/**
	 * Get a string representation of the sender ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the senderIdString
	 */
	public String getSenderIdString() {
<span class="fc" id="L632">		return senderIdString;</span>
	}

	/**
	 * Get a string representation of the recipient ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the recipientIdString
	 */
	public String getRecipientIdString() {
<span class="fc" id="L642">		return recipientIdString;</span>
	}

    public int rollbackRecipientSeq() {
<span class="nc" id="L646">		return rollback_recipient_seq;</span>
	}

	public int rollbackRecipientReplay() {
<span class="nc" id="L650">		return rollback_recipient_replay;</span>
	}

	/**
	 * @param seq the sender sequence number to set
	 */
	public synchronized void setSenderSeq(int seq) {
<span class="fc" id="L657">		sender_seq = seq;</span>
<span class="fc" id="L658">	}</span>

	/**
	 * @param seq the recipient sequence number to set
	 */
	public synchronized void setReceiverSeq(int seq) {
<span class="fc" id="L664">		recipient_seq = seq;</span>
<span class="fc" id="L665">	}</span>

	/**
	 * Save the tag of the last processed block
	 * 
	 * @param tag the tag
	 */
	public void setLastBlockTag(byte[] tag) {
<span class="nc" id="L673">		last_block_tag = tag.clone();</span>
<span class="nc" id="L674">	}</span>

	/**
	 * Enables setting the sender key
	 * 
	 * @param senderKey the sender key to set
	 */
	public void setSenderKey(byte[] senderKey) {
<span class="fc" id="L682">		this.sender_key = senderKey.clone();</span>
<span class="fc" id="L683">	}</span>
	
	/**
	 * Enables setting the recipient key
	 * 
	 * @param recipientKey the recipient key to set
	 */
	public void setRecipientKey(byte[] recipientKey) {
<span class="nc" id="L691">		this.recipient_key = recipientKey.clone();</span>
<span class="nc" id="L692">	}</span>
	
	/**
	 * Set the maximum sequence number.
	 * 
	 * @param seqMax the maximum sequence number.
	 */
	public void setSeqMax(int seqMax) {
<span class="fc" id="L700">		this.seqMax = seqMax;</span>
<span class="fc" id="L701">	}</span>

	/**
	 * Sets the valid lengths, in bytes, of constrained variables(ids, IVs and
	 * keys).
	 * 
	 * @throws RuntimeException if not this.common_alg has been initiated
	 */
	private void setLengths() {
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">		if (common_alg != null) {</span>

<span class="fc" id="L712">			iv_length = EncryptCommon.ivLength(common_alg);</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">			if (iv_length &gt; 0) {</span>
<span class="fc" id="L714">				id_length = iv_length - 6; // RFC section 5.2</span>
<span class="fc" id="L715">				key_length = common_alg.getKeySize() / 8;</span>

			} else {
<span class="fc" id="L718">				LOGGER.error(&quot;Unable to set lengths, since algorithm&quot;);</span>
<span class="fc" id="L719">				throw new RuntimeException(&quot;Unable to set lengths, since algorithm&quot;);</span>
			}

		} else {
<span class="nc" id="L723">			LOGGER.error(&quot;Common_alg has not yet been initiated.&quot;);</span>
<span class="nc" id="L724">			throw new RuntimeException(&quot;Common_alg has not yet been initiated.&quot;);</span>
		}
<span class="fc" id="L726">	}</span>

	/**
	 * @return the URI this context is associated with if any.
	 */
	public String getUri() {
<span class="fc" id="L732">		return uri;</span>
	}

	/**
	 * Sets the URI this context is associated with.
	 * (The URI it is saved under in the HashMapCtxDB.)
	 *
	 * This will be set when added to the HashMapCtxDB.
	 *
	 * @param uri the URI this OSCORE context is associated with
	 */
	protected void setUri(String uri) {
<span class="fc" id="L744">		this.uri = uri;</span>
<span class="fc" id="L745">	}</span>

	/**
	 * Get the context re-derivation key.
	 * 
	 * @return the context re-derivation key
	 */
	protected byte[] getContextRederivationKey() {
<span class="fc" id="L753">		return contextRederivationKey;</span>
	}

	/**
	 * Sets the context re-derivation key.
	 * 
	 * @param contextRederivationKey the context re-derivation key to set
	 */
	protected void setContextRederivationKey(byte[] contextRederivationKey) {
<span class="fc" id="L762">		this.contextRederivationKey = contextRederivationKey;</span>
<span class="fc" id="L763">	}</span>

	/**
	 * Check the phase of the context re-derivation process.
	 * 
	 * @return the contextRederivationOngoing
	 */
	public ContextRederivation.PHASE getContextRederivationPhase() {
<span class="fc" id="L771">		return contextRederivationPhase;</span>
	}

	/**
	 * Set the phase of the context re-derivation process.
	 * 
	 * @param contextRederivationPhase the contextRederivationPhase to set
	 */
	public void setContextRederivationPhase(ContextRederivation.PHASE contextRederivationPhase) {
<span class="fc" id="L780">		this.contextRederivationPhase = contextRederivationPhase;</span>
<span class="fc" id="L781">	}</span>

	/**
	 * Increase the sender's sequence number by one
	 *
	 * @throws OSException if the sequence number wraps
	 */
	public synchronized void increaseSenderSeq() throws OSException {
<span class="fc bfc" id="L789" title="All 2 branches covered.">		if (sender_seq &gt;= seqMax) {</span>
<span class="fc" id="L790">			LOGGER.error(&quot;Sequence number wrapped, get a new OSCore context&quot;);</span>
<span class="fc" id="L791">			throw new OSException(&quot;Sequence number wrapped&quot;);</span>
		}
<span class="fc" id="L793">		sender_seq++;</span>
<span class="fc" id="L794">	}</span>

	// TODO: For interop testing
<span class="fc" id="L797">	public static boolean DISABLE_REPLAY_CHECKS = false;</span>


	/**
	 * Checks and sets the sequence number for incoming messages.
	 * 
	 * @param seq the incoming sequence number
	 * 
	 * @throws OSException if the sequence number wraps or if it is a replay
	 */
	public synchronized void checkIncomingSeq(int seq) throws OSException {

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">		if(DISABLE_REPLAY_CHECKS) {</span>
<span class="nc" id="L810">			return;</span>
		}
		
<span class="fc bfc" id="L813" title="All 2 branches covered.">		if (seq &gt;= seqMax) {</span>
<span class="fc" id="L814">			LOGGER.error(&quot;Sequence number wrapped, get new OSCore context&quot;);</span>
<span class="fc" id="L815">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="pc bpc" id="L818" title="1 of 2 branches missed.">		if (seq &lt; internal_recipient_seq) {</span>
<span class="nc" id="L819">			LOGGER.error(&quot;Message too old&quot;);</span>
<span class="nc" id="L820">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="fc bfc" id="L823" title="All 2 branches covered.">		boolean valid = ((recipient_replay_window &gt;&gt; (seq - internal_recipient_seq)) &amp; 1) == 0;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">		if (!valid) {</span>
<span class="fc" id="L825">			LOGGER.error(&quot;Replayed message detected&quot;);</span>
<span class="fc" id="L826">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="fc" id="L829">		recipient_seq = seq;</span>
		// Update window
<span class="fc" id="L831">		int shift = seq - (internal_recipient_seq + recipient_replay_window_size - 1);</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">		if (shift &gt; 0) {</span>
<span class="nc" id="L833">			recipient_replay_window &gt;&gt;= shift;</span>
<span class="nc" id="L834">			internal_recipient_seq += shift;</span>
		}
<span class="fc" id="L836">		recipient_replay_window |= 1 &lt;&lt; (seq - internal_recipient_seq);</span>
<span class="fc" id="L837">	}</span>

	/**
	 * Rolls back the latest recipient sequence number update if any
	 */
	public synchronized void rollBack() {
<span class="nc bnc" id="L843" title="All 2 branches missed.">		if (rollback_recipient_replay != -1) {</span>
<span class="nc" id="L844">			recipient_replay_window = rollback_recipient_replay;</span>
<span class="nc" id="L845">			rollback_recipient_replay = -1;</span>
		}
<span class="nc bnc" id="L847" title="All 2 branches missed.">		if (rollback_recipient_seq != -1) {</span>
<span class="nc" id="L848">			recipient_seq = rollback_recipient_seq;</span>
<span class="nc" id="L849">			rollback_recipient_seq = -1;</span>
		}
<span class="nc bnc" id="L851" title="All 2 branches missed.">		if (this.rollback_last_block_tag != null) {</span>
<span class="nc" id="L852">			this.last_block_tag = this.rollback_last_block_tag;</span>
<span class="nc" id="L853">			this.rollback_last_block_tag = null;</span>
		}
<span class="nc" id="L855">	}</span>

	public static byte[] deriveKey(byte[] secret, byte[] salt, int cbitKey, String digest, byte[] rgbContext)
			throws CoseException {

<span class="fc" id="L860">		final String HMAC_ALG_NAME = &quot;Hmac&quot; + digest;</span>

		try {
<span class="fc" id="L863">			Mac hmac = Mac.getInstance(HMAC_ALG_NAME);</span>
<span class="fc" id="L864">			int hashLen = hmac.getMacLength();</span>

			// Perform extract
<span class="fc" id="L867">			hmac.init(new SecretKeySpec(salt, HMAC_ALG_NAME));</span>
<span class="fc" id="L868">			byte[] rgbExtract = hmac.doFinal(secret);</span>

			// Perform expand
<span class="fc" id="L871">			hmac.init(new SecretKeySpec(rgbExtract, HMAC_ALG_NAME));</span>
<span class="fc" id="L872">			int c = (cbitKey / hashLen) + 1;</span>
<span class="fc" id="L873">			byte[] rgbOut = new byte[cbitKey];</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">			int maxLen = (hashLen * c &gt; cbitKey) ? hashLen * c : cbitKey;</span>
<span class="fc" id="L875">			byte[] T = new byte[maxLen];</span>
<span class="fc" id="L876">			byte[] last = new byte[0];</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">			for (int i = 0; i &lt; c; i++) {</span>
<span class="fc" id="L878">				hmac.reset();</span>
<span class="fc" id="L879">				hmac.update(last);</span>
<span class="fc" id="L880">				hmac.update(rgbContext);</span>
<span class="fc" id="L881">				hmac.update((byte) (i + 1));</span>
<span class="fc" id="L882">				last = hmac.doFinal();</span>
<span class="fc" id="L883">				System.arraycopy(last, 0, T, i * hashLen, hashLen);</span>
			}
<span class="fc" id="L885">			System.arraycopy(T, 0, rgbOut, 0, cbitKey);</span>
<span class="fc" id="L886">			return rgbOut;</span>
<span class="nc" id="L887">		} catch (NoSuchAlgorithmException | InvalidKeyException ex) {</span>
<span class="nc" id="L888">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L889">		} catch (Exception ex) {</span>
<span class="nc" id="L890">			throw new CoseException(&quot;Derivation failure&quot;, ex);</span>
		}
	}

	/**
	 * Converts a byte array to a hexadecimal string representation.
	 *
	 * @param bytes the byte array to convert
	 * @return the string representation
	 */
	private String toHex(byte[] bytes) {
<span class="fc bfc" id="L901" title="All 4 branches covered.">		if(bytes == null || bytes.length == 0) {</span>
<span class="fc" id="L902">			return &quot;&quot;;</span>
		} else {
<span class="fc" id="L904">			return StringUtil.byteArray2Hex(bytes);</span>
		}
	}

	/**
	 * Returns this CoAPCode.
	 * 
	 * @return the coap code
	 */
	public Code getCoAPCode() {
<span class="fc" id="L914">		return CoAPCode;</span>
	}

	/**
	 * Sets this CoAPCode to CoAPCode
	 * 
	 * @param coapCode coap code.
	 */
	public void setCoAPCode(Code coapCode) {
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">		if (coapCode != null) {</span>
<span class="fc" id="L924">			this.CoAPCode = coapCode;</span>
		}
<span class="fc" id="L926">	}</span>

	/**
	 * Initializes the cipher object by calling CCMBlockCipher.encrypt with
	 * dummy data. Doing this at creation of the OSCORE context reduces the
	 * latency for the first request since it would otherwise happen then.
	 * 
	 * @param alg the encryption algorithm used
	 */
	private void initializeCipher(AlgorithmID alg) {
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">		switch (alg) {</span>
		case AES_CCM_16_64_128:
		case AES_CCM_16_128_128:
		case AES_CCM_64_64_128:
		case AES_CCM_64_128_128:

<span class="fc" id="L942">			byte[] key = { (byte) 0xEB, (byte) 0xDE, (byte) 0xBC, (byte) 0x51, (byte) 0xF1, (byte) 0x03,</span>
					(byte) 0x79, (byte) 0x14, (byte) 0x14, (byte) 0x4F, (byte) 0xC3, (byte) 0xAC, (byte) 0x40,
					(byte) 0x14, (byte) 0xD2, (byte) 0x4C };
<span class="fc" id="L945">			byte[] nonce = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };</span>

			try {
<span class="fc" id="L948">				CCMBlockCipher.encrypt(new SecretKeySpec(key, &quot;AES&quot;), nonce, Bytes.EMPTY,</span>
						Bytes.EMPTY, 0);
<span class="nc" id="L950">			} catch (GeneralSecurityException e) {</span>
<span class="nc" id="L951">				LOGGER.error(&quot;Failed to initialize cipher.&quot;);</span>
<span class="nc" id="L952">				throw new RuntimeException(&quot;Failed to initialize cipher.&quot;);</span>
<span class="fc" id="L953">			}</span>

			break;

		default:
			break;
		}
<span class="fc" id="L960">	}</span>

	/**
	 * Create byte array from values.
	 * 
	 * @param values bytes for byte array
	 * @return initialized byte array
	 */
	private static byte[] createByteArray(byte... values) {
<span class="fc" id="L969">		return values;</span>
	}

	/**
	 * Provides a method to check if this context is used for Group OSCORE.
	 * 
	 * @return if this is a group (Group OSCORE) context
	 */
	public boolean isGroupContext() {
<span class="fc bfc" id="L978" title="All 4 branches covered.">		return this instanceof GroupSenderCtx || this instanceof GroupRecipientCtx;</span>
	}

	// TODO: Remove?
	protected GroupSenderCtx getSenderCtx() {
<span class="nc" id="L983">		return null;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
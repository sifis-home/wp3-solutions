<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OptionJuggle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">OptionJuggle.java</span></div><h1>OptionJuggle.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2018 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.californium.core.coap.Option;
import org.eclipse.californium.core.coap.OptionNumberRegistry;
import org.eclipse.californium.core.coap.OptionSet;
import org.eclipse.californium.core.coap.Request;
import org.eclipse.californium.core.coap.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.eclipse.californium.core.coap.CoAP.Code;
import org.eclipse.californium.core.coap.CoAP.ResponseCode;
import org.eclipse.californium.core.coap.Message;

/**
 * 
 * Provides option handling methods necessary for OSCORE mechanics.
 *
 */
<span class="nc" id="L43">public class OptionJuggle {</span>

	/**
	 * The logger
	 */
<span class="fc" id="L48">	private static final Logger LOGGER = LoggerFactory.getLogger(OptionJuggle.class);</span>
	
<span class="fc" id="L50">	private static List&lt;Integer&gt; allEOptions = populateAllEOptions();</span>

	private static List&lt;Integer&gt; populateAllEOptions() {
<span class="fc" id="L53">		List&lt;Integer&gt; allEOptions = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L54">		allEOptions.add(OptionNumberRegistry.IF_MATCH);</span>
<span class="fc" id="L55">		allEOptions.add(OptionNumberRegistry.ETAG);</span>
<span class="fc" id="L56">		allEOptions.add(OptionNumberRegistry.IF_NONE_MATCH);</span>
<span class="fc" id="L57">		allEOptions.add(OptionNumberRegistry.OBSERVE);</span>
<span class="fc" id="L58">		allEOptions.add(OptionNumberRegistry.LOCATION_PATH);</span>
<span class="fc" id="L59">		allEOptions.add(OptionNumberRegistry.URI_PATH);</span>
<span class="fc" id="L60">		allEOptions.add(OptionNumberRegistry.CONTENT_FORMAT);</span>
<span class="fc" id="L61">		allEOptions.add(OptionNumberRegistry.MAX_AGE);</span>
<span class="fc" id="L62">		allEOptions.add(OptionNumberRegistry.URI_QUERY);</span>
<span class="fc" id="L63">		allEOptions.add(OptionNumberRegistry.ACCEPT);</span>
<span class="fc" id="L64">		allEOptions.add(OptionNumberRegistry.LOCATION_QUERY);</span>
<span class="fc" id="L65">		allEOptions.add(OptionNumberRegistry.BLOCK2);</span>
<span class="fc" id="L66">		allEOptions.add(OptionNumberRegistry.BLOCK1);</span>
<span class="fc" id="L67">		allEOptions.add(OptionNumberRegistry.SIZE2);</span>
<span class="fc" id="L68">		allEOptions.add(OptionNumberRegistry.SIZE1);</span>
<span class="fc" id="L69">		return allEOptions;</span>
	}

	/**
	 * Prepare a set or original CoAP options for unprotected use with OSCore.
	 * 
	 * @param options the original options
	 * 
	 * @return the OSCore-U option set
	 */
	public static OptionSet prepareUoptions(OptionSet options) {
<span class="fc" id="L80">		boolean hasProxyUri = options.hasProxyUri();</span>
<span class="fc" id="L81">		boolean hasUriHost = options.hasUriHost();</span>
<span class="fc" id="L82">		boolean hasUriPort = options.hasUriPort();</span>
<span class="fc" id="L83">		boolean hasProxyScheme = options.hasProxyScheme();</span>
<span class="fc" id="L84">		boolean hasMaxAge = options.hasMaxAge();</span>
<span class="fc" id="L85">		boolean hasObserve = options.hasObserve();</span>
<span class="fc" id="L86">		boolean hasEdhoc = options.hasEdhoc(); // EDHOC</span>

<span class="fc" id="L88">		OptionSet ret = new OptionSet();</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">		if (hasUriHost) {</span>
<span class="fc" id="L91">			ret.setUriHost(options.getUriHost());</span>
		}

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">		if (hasUriPort) {</span>
<span class="nc" id="L95">			ret.setUriPort(options.getUriPort());</span>
		}

<span class="pc bpc" id="L98" title="1 of 2 branches missed.">		if (hasMaxAge) {</span>
<span class="nc" id="L99">			ret.setMaxAge(options.getMaxAge());</span>
		}

<span class="pc bpc" id="L102" title="1 of 2 branches missed.">		if (hasProxyScheme) {</span>
<span class="nc" id="L103">			ret.setProxyScheme(options.getProxyScheme());</span>
		}

<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (hasObserve) {</span>
<span class="fc" id="L107">			ret.setObserve(options.getObserve());</span>
		}

<span class="fc bfc" id="L110" title="All 2 branches covered.">		if (hasProxyUri) {</span>
<span class="fc" id="L111">			String proxyUri = options.getProxyUri();</span>
<span class="fc" id="L112">			proxyUri = proxyUri.replace(&quot;coap://&quot;, &quot;&quot;);</span>
<span class="fc" id="L113">			proxyUri = proxyUri.replace(&quot;coaps://&quot;, &quot;&quot;);</span>
<span class="fc" id="L114">			int i = proxyUri.indexOf('/');</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">			if (i &gt;= 0) {</span>
<span class="fc" id="L116">				proxyUri = proxyUri.substring(0, i);</span>
			}
<span class="fc" id="L118">			proxyUri = &quot;coap://&quot; + proxyUri;</span>
<span class="fc" id="L119">			ret.setProxyUri(proxyUri);</span>
		}

<span class="fc" id="L122">		byte[] oscore = options.getOscore();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (oscore != null) {</span>
<span class="fc" id="L124">			ret.setOscore(oscore);</span>
		}

		// EDHOC
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if (hasEdhoc) {</span>
<span class="nc" id="L129">			ret.setEdhoc(true);</span>
		}

<span class="fc" id="L132">		return ret;</span>
	}

	/**
	 * Prepare a set or original CoAP options for encryption with OSCore.
	 * 
	 * @param options the original CoAP options
	 * 
	 * @return the option to be encrypted
	 */
	public static OptionSet prepareEoptions(OptionSet options) {
<span class="fc" id="L143">		OptionSet ret = new OptionSet();</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">		for (Option o : options.asSortedList()) {</span>
<span class="fc bfc" id="L146" title="All 3 branches covered.">			switch (o.getNumber()) {</span>

			case OptionNumberRegistry.URI_HOST:
			case OptionNumberRegistry.URI_PORT:
			case OptionNumberRegistry.PROXY_SCHEME:
			case OptionNumberRegistry.OSCORE:
			case OptionNumberRegistry.EDHOC: // EDHOC
				// do not encrypt
<span class="fc" id="L154">				break;</span>
			case OptionNumberRegistry.PROXY_URI:
				// create Uri-Path and Uri-Query
<span class="fc" id="L157">				String proxyUri = o.getStringValue();</span>
<span class="fc" id="L158">				proxyUri = proxyUri.replace(&quot;coap://&quot;, &quot;&quot;);</span>
<span class="fc" id="L159">				proxyUri = proxyUri.replace(&quot;coaps://&quot;, &quot;&quot;);</span>
<span class="fc" id="L160">				int i = proxyUri.indexOf('/');</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">				if (i &gt;= 0) {</span>
<span class="fc" id="L162">					proxyUri = proxyUri.substring(i + 1, proxyUri.length());</span>
				} else {// No Uri-Path and Uri-Query
					break;
				}
<span class="fc" id="L166">				i = proxyUri.indexOf(&quot;?&quot;);</span>
<span class="fc" id="L167">				String uriPath = proxyUri;</span>
<span class="fc" id="L168">				String uriQuery = null;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">				if (i &gt;= 0) {</span>
<span class="nc" id="L170">					uriPath = proxyUri.substring(0, i);</span>
<span class="nc" id="L171">					uriQuery = proxyUri.substring(i + 1, proxyUri.length());</span>
				}

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">				if (uriPath != null) {</span>
<span class="fc" id="L175">					ret.setUriPath(uriPath);</span>
				}

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">				if (uriQuery != null) {</span>
<span class="nc" id="L179">					String[] uriQueries = uriQuery.split(&quot;&amp;&quot;);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">					for (int idx = 0; idx &lt; uriQueries.length; idx++) {</span>
<span class="nc" id="L181">						ret.setUriQuery(uriQueries[idx]);</span>
					}
<span class="nc" id="L183">				}</span>
				break;
			default: // default is encrypt
<span class="fc" id="L186">				ret.addOption(o);</span>
			}
<span class="fc" id="L188">		}</span>
<span class="fc" id="L189">		return ret;</span>
	}

	/**
	 * Returns a new OptionSet, result, which doesn't contain any e options
	 * 
	 * @param optionSet the options
	 * @return a new optionSet which have had the non-special e options removed
	 */
	public static OptionSet discardEOptions(OptionSet optionSet) {
<span class="fc" id="L199">		LOGGER.info(&quot;Removing inner only E options from the outer options&quot;);</span>
<span class="fc" id="L200">		OptionSet result = new OptionSet();</span>
		
<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (Option opt : optionSet.asSortedList()) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">			if (!allEOptions.contains(opt.getNumber())) {</span>
<span class="fc" id="L204">				result.addOption(opt);</span>
			}
<span class="fc" id="L206">		}</span>
<span class="fc" id="L207">		return result;</span>
	}

	/**
	 * Sets the fake code in the coap header and returns the real code.
	 * 
	 * @param request the request that receives its fake code.
	 * @return request with fake code.
	 */
	public static Request setFakeCodeRequest(Request request) {
<span class="fc bfc" id="L217" title="All 2 branches covered.">		Code fakeCode = request.getOptions().hasObserve() ? Code.FETCH : Code.POST;</span>
<span class="fc" id="L218">		return requestWithNewCode(request, fakeCode);</span>
	}

	/**
	 * Sets the Request's CoAP Code with realCode
	 * 
	 * @param request the request that receives its real code
	 * @param realCode the real code
	 * @return request with real code.
	 */
	public static Request setRealCodeRequest(Request request, Code realCode) {
<span class="fc" id="L229">		return requestWithNewCode(request, realCode);</span>
	}

	/**
	 * Sets the fake code in the coap header and returns the real code.
	 * 
	 * @param response the response that receives its fake code.
	 * @return response with fake code.
	 */
	public static Response setFakeCodeResponse(Response response) {
<span class="fc" id="L239">		return responseWithNewCode(response, ResponseCode.CHANGED);</span>
	}

	/**
	 * Sets the realCode for a response
	 * 
	 * @param response response
	 * @param realCode real code
	 * @return response with real code
	 */
	public static Response setRealCodeResponse(Response response, ResponseCode realCode) {
<span class="fc" id="L250">		return responseWithNewCode(response, realCode);</span>
	}

	/**
	 * Change the CoAP Code of the request to code
	 * 
	 * @param request the Request having its CoAP Code changed
	 * @param code the new CoAP Code
	 * @return request with new code.
	 */
	private static Request requestWithNewCode(Request request, Code code) {
<span class="fc" id="L261">		Request newRequest = new Request(code);</span>
<span class="fc" id="L262">		copy(newRequest, request);</span>
<span class="fc" id="L263">		newRequest.setUserContext(request.getUserContext());</span>

<span class="fc" id="L265">		return newRequest;</span>
	}

	/**
	 * Change the ResponseCode of the response to code
	 * 
	 * @param response the Response having its ResponseCode changed
	 * @param code the new ResponseCode
	 * @return response with new code.
	 */
	private static Response responseWithNewCode(Response response, ResponseCode code) {
<span class="fc" id="L276">		Long rtt = response.getApplicationRttNanos();</span>

<span class="fc" id="L278">		Response newResponse = new Response(code);</span>
<span class="fc" id="L279">		copy(newResponse, response);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">		if (rtt != null) {</span>
<span class="fc" id="L281">			newResponse.setApplicationRttNanos(rtt);</span>
		}

<span class="fc" id="L284">		return newResponse;</span>
	}

	private static void copy(Message newMessage, Message oldMessage) {
<span class="fc" id="L288">		newMessage.setOptions(oldMessage.getOptions());</span>
<span class="fc" id="L289">		newMessage.setPayload(oldMessage.getPayload());</span>
<span class="fc" id="L290">		newMessage.setToken(oldMessage.getToken());</span>
<span class="fc" id="L291">		newMessage.setDestinationContext(oldMessage.getDestinationContext());</span>
<span class="fc" id="L292">		newMessage.setSourceContext(oldMessage.getSourceContext());</span>
<span class="fc" id="L293">		newMessage.addMessageObservers(oldMessage.getMessageObservers());</span>
<span class="fc" id="L294">		newMessage.setMID(oldMessage.getMID());</span>
<span class="fc" id="L295">		newMessage.setType(oldMessage.getType());</span>
<span class="fc" id="L296">		newMessage.setDuplicate(oldMessage.isDuplicate());</span>
<span class="fc" id="L297">		newMessage.setNanoTimestamp(oldMessage.getNanoTimestamp());</span>
<span class="fc" id="L298">	}</span>

	/**
	 * Merges two optionSets and returns the merge. Priority is eOptions
	 * 
	 * @param eOptions priority options
	 * @param uOptions options to be added
	 * @return merged OptionSet
	 */
	public static OptionSet merge(OptionSet eOptions, OptionSet uOptions) {

<span class="fc" id="L309">		List&lt;Option&gt; u = uOptions.asSortedList();</span>

<span class="fc bfc" id="L311" title="All 2 branches covered.">		for (Option tmp : u) {</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">			if (!eOptions.hasOption(tmp.getNumber())) {</span>
<span class="fc" id="L313">				eOptions.addOption(tmp);</span>
			}
<span class="fc" id="L315">		}</span>
<span class="fc" id="L316">		return eOptions;</span>
	}

	// FIXME: For below use instead OscoreOptionDecoder/Encoder

	/**
	 * Retrieve RID value from an OSCORE option.
	 * 
	 * @param oscoreOption the OSCORE option
	 * @return the RID value
	 */
	static byte[] getRid(byte[] oscoreOption) {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (oscoreOption.length == 0) {</span>
<span class="nc" id="L329">			return null;</span>
		}
	
		// Parse the flag byte
<span class="fc" id="L333">		byte flagByte = oscoreOption[0];</span>
<span class="fc" id="L334">		int n = flagByte &amp; 0x07;</span>
<span class="fc" id="L335">		int k = flagByte &amp; 0x08;</span>
<span class="fc" id="L336">		int h = flagByte &amp; 0x10;</span>
	
<span class="fc" id="L338">		byte[] kid = null;</span>
<span class="fc" id="L339">		int index = 1;</span>
	
		// Partial IV
<span class="fc" id="L342">		index += n;</span>
	
		// KID Context
<span class="fc bfc" id="L345" title="All 2 branches covered.">		if (h != 0) {</span>
<span class="fc" id="L346">			int s = oscoreOption[index];</span>
<span class="fc" id="L347">			index += s + 1;</span>
		}
	
		// KID
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (k != 0) {</span>
<span class="fc" id="L352">			kid = Arrays.copyOfRange(oscoreOption, index, oscoreOption.length);</span>
		}
	
<span class="fc" id="L355">		return kid;</span>
	}

	/**
	 * Retrieve ID Context value from an OSCORE option.
	 * 
	 * @param oscoreOption the OSCORE option
	 * @return the ID Context value
	 */
	static byte[] getIDContext(byte[] oscoreOption) {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">		if (oscoreOption.length == 0) {</span>
<span class="nc" id="L366">			return null;</span>
		}

		// Parse the flag byte
<span class="fc" id="L370">		byte flagByte = oscoreOption[0];</span>
<span class="fc" id="L371">		int n = flagByte &amp; 0x07;</span>
<span class="fc" id="L372">		int h = flagByte &amp; 0x10;</span>

<span class="fc" id="L374">		byte[] kidContext = null;</span>
<span class="fc" id="L375">		int index = 1;</span>

		// Partial IV
<span class="fc" id="L378">		index += n;</span>

		// KID Context
<span class="fc bfc" id="L381" title="All 2 branches covered.">		if (h != 0) {</span>
<span class="fc" id="L382">			int s = oscoreOption[index];</span>
<span class="fc" id="L383">			kidContext = Arrays.copyOfRange(oscoreOption, index + 1, index + 1 + s);</span>
<span class="fc" id="L384">			index += s + 1;</span>
		}

<span class="fc" id="L387">		return kidContext;</span>
	}

	/**
	 * Retrieve Partial IV (sequence nr.) value from an OSCORE option.
	 * 
	 * @param oscoreOption the OSCORE option
	 * @return the Partial IV value
	 */
	static int getPartialIV(byte[] oscoreOption) {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		if (oscoreOption.length == 0) {</span>
<span class="nc" id="L398">			return -1;</span>
		}

		// Parse the flag byte
<span class="fc" id="L402">		byte flagByte = oscoreOption[0];</span>
<span class="fc" id="L403">		int n = flagByte &amp; 0x07;</span>

<span class="fc" id="L405">		byte[] partialIV = null;</span>
<span class="fc" id="L406">		int index = 1;</span>

		// Parsing Partial IV
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">		if (n &gt; 0) {</span>
<span class="fc" id="L410">				partialIV = Arrays.copyOfRange(oscoreOption, index, index + n);</span>
		} else {
<span class="nc" id="L412">			return -1;</span>
		}

		// TODO: Avoid using BigInteger
<span class="fc" id="L416">		BigInteger partialIVBi = new BigInteger(partialIV);</span>
<span class="fc" id="L417">		int ret = partialIVBi.intValue();</span>

<span class="fc" id="L419">		return ret;</span>
	}

	/**
	 * Check the group mode bit value from an OSCORE option.
	 * 
	 * @param oscoreOption the OSCORE option
	 * @return if the group mode bit is set
	 */
	static boolean getGroupModeBit(byte[] oscoreOption) {
<span class="fc bfc" id="L429" title="All 2 branches covered.">		if (oscoreOption.length == 0) {</span>
<span class="fc" id="L430">			return false;</span>
		}

		// Parse the flag byte
<span class="fc" id="L434">		byte flagByte = oscoreOption[0];</span>
<span class="fc" id="L435">		int g = flagByte &amp; 0x20;</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (g != 0) {</span>
<span class="fc" id="L438">			return true;</span>
		} else {
<span class="fc" id="L440">			return false;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyRemapping.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-EDHOC</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.edhoc</a> &gt; <span class="el_source">KeyRemapping.java</span></div><h1>KeyRemapping.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2020 RISE and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Rikard HÃ¶glund (RISE)
 *    
 ******************************************************************************/
package org.eclipse.californium.edhoc;

import java.math.BigInteger;
import java.security.Provider;
import java.security.Security;
import java.util.Arrays;

import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;
import org.eclipse.californium.elements.util.StringUtil;

import net.i2p.crypto.eddsa.EdDSAPublicKey;
import net.i2p.crypto.eddsa.EdDSASecurityProvider;
import net.i2p.crypto.eddsa.math.Field;
import net.i2p.crypto.eddsa.math.FieldElement;
import net.i2p.crypto.eddsa.math.bigint.BigIntegerFieldElement;
import net.i2p.crypto.eddsa.math.bigint.BigIntegerLittleEndianEncoding;

/**
 * Class implementing functionality for key remapping from Edwards coordinates
 * to Montgomery coordinates.
 *
 */
<span class="nc" id="L42">public class KeyRemapping {</span>

	/*
	 * Useful links:
	 * https://crypto.stackexchange.com/questions/63732/curve-25519-x25519-
	 * ed25519-convert-coordinates-between-montgomery-curve-and-t/63734
	 * 
	 * https://tools.ietf.org/html/rfc7748
	 * 
	 * https://tools.ietf.org/html/rfc8032
	 */

	// Create the ed25519 field
<span class="fc" id="L55">	private static Field ed25519Field = new Field(256, // b</span>
<span class="fc" id="L56">			StringUtil.hex2ByteArray(&quot;edffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f&quot;), // q(2^255-19)</span>
			new BigIntegerLittleEndianEncoding());

	// Value of sqrt(-486664) hardcoded (note that there are 2 roots)
<span class="fc" id="L60">	private static BigIntegerFieldElement root = new BigIntegerFieldElement(ed25519Field,</span>
			new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));

	/**
	 * Main method running a number of tests on the code.
	 * 
	 * @param args command line arguments
	 * @throws Exception on failure in some of the tests
	 */
	public static void main(String args[]) throws Exception {
<span class="nc" id="L70">		Provider EdDSA = new EdDSASecurityProvider();</span>
<span class="nc" id="L71">		Security.insertProviderAt(EdDSA, 1);</span>

		// Define test values x and y from RFC7748. Created as field elements to
		// use for calculations in the field.
<span class="nc" id="L75">		BigIntegerFieldElement x = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;15112221349535400772501151409588531511454012693041857206046113283949847762202&quot;));
<span class="nc" id="L77">		BigIntegerFieldElement y = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;46316835694926478169428394003475163141307993866256225615783033603165251855960&quot;));

		// Define correctly calculated values of u and v from RFC7748
<span class="nc" id="L81">		BigIntegerFieldElement u_correct = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;9&quot;));</span>
<span class="nc" id="L82">		BigIntegerFieldElement v_correct = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;14781619447589544791020593568409986887264606134616475288964881837755586237401&quot;));

		// Calculate u and v values
<span class="nc" id="L86">		FieldElement u = calcCurve25519_u(y);</span>
<span class="nc" id="L87">		FieldElement v = calcCurve25519_v(x, u);</span>

		// Print calculated values
<span class="nc" id="L90">		System.out.println(&quot;x: &quot; + x);</span>
<span class="nc" id="L91">		System.out.println(&quot;y: &quot; + y);</span>

<span class="nc" id="L93">		System.out.println(&quot;v: &quot; + v);</span>
<span class="nc" id="L94">		System.out.println(&quot;u: &quot; + u);</span>

		// Check that calculated u and v values are correct
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (Arrays.equals(u.toByteArray(), u_correct.toByteArray())) {</span>
<span class="nc" id="L98">			System.out.println(&quot;u value is correct!&quot;);</span>
		} else {
<span class="nc" id="L100">			System.out.println(&quot;u value is INCORRECT!&quot;);</span>
		}
<span class="nc bnc" id="L102" title="All 2 branches missed.">		if (Arrays.equals(v.toByteArray(), v_correct.toByteArray())) {</span>
<span class="nc" id="L103">			System.out.println(&quot;v value is correct!&quot;);</span>
		} else {
<span class="nc" id="L105">			System.out.println(&quot;v value is INCORRECT!&quot;);</span>
		}

		/**/
<span class="nc" id="L109">		System.out.println();</span>
<span class="nc" id="L110">		System.out.println();</span>
		/**/

		// Testing starting with a COSE Key

<span class="nc" id="L115">		OneKey myKey = OneKey.generateKey(AlgorithmID.EDDSA);</span>
<span class="nc" id="L116">		FieldElement y_fromKeyAlt = extractCOSE_y_alt(myKey);</span>
<span class="nc" id="L117">		FieldElement y_fromKey = extractCOSE_y(myKey);</span>

<span class="nc" id="L119">		System.out.println(&quot;y from COSE key (alt): &quot; + y_fromKeyAlt);</span>
<span class="nc" id="L120">		System.out.println(&quot;y from COSE key: &quot; + y_fromKey);</span>
<span class="nc" id="L121">		System.out.println(&quot;COSE key X param_: &quot; + myKey.get(KeyKeys.OKP_X));</span>

<span class="nc" id="L123">		System.out.println(&quot;y from COSE key (alt) (bytes): &quot; + StringUtil.byteArray2HexString(y_fromKeyAlt.toByteArray()));</span>
<span class="nc" id="L124">		System.out.println(&quot;y from COSE key (bytes): &quot; + StringUtil.byteArray2HexString(y_fromKey.toByteArray()));</span>

		// Check that calculating y in both ways give the same result
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (Arrays.equals(y_fromKeyAlt.toByteArray(), y_fromKey.toByteArray())) {</span>
<span class="nc" id="L128">			System.out.println(&quot;y from key value is correct!&quot;);</span>
		} else {
<span class="nc" id="L130">			System.out.println(&quot;y from key value is INCORRECT!&quot;);</span>
		}

		/**/
<span class="nc" id="L134">		System.out.println();</span>
<span class="nc" id="L135">		System.out.println();</span>
		/**/

<span class="nc" id="L138">		FieldElement x_fromKey = extractCOSE_x(myKey);</span>
<span class="nc" id="L139">		System.out.println(&quot;x from COSE key: &quot; + x_fromKey);</span>

<span class="nc" id="L141">		FieldElement uuu1 = calcCurve25519_u(y_fromKeyAlt);</span>
<span class="nc" id="L142">		FieldElement uuu2 = calcCurve25519_u(y_fromKey);</span>
		// calcCurve25519_v(x_fromKey, uuu1);
		// calcCurve25519_v(x_fromKey, uuu2);
		//
<span class="nc" id="L146">		System.out.println(uuu1);</span>
<span class="nc" id="L147">		System.out.println(uuu2);</span>

<span class="nc" id="L149">	}</span>

	/**
	 * Calculate Curve25519 u coordinate from Ed25519 y coordinate
	 * 
	 * @param y the Ed25519 y coordinate
	 * @return the Curve25519 u coordinate
	 */
	static FieldElement calcCurve25519_u(FieldElement y) {

		/* Calculate u from y */
		// u = (1+y)/(1-y)

		// 1 + y -&gt; y + 1
<span class="fc" id="L163">		FieldElement one_plus_y = y.addOne();</span>

		// 1 - y -&gt; -y + 1
<span class="fc" id="L166">		FieldElement one_minus_y = (y.negate()).addOne();</span>

		// invert(1 - y)
<span class="fc" id="L169">		FieldElement one_minus_y_invert = one_minus_y.invert();</span>

		// (1 + y) / (1 - y) -&gt; (1 + y) * invert(1 - y)
<span class="fc" id="L172">		FieldElement u = one_plus_y.multiply(one_minus_y_invert);</span>

<span class="fc" id="L174">		return u;</span>

	}

	/**
	 * Calculate Curve25519 v coordinate from Ed25519 x coordinate and
	 * Curve25519 u coordinate
	 * 
	 * @param x the Ed25519 x coordinate
	 * @param u the Curve25519 u coordinate
	 * @return the Curve25519 v coordinate
	 */
	static FieldElement calcCurve25519_v(FieldElement x, FieldElement u) {

		/* Calculate v from u and x */
		// v = sqrt(-486664)*u/x

		// invert(x)
<span class="fc" id="L192">		FieldElement x_invert = x.invert();</span>

		// u / x -&gt; u * invert(x)
<span class="fc" id="L195">		FieldElement u_over_x = u.multiply(x_invert);</span>

		// calculate v
<span class="fc" id="L198">		FieldElement v = root.multiply(u_over_x);</span>

<span class="fc" id="L200">		return v;</span>
	}

	/**
	 * BigInteger z_2_bi = new BigInteger(invertArray(z_2.toByteArray()));
	 * BigIntegerFieldElement z_2_bif = new BigIntegerFieldElement(ed25519Field,
	 * z_2_bi);
	 */

	/**
	 * Calculate Curve25519 v coordinate from Ed25519 x coordinate and
	 * Curve25519 u coordinate
	 * 
	 * @param x the Ed25519 x coordinate
	 * @param u the Curve25519 u coordinate
	 * @return the Curve25519 v coordinate
	 */
	static FieldElement calcCurve25519_v_alt(FieldElement x, FieldElement u) {

		/* Calculate v from u and x */
		// v = sqrt(-486664)*u/x

		// invert(x)
<span class="nc" id="L223">		FieldElement x_invert = x.invert();</span>

		// u / x -&gt; u * invert(x)
<span class="nc" id="L226">		FieldElement _x_invert = ed25519ToBiginteger(x_invert);</span>
<span class="nc" id="L227">		FieldElement u_over_x = u.multiply(_x_invert);</span>

		// calculate v
<span class="nc" id="L230">		FieldElement v = root.multiply(u_over_x);</span>

<span class="nc" id="L232">		return v;</span>
	}

	/**
	 * Convert a Ed25519FieldElement to a BigIntegerFieldElement
	 * 
	 * @param input the Ed25519FieldElement
	 * @return the resulting BigIntegerFieldElement
	 */
	static BigIntegerFieldElement ed25519ToBiginteger(FieldElement input) {
<span class="nc" id="L242">		BigInteger outputBi = new BigInteger(invertArray(input.toByteArray()));</span>
<span class="nc" id="L243">		BigIntegerFieldElement outputFieldElement = new BigIntegerFieldElement(ed25519Field, outputBi);</span>

<span class="nc" id="L245">		return outputFieldElement;</span>
	}

	/* COSE related functions below */

	/**
	 * Extract the y point coordinate from a COSE Key (OneKey). Alternative way
	 * using division.
	 * 
	 * @param key the COSE key
	 * @return the y point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_y_alt(OneKey key) throws CoseException {
<span class="fc" id="L260">		EdDSAPublicKey pubKey = (EdDSAPublicKey) key.AsPublicKey();</span>

		// Get projective coordinates for Y and Z
<span class="fc" id="L263">		FieldElement Y = pubKey.getA().getY();</span>
<span class="fc" id="L264">		FieldElement Z = pubKey.getA().getZ();</span>

		// y = Y/Z -&gt; y = Y * invert(Z)
<span class="fc" id="L267">		FieldElement recip = Z.invert();</span>
<span class="fc" id="L268">		FieldElement y = Y.multiply(recip);</span>

<span class="fc" id="L270">		return y;</span>
	}

	/**
	 * Extract the y point coordinate from a COSE Key (OneKey). Way using the X
	 * value of the key directly, clearing one bit.
	 * https://tools.ietf.org/html/rfc8032#section-5.1.2
	 * 
	 * @param key the COSE key
	 * @return the y point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_y(OneKey key) throws CoseException {

		// Retrieve X value from COSE key as byte array
<span class="fc" id="L286">		byte[] X_value = key.get(KeyKeys.OKP_X).GetByteString();</span>

		// Clear most significant bit of the final octet in the X value (that
		// indicates sign of x coordinate). The result is the y coordinate.
<span class="fc" id="L290">		byte[] y_array = X_value.clone();</span>
<span class="fc" id="L291">		y_array[y_array.length - 1] &amp;= 0B01111111;</span>

		// The array must be reversed to have correct byte order
		// BigInteger wants Big Endian but it is in Little Endian
<span class="fc" id="L295">		byte[] y_array_inv = invertArray(y_array);</span>

		// Create field element for y from updated X value
<span class="fc" id="L298">		FieldElement y = new BigIntegerFieldElement(ed25519Field, new BigInteger(y_array_inv));</span>

<span class="fc" id="L300">		return y;</span>
	}

	/**
	 * Extract the x point coordinate from a COSE Key (OneKey). Way using
	 * division.
	 * 
	 * @param key the COSE key
	 * @return the x point coordinate
	 * 
	 * @throws CoseException if retrieving public key part fails
	 */
	static FieldElement extractCOSE_x(OneKey key) throws CoseException {
<span class="fc" id="L313">		EdDSAPublicKey pubKey = (EdDSAPublicKey) key.AsPublicKey();</span>

		// Get projective coordinates for X and Z
<span class="fc" id="L316">		FieldElement X = pubKey.getA().getX();</span>
<span class="fc" id="L317">		FieldElement Z = pubKey.getA().getZ();</span>

		// x = X/Z -&gt; x = X * invert(Z)
<span class="fc" id="L320">		FieldElement recip = Z.invert();</span>
<span class="fc" id="L321">		FieldElement x = X.multiply(recip);</span>

<span class="fc" id="L323">		return x;</span>
	}

	/**
	 * Invert a byte array
	 * 
	 * @param input the input byte array
	 * @return the inverted byte array
	 */
	public static byte[] invertArray(byte[] input) {
<span class="fc" id="L333">		byte[] output = input.clone();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">		for (int i = 0; i &lt; input.length; i++) {</span>
<span class="fc" id="L335">			output[i] = input[input.length - i - 1];</span>
		}
<span class="fc" id="L337">		return output;</span>
	}

	/* Methods for Weierstrass conversions below */
	// https://tools.ietf.org/html/draft-ietf-lwig-curve-representations-10#appendix-E.2

	/**
	 * Remap a Curve25519 u coordinate to a Wei25519 X coordinate.
	 * 
	 * @param u the Curve25519 u coordinate
	 * 
	 * @return the Wei25519 X coordinate
	 */
	public static FieldElement curve25519uToWei25519X(FieldElement u) {
<span class="fc" id="L351">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L352">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>

		// X = u + A/3
<span class="fc" id="L355">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L357">		FieldElement X = u.add(AoverThree);</span>

<span class="fc" id="L359">		return X;</span>

	}

	/**
	 * Remap a Curve25519 v coordinate to a Wei25519 Y coordinate.
	 * 
	 * @param v the Curve25519 v coordinate
	 * 
	 * @return the Wei25519 Y coordinate
	 */
	public static FieldElement curve25519vToWei25519Y(FieldElement v) {
		// Y = v
<span class="fc" id="L372">		FieldElement Y = v;</span>

<span class="fc" id="L374">		return Y;</span>
	}

	/**
	 * Remap a Wei25519 X coordinate to a Curve25519 u coordinate.
	 * 
	 * @param X the Wei25519 X coordinate
	 * 
	 * @return the Curve25519 u coordinate
	 */
	public static FieldElement wei25519XToCurve25519u(FieldElement X) {
<span class="fc" id="L385">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L386">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>

		// u = X - A/3
<span class="fc" id="L389">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L391">		FieldElement u = X.subtract(AoverThree);</span>

<span class="fc" id="L393">		return u;</span>
	}

	/**
	 * Remap a Wei25519 Y coordinate to a Curve25519 v coordinate.
	 * 
	 * @param Y the Wei25519 Y coordinate
	 * 
	 * @return the Curve25519 v coordinate
	 */
	public static FieldElement wei25519YToCurve25519v(FieldElement Y) {
		// v = Y
<span class="fc" id="L405">		FieldElement v = Y;</span>

<span class="fc" id="L407">		return v;</span>

	}

	/**
	 * Remap a Edwards25519 y coordinate to a Wei25519 X coordinate
	 * 
	 * @param y the Edwards25519 y coordinate
	 * @return the Wei25519 X coordinate
	 */
	public static FieldElement edwards25519yToWei25519X(FieldElement y) {
		// X = ((1+y)/(1-y)+A/3

<span class="fc" id="L420">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L421">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L422">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>
<span class="fc" id="L423">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L425">		FieldElement onePlusY = one.add(y);</span>
<span class="fc" id="L426">		FieldElement oneMinusY = one.subtract(y);</span>

<span class="fc" id="L428">		FieldElement divided = onePlusY.multiply(oneMinusY.invert());</span>

<span class="fc" id="L430">		FieldElement X = divided.add(AoverThree);</span>

<span class="fc" id="L432">		return X;</span>
	}

	/**
	 * Remap a Edwards25519 x (&amp; y) coordinate to a Wei25519 Y coordinate
	 * 
	 * @param x the Edwards25519 x coordinate
	 * @param y the Edwards25519 y coordinate
	 * @return the Wei25519 Y coordinate
	 */
	public static FieldElement edwards25519xToWei25519Y(FieldElement x, FieldElement y) {
		// Y = c*(1+y)/((1-y)*x)

<span class="fc" id="L445">		BigIntegerFieldElement c = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));
<span class="fc" id="L447">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>

<span class="fc" id="L449">		FieldElement onePlusY = one.add(y);</span>
<span class="fc" id="L450">		FieldElement oneMinusY = one.subtract(y);</span>

<span class="fc" id="L452">		FieldElement onePlusYmultC = c.multiply(onePlusY);</span>
<span class="fc" id="L453">		FieldElement oneMinusYmultX = oneMinusY.multiply(x);</span>

<span class="fc" id="L455">		FieldElement Y = onePlusYmultC.multiply((oneMinusYmultX.invert()));</span>

<span class="fc" id="L457">		return Y;</span>
	}

	/**
	 * Remap a Weierstrass X coordinate to a Edwards25519 y coordinate
	 * 
	 * @param X the Weierstrass X coordinate
	 * @return the Edwards25519 y coordinate
	 */
	public static FieldElement wei25519XToEdwards25519y(FieldElement X) {
		// y = (X-A/3-1)/(X-A/3+1)

<span class="fc" id="L469">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L470">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L471">		BigIntegerFieldElement one = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;1&quot;));</span>
<span class="fc" id="L472">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L474">		FieldElement numerator = X.subtract(AoverThree).subtract(one);</span>
<span class="fc" id="L475">		FieldElement denominator = X.subtract(AoverThree).add(one);</span>

<span class="fc" id="L477">		FieldElement y = numerator.multiply(denominator.invert());</span>

<span class="fc" id="L479">		return y;</span>
	}

	/**
	 * Remap a Weierstrass Y (&amp; X) coordinate to an Edwards25519 x coordinate
	 * 
	 * @param Y the Weierstrass Y coordinate
	 * @param X the Weierstrass X coordinate
	 * @return the Edwards25519 x coordinate
	 */
	public static FieldElement wei25519YToEdwards25519x(FieldElement Y, FieldElement X) {
		// x = (c*(X-A/3)/Y

<span class="fc" id="L492">		BigIntegerFieldElement c = new BigIntegerFieldElement(ed25519Field,</span>
				new BigInteger(&quot;51042569399160536130206135233146329284152202253034631822681833788666877215207&quot;));

<span class="fc" id="L495">		BigIntegerFieldElement A = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;486662&quot;));</span>
<span class="fc" id="L496">		BigIntegerFieldElement three = new BigIntegerFieldElement(ed25519Field, new BigInteger(&quot;3&quot;));</span>
<span class="fc" id="L497">		FieldElement AoverThree = A.multiply(three.invert());</span>

<span class="fc" id="L499">		FieldElement XminusAoverThree = X.subtract(AoverThree);</span>

<span class="fc" id="L501">		FieldElement numerator = XminusAoverThree.multiply(c);</span>
<span class="fc" id="L502">		FieldElement denominator = Y;</span>

<span class="fc" id="L504">		FieldElement x = numerator.multiply(denominator.invert());</span>

<span class="fc" id="L506">		return x;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>